
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>drudge.drudge &#8212; drudge 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for drudge.drudge</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;The main drudge and tensor class definition.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="k">import</span> <span class="n">Math</span><span class="p">,</span> <span class="n">display</span>
<span class="kn">from</span> <span class="nn">pyspark</span> <span class="k">import</span> <span class="n">RDD</span><span class="p">,</span> <span class="n">SparkContext</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">latex</span><span class="p">,</span> <span class="n">symbols</span>

<span class="kn">from</span> <span class="nn">.canonpy</span> <span class="k">import</span> <span class="n">Perm</span><span class="p">,</span> <span class="n">Group</span>
<span class="kn">from</span> <span class="nn">.report</span> <span class="k">import</span> <span class="n">Report</span>
<span class="kn">from</span> <span class="nn">.term</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Range</span><span class="p">,</span> <span class="n">sum_term</span><span class="p">,</span> <span class="n">Term</span><span class="p">,</span> <span class="n">parse_term</span><span class="p">,</span> <span class="n">Vec</span><span class="p">,</span> <span class="n">subst_factor_in_term</span><span class="p">,</span>
    <span class="n">subst_vec_in_term</span><span class="p">,</span> <span class="n">parse_terms</span><span class="p">,</span> <span class="n">einst_term</span><span class="p">,</span> <span class="n">diff_term</span><span class="p">,</span> <span class="n">try_resolve_range</span><span class="p">,</span>
    <span class="n">rewrite_term</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">ensure_symb</span><span class="p">,</span> <span class="n">BCastVar</span><span class="p">,</span> <span class="n">nest_bind</span><span class="p">,</span> <span class="n">prod_</span>


<div class="viewcode-block" id="Tensor"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor">[docs]</a><span class="k">class</span> <span class="nc">Tensor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The main tensor class.</span>

<span class="sd">    A tensor is an aggregate of terms distributed and managed by Spark.  Here</span>
<span class="sd">    most operations needed for tensors are defined.</span>

<span class="sd">    Normally, tensor instances are created from drudge methods or tensor</span>
<span class="sd">    operations.  Direct invocation of its constructor is seldom in user scripts.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;_drudge&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_terms&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_local_terms&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_free_vars&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_expanded&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_repartitioned&#39;</span>
    <span class="p">]</span>

    <span class="c1">#</span>
    <span class="c1"># Term creation</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.__init__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drudge</span><span class="p">:</span> <span class="s1">&#39;Drudge&#39;</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">RDD</span><span class="p">,</span>
                 <span class="n">free_vars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repartitioned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the tensor.</span>

<span class="sd">        This function is not designed to be called by users directly.  Tensor</span>
<span class="sd">        creation should be carried out by factory function inside drudges and</span>
<span class="sd">        the operations defined here.</span>

<span class="sd">        The default values for the keyword arguments are always the safest</span>
<span class="sd">        choice, for better performance, manipulations are encouraged to have</span>
<span class="sd">        proper consideration of all the keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="n">drudge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">=</span> <span class="n">terms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: typing.List[Term]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_free_vars</span> <span class="o">=</span> <span class="n">free_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span> <span class="o">=</span> <span class="n">expanded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span> <span class="o">=</span> <span class="n">repartitioned</span></div>

    <span class="c1"># To be used by the apply method.</span>
    <span class="n">_INIT_ARGS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;free_vars&#39;</span><span class="p">:</span> <span class="s1">&#39;_free_vars&#39;</span><span class="p">,</span>
        <span class="s1">&#39;expanded&#39;</span><span class="p">:</span> <span class="s1">&#39;_expanded&#39;</span><span class="p">,</span>
        <span class="s1">&#39;repartitioned&#39;</span><span class="p">:</span> <span class="s1">&#39;_repartitioned&#39;</span>
    <span class="p">}</span>

    <span class="c1">#</span>
    <span class="c1"># Basic information</span>
    <span class="c1">#</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">drudge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The drudge created the tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The terms in the tensor, as an RDD object.</span>

<span class="sd">        Although for users, normally there is no need for direct manipulation of</span>
<span class="sd">        the terms, it is still exposed here for flexibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">local_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Gather the terms locally into a list.</span>

<span class="sd">        The list returned by this is for read-only and should **never** be</span>
<span class="sd">        mutated.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method will gather all terms into the memory of the driver.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the number of terms.</span>

<span class="sd">        A zero number of terms signatures a zero tensor.  Accessing this</span>
<span class="sd">        property will make the tensor to be cached automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>  <span class="c1"># We never get a tensor just to count its terms.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

<div class="viewcode-block" id="Tensor.cache"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.cache">[docs]</a>    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cache the terms in the tensor.</span>

<span class="sd">        This method should be called when this tensor is an intermediate result</span>
<span class="sd">        that will be used multiple times.  The tensor itself will be returned</span>
<span class="sd">        for the ease of chaining.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Tensor.repartition"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.repartition">[docs]</a>    <span class="k">def</span> <span class="nf">repartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_partitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Repartition the terms across the Spark cluster.</span>

<span class="sd">        This function should be called when the terms need to be rebalanced</span>
<span class="sd">        among the workers.  Note that this incurs an Spark RDD shuffle operation</span>
<span class="sd">        and might be very expensive.  Its invocation and the number of</span>
<span class="sd">        partitions used need to be fine-tuned for different problems to achieve</span>
<span class="sd">        good performance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        num_partitions : int</span>
<span class="sd">            The number of partitions.  By default, the number is read from the</span>
<span class="sd">            drudge object.</span>

<span class="sd">        cache : bool</span>
<span class="sd">            If the result is going to be cached.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span><span class="p">:</span>

            <span class="n">num_partitions</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">num_partitions</span> <span class="k">if</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                <span class="n">num_partitions</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No default number of partitions available&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the tensor is a scalar.</span>

<span class="sd">        A tensor is considered a scalar when none of its terms has a vector</span>
<span class="sd">        part.  This property will make the tensor automatically cached.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;The free variables in the tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_free_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_vars</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_free_vars</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the free variables in the given terms.&quot;&quot;&quot;</span>

        <span class="c1"># The terms are definitely going to be used for other purposes.</span>
        <span class="n">terms</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="nb">set</span><span class="p">(),</span> <span class="n">_union</span><span class="p">,</span> <span class="n">_union</span><span class="p">)</span>
        <span class="c1"># TODO: investigate performance characteristic with treeAggregate.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the tensor is already expanded.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">repartitioned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the terms in the tensor is already repartitioned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span>

<div class="viewcode-block" id="Tensor.has_base"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.has_base">[docs]</a>    <span class="k">def</span> <span class="nf">has_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Vec</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find if the tensor has the given scalar or vector base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        base</span>
<span class="sd">            The base whose presence is to be queried.  When it is indexed base</span>
<span class="sd">            or a plain symbol, its presence in the amplitude part is tested.</span>
<span class="sd">            When it is a vector, its presence in the vector part is tested.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">has_base</span><span class="p">(</span><span class="n">base</span><span class="p">))</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Printing support</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.__str__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the string representation of the tensor.</span>

<span class="sd">        Note that this function will **gather** all terms into the driver.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_terms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_terms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.latex"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.latex">[docs]</a>    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the latex form for the tensor.</span>

<span class="sd">        The actual printing is dispatched to the drudge object for the</span>
<span class="sd">        convenience of tuning the appearance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sep_lines : bool</span>
<span class="sd">            If terms should be put into separate lines by separating them with</span>
<span class="sd">            ``\\``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">format_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="n">sep_lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.display"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">if_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the tensor in interactive IPython notebook sessions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        if_return</span>
<span class="sd">            If the resulted equation be returned rather than directly displayed.</span>
<span class="sd">            It can be disabled for displaying equation in the middle of a</span>
<span class="sd">            Jupyter cell.</span>

<span class="sd">        sep_lines</span>
<span class="sd">            If terms should be written into separate lines.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">form</span> <span class="o">=</span> <span class="n">Math</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">sep_lines</span><span class="o">=</span><span class="n">sep_lines</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">if_return</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">form</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
            <span class="k">return</span></div>

    <span class="c1">#</span>
    <span class="c1"># Pickling support</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.__getstate__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__getstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current state of the tensor.</span>

<span class="sd">        Here we just have the local terms.  Other cached information are</span>
<span class="sd">        discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_terms</span></div>

<div class="viewcode-block" id="Tensor.__setstate__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__setstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the state for the new tensor.</span>

<span class="sd">        This function reads the drudge to use from the module attribute, which</span>
<span class="sd">        is set in the :py:meth:`Drudge.pickle_env` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">drudge</span> <span class="o">=</span> <span class="n">_default_drudge</span>
        <span class="k">if</span> <span class="n">drudge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Tensor objects cannot be unpickled, &#39;</span>
                <span class="s1">&#39;need to be inside Drudge.pickle_env&#39;</span>
            <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drudge</span><span class="p">,</span> <span class="n">Drudge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">drudge</span><span class="p">,</span> <span class="n">drudge</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
        <span class="k">return</span></div>

    <span class="c1">#</span>
    <span class="c1"># Small manipulations</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.apply"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the given function to the RDD of terms.</span>

<span class="sd">        This function is analogous to the replace function of Python named</span>
<span class="sd">        tuples, the same value from self for the tensor initializer is going to</span>
<span class="sd">        be used when it is not given.  The terms get special treatment since it</span>
<span class="sd">        is the centre of tensor objects.  The drudge is kept the same always.</span>

<span class="sd">        Users generally do not need this method.  It is exposed here just for</span>
<span class="sd">        flexibility and convenience.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            For developers:  Note that the resulted tensor will inherit all</span>
<span class="sd">            unspecified keyword arguments from self.  This method can give</span>
<span class="sd">            *unexpected results* if certain arguments are not correctly reset</span>
<span class="sd">            when they need to.  For instance, when expanded is not reset when</span>
<span class="sd">            the result is no longer guaranteed to be in expanded form, later</span>
<span class="sd">            expansions could be skipped when they actually need to be performed.</span>

<span class="sd">            So all functions using this methods need to be reviewed when new</span>
<span class="sd">            property are added to tensor class.  Direct invocation of the tensor</span>
<span class="sd">            constructor is a much safe alternative.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_INIT_ARGS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Here for a lot of methods, we have two versions, with one being public,</span>
    <span class="c1"># another being private with a leading underscore.  The private version</span>
    <span class="c1"># operates on given RDD of terms and returns another RDD of terms.  The</span>
    <span class="c1"># public version operates on the terms of the current tensor, and return</span>
    <span class="c1"># another tensor.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.reset_dumms"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.reset_dumms">[docs]</a>    <span class="k">def</span> <span class="nf">reset_dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the dummies.</span>

<span class="sd">        The dummies will be set to the canonical dummies according to the order</span>
<span class="sd">        in the summation list.  This method is especially useful on</span>
<span class="sd">        canonicalized tensors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        excl</span>
<span class="sd">            A set of symbols to be excluded in the dummy selection.  This option</span>
<span class="sd">            can be useful when some symbols already used as dummies are planned</span>
<span class="sd">            to be used for other purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="k">if</span> <span class="n">excl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excl</span> <span class="o">=</span> <span class="n">free_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">excl</span> <span class="o">|=</span> <span class="n">free_vars</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reset_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">excl</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_reset_dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">RDD</span><span class="p">,</span> <span class="n">excl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RDD</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get terms with dummies reset.</span>

<span class="sd">        Note that this function does not automatically add the free variables in</span>
<span class="sd">        the terms to the excluded symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dumms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span>
        <span class="n">res_terms</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span><span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">excl</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">res_terms</span>

<div class="viewcode-block" id="Tensor.simplify_amps"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.simplify_amps">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_amps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the amplitudes in the tensor.</span>

<span class="sd">        This method simplifies the amplitude in the terms of the tensor by using</span>
<span class="sd">        the facility from SymPy.  The zero terms will be filtered out as well.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Some free variables might be canceled.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_amps</span><span class="p">,</span> <span class="n">free_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repartitioned</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_simplify_amps</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the terms with amplitude simplified by SymPy.&quot;&quot;&quot;</span>

        <span class="n">simplified_terms</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="n">skip_vecs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">_is_nonzero</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">simplified_terms</span>

<div class="viewcode-block" id="Tensor.simplify_deltas"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.simplify_deltas">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_deltas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the deltas in the tensor.</span>

<span class="sd">        Kronecker deltas whose operands contains dummies will be attempted to be</span>
<span class="sd">        simplified.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_deltas</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span><span class="p">),</span>
            <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_simplify_deltas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">expanded</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the deltas in the terms.</span>

<span class="sd">        This function will leave the resulted terms in expanded form.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expanded</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>

        <span class="n">resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">resolvers</span>

        <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">simplify_deltas</span><span class="p">(</span><span class="n">resolvers</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">_is_nonzero</span><span class="p">)</span>

<div class="viewcode-block" id="Tensor.expand"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expand the terms in the tensor.</span>

<span class="sd">        By calling this method, terms in the tensor whose amplitude is the</span>
<span class="sd">        addition of multiple parts will be expanded into multiple terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repartitioned</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get terms after they are fully expanded.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span>

<div class="viewcode-block" id="Tensor.sort"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the terms in the tensor.</span>

<span class="sd">        The terms will generally be sorted according to increasing complexity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sort</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="n">terms</span><span class="p">:</span> <span class="n">RDD</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the terms in the tensor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">sortBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">sort_key</span><span class="p">)</span>

<div class="viewcode-block" id="Tensor.merge"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge terms with the same vector and summation part.</span>

<span class="sd">        This function merges terms only when their summation list and vector</span>
<span class="sd">        part are *syntactically* the same.  So it is more useful when the</span>
<span class="sd">        canonicalization has been performed and the dummies reset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># All the traits could be invalidated by merging.</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the term when they are attempted to be merged.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">simple_merge</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="p">((</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">vecs</span><span class="p">),</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reduceByKey</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Term</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_decompose_term</span><span class="p">)</span><span class="o">.</span><span class="n">reduceByKey</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Term</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Canonicalization</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.canon"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.canon">[docs]</a>    <span class="k">def</span> <span class="nf">canon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonicalize the terms in the tensor.</span>

<span class="sd">        This method will first expand the terms in the tensor.  Then the</span>
<span class="sd">        canonicalization algorithm is going to be applied to each of the terms.</span>
<span class="sd">        Note that this method does not rename the dummies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_canon</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span><span class="p">),</span>
            <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repartitioned</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_canon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">expanded</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the canonicalized terms.&quot;&quot;&quot;</span>

        <span class="n">symms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span>

        <span class="n">vec_colour</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">vec_colour</span>
        <span class="c1"># Normally a static function, not broadcast variable.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">expanded</span><span class="p">:</span>
            <span class="n">expanded_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expanded_terms</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="n">canoned</span> <span class="o">=</span> <span class="n">expanded_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">term</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">vec_colour</span><span class="o">=</span><span class="n">vec_colour</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">canoned</span>

<div class="viewcode-block" id="Tensor.normal_order"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.normal_order">[docs]</a>    <span class="k">def</span> <span class="nf">normal_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normal order the terms in the tensor.</span>

<span class="sd">        The actual work is dispatched to the drudge, who has domain specific</span>
<span class="sd">        knowledge about the noncommutativity of the vectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Free variables, expanded, and repartitioned can all be invalidated.</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">normal_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># The driver simplification.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.simplify"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the tensor.</span>

<span class="sd">        This is the master driver function for tensor simplification.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">),</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the terms in the simplified form.&quot;&quot;&quot;</span>

        <span class="n">num_partitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">num_partitions</span>

        <span class="n">repartitioned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repartitioned</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="n">repartitioned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">repartitioned</span> <span class="ow">and</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">)</span>

        <span class="c1"># First we make the vector part normal-ordered.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">normal_order</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">)</span>

        <span class="c1"># Simplify things like zero or deltas.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">full_simplify</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_amps</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_deltas</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Canonicalize the terms and see if they can be merged.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># In rare cases, normal order could make the result unexpanded.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Find a design to skip repartition in most cases.</span>

        <span class="n">free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_free_vars</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_dumms</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>

        <span class="c1"># Finally simplify the merged amplitude again.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">full_simplify</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_amps</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>

        <span class="c1"># Make the final expansion.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">terms</span>

    <span class="c1">#</span>
    <span class="c1"># Comparison operations</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.__eq__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare the equality of tensors.</span>

<span class="sd">        Note that this function only compares the syntactical equality of</span>
<span class="sd">        tensors.  Mathematically equal tensors might be compared to be unequal</span>
<span class="sd">        by this function when they are not simplified.</span>

<span class="sd">        Note that only comparison with zero is performed by counting the number</span>
<span class="sd">        of terms distributed.  Or this function gathers all terms in both</span>
<span class="sd">        tensors and can be very expensive.  So direct comparison of two tensors</span>
<span class="sd">        is mostly suitable for testing and debugging on small problems only.</span>
<span class="sd">        For large scale problems, it is advised to compare the simplified</span>
<span class="sd">        difference with zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_terms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_terms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">local_terms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n_terms</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_terms</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">term</span> <span class="o">==</span> <span class="n">parse_term</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">assert</span> <span class="kc">False</span></div>

    <span class="c1">#</span>
    <span class="c1"># Mathematical operations</span>
    <span class="c1">#</span>

    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">20.0</span>

<div class="viewcode-block" id="Tensor.__add__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the two tensors together.</span>

<span class="sd">        The terms in the two tensors will be concatenated together, without any</span>
<span class="sd">        further processing.</span>

<span class="sd">        In addition to full tensors, tensor inputs can also be directly added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.__radd__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__radd__">[docs]</a>    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add tensor with something in front.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add tensor with another thing.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_free_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_vars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">terms</span><span class="p">),</span>
            <span class="n">free_vars</span><span class="o">=</span><span class="n">free_vars</span><span class="p">,</span>
            <span class="n">expanded</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">expanded</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Tensor.__sub__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract another tensor from this tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">other</span> <span class="o">*</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tensor.__rsub__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__rsub__">[docs]</a>    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract the tensor from another quantity.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">_add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.__mul__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Tensor&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Multiply the tensor.</span>

<span class="sd">        This multiplication operation is done completely within the framework of</span>
<span class="sd">        free algebras.  The vectors are only concatenated without further</span>
<span class="sd">        processing.  The actual handling of the commutativity should be carried</span>
<span class="sd">        out at the normal ordering operation for different problems.</span>

<span class="sd">        In addition to full tensors, tensors can also be multiplied to user</span>
<span class="sd">        tensor input directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.__rmul__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__rmul__">[docs]</a>    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply the tensor on the right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply the tensor with another.&quot;&quot;&quot;</span>
        <span class="n">prod</span><span class="p">,</span> <span class="n">free_vars</span><span class="p">,</span> <span class="n">expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_terms</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">dumms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">prod</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mul_term</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">free_vars</span><span class="o">=</span><span class="n">free_vars</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="n">expanded</span><span class="p">)</span>

<div class="viewcode-block" id="Tensor.__or__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__or__">[docs]</a>    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the commutator with another tensor.</span>

<span class="sd">        In the same way as multiplication, this can be used for both full</span>
<span class="sd">        tensors and local tensor input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tensor.__ror__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__ror__">[docs]</a>    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the commutator with another tensor on the right.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_comm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the commutator.&quot;&quot;&quot;</span>
        <span class="n">prod</span><span class="p">,</span> <span class="n">free_vars</span><span class="p">,</span> <span class="n">expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cartesian_terms</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">dumms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">prod</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm_term</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">free_vars</span><span class="o">=</span><span class="n">free_vars</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="n">expanded</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cartesian_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian the terms with the terms in another tensor.</span>

<span class="sd">        The other tensor will be attempted to be interpreted as a tensor when it</span>
<span class="sd">        is not given as one.  And the free variables used in both tensors will</span>
<span class="sd">        also be returned since it is going to be used frequently.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">cartesian</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>

            <span class="n">free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">|</span> <span class="n">other</span><span class="o">.</span><span class="n">free_vars</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expanded</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_expanded</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Special optimized version when the other terms are local.</span>

            <span class="n">other_terms</span> <span class="o">=</span> <span class="n">parse_terms</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span> <span class="k">if</span> <span class="n">right</span> <span class="k">else</span> <span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_terms</span>
                    <span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Special optimization when we just have one term.</span>
                <span class="n">other_term</span> <span class="o">=</span> <span class="n">other_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">other_term</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span> <span class="k">if</span> <span class="n">right</span> <span class="k">else</span> <span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">other_term</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">free_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
                <span class="n">i</span><span class="o">.</span><span class="n">free_vars</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_terms</span>
                <span class="p">])</span>
            <span class="n">free_vars</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">prod</span><span class="p">,</span> <span class="n">free_vars</span><span class="p">,</span> <span class="n">expanded</span>

    <span class="c1">#</span>
    <span class="c1"># Substitution</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.subst"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.subst">[docs]</a>    <span class="k">def</span> <span class="nf">subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">wilds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substitute the all appearance of the defined tensor.</span>

<span class="sd">        When the given LHS is a plain SymPy symbol, all its appearances in the</span>
<span class="sd">        amplitude of the tensor will be replaced.  Or the LHS can also be</span>
<span class="sd">        indexed SymPy expression or indexed Vector, for which all of the</span>
<span class="sd">        appearances of the indexed base or vector base will be attempted to be</span>
<span class="sd">        matched against the indices on the LHS.  When a matching succeeds for</span>
<span class="sd">        all the indices, the RHS, with the substitution found in the matching</span>
<span class="sd">        performed, will be replace the indexed base in the amplitude, or the</span>
<span class="sd">        vector.  Note that for scalar LHS, the RHS must contain no vector.</span>

<span class="sd">        Since we do not commonly define tensors with wild symbols, an option</span>
<span class="sd">        ``wilds`` can be used to give a mapping translating plain symbols on the</span>
<span class="sd">        LHS and the RHS to the wild symbols that would like to be used.  The</span>
<span class="sd">        default value of None could make all **plain** symbols in the indices of</span>
<span class="sd">        the LHS to be translated into a wild symbol with the same name and no</span>
<span class="sd">        exclusion. And empty dictionary can be used to disable all such</span>
<span class="sd">        automatic translation.  The default value of None should satisfy most</span>
<span class="sd">        needs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        For instance, we can have a very simple tensor, the outer product of the</span>
<span class="sd">        same vector,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; dr = Drudge(SparkContext())</span>
<span class="sd">            &gt;&gt;&gt; r = Range(&#39;R&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a, b = dr.set_dumms(r, symbols(&#39;a b c d e f&#39;))[:2]</span>
<span class="sd">            &gt;&gt;&gt; dr.add_default_resolver(r)</span>
<span class="sd">            &gt;&gt;&gt; x = IndexedBase(&#39;x&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = Vec(&#39;v&#39;)</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.einst(x[a] * x[b] * v[a] * v[b])</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;sum_{a, b} x[a]*x[b] * v[a] * v[b]&#39;</span>

<span class="sd">        We can replace the indexed base by the product of a matrix with another</span>
<span class="sd">        indexed base,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; o = IndexedBase(&#39;o&#39;)</span>
<span class="sd">            &gt;&gt;&gt; y = IndexedBase(&#39;y&#39;)</span>
<span class="sd">            &gt;&gt;&gt; res = tensor.subst(x[a], dr.einst(o[a, b] * y[b]))</span>
<span class="sd">            &gt;&gt;&gt; str(res)</span>
<span class="sd">            &#39;sum_{a, b, c, d} y[c]*y[d]*o[a, c]*o[b, d] * v[a] * v[b]&#39;</span>

<span class="sd">        We can also make substitution on the vectors,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; w = Vec(&#39;w&#39;)</span>
<span class="sd">            &gt;&gt;&gt; res = tensor.subst(v[a], dr.einst(o[a, b] * w[b]))</span>
<span class="sd">            &gt;&gt;&gt; str(res)</span>
<span class="sd">            &#39;sum_{a, b, c, d} x[a]*x[b]*o[a, c]*o[b, d] * w[c] * w[d]&#39;</span>

<span class="sd">        After the substitution, we can always make a simplification, at least to</span>
<span class="sd">        make the naming of the dummies more aesthetically pleasing,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; res = res.simplify()</span>
<span class="sd">            &gt;&gt;&gt; str(res)</span>
<span class="sd">            &#39;sum_{a, b, c, d} x[c]*x[d]*o[c, a]*o[d, b] * w[a] * w[b]&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">(</span><span class="n">Vec</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid LHS for substitution&#39;</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span>
                <span class="s1">&#39;expecting vector, indexed, or symbol&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_base</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># We need to gather, and later broadcast all the terms.  The rational is</span>
        <span class="c1"># that the RHS is usually small in real problems.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">rhs_terms</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">local_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhs_terms</span> <span class="o">=</span> <span class="n">parse_terms</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">i</span><span class="o">.</span><span class="n">is_scalar</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rhs_terms</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid RHS for substituting a scalar&#39;</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">wilds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">(</span><span class="n">Indexed</span><span class="p">,</span> <span class="n">Vec</span><span class="p">)):</span>
                <span class="n">wilds</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">Wild</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">indices</span> <span class="k">if</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
                    <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wilds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">wilds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Vec</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">wilds</span><span class="p">))</span>

        <span class="n">rhs_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">wilds</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rhs_terms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">expand</span><span class="p">()]</span>

        <span class="n">expanded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">expanded</span><span class="o">.</span><span class="n">_subst</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_terms</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="n">full_balance</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_subst</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Vec</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">],</span> <span class="n">rhs_terms</span><span class="p">,</span>
            <span class="n">full_balance</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Core substitution function.</span>

<span class="sd">        This function assumes the self and the substituting terms are already</span>
<span class="sd">        fully expanded.  And the LHS and the RHS of the substitution have been</span>
<span class="sd">        replaced with the wilds if it is needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free_vars_local</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">|</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">free_vars</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rhs_terms</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">free_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">free_vars_local</span><span class="p">)</span>
        <span class="n">dumms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span>
        <span class="n">full_simplify</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">full_simplify</span>

        <span class="c1"># We keep the dummbegs dictionary for each term and substitute all</span>
        <span class="c1"># appearances of the lhs one-by-one.</span>

        <span class="n">subs_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="o">.</span><span class="n">value</span>
        <span class="p">))</span>

        <span class="n">rhs_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">rhs_terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">(</span><span class="n">Indexed</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">nest_bind</span><span class="p">(</span><span class="n">subs_states</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">subst_factor_in_term</span><span class="p">(</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_terms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dummbegs</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">full_simplify</span><span class="o">=</span><span class="n">full_simplify</span>
            <span class="p">),</span> <span class="n">full_balance</span><span class="o">=</span><span class="n">full_balance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">nest_bind</span><span class="p">(</span><span class="n">subs_states</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">subst_vec_in_term</span><span class="p">(</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_terms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">dumms</span><span class="o">=</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dummbegs</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">excl</span><span class="o">=</span><span class="n">free_vars</span><span class="o">.</span><span class="n">value</span>
            <span class="p">),</span> <span class="n">full_balance</span><span class="o">=</span><span class="n">full_balance</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">res_terms</span><span class="p">,</span> <span class="n">free_vars</span><span class="o">=</span><span class="n">free_vars_local</span><span class="p">,</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Tensor.subst_all"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.subst_all">[docs]</a>    <span class="k">def</span> <span class="nf">subst_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defs</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Substitute all given definitions serially.</span>

<span class="sd">        The definitions should be given as an iterable of either</span>
<span class="sd">        :py:class:`TensorDef` instances or pairs of left-hand side and</span>
<span class="sd">        right-hand side of the substitutions.  Note that the substitutions are</span>
<span class="sd">        going to be performed **according to the given order** one-by-one,</span>
<span class="sd">        rather than simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">defs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">TensorDef</span><span class="p">):</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">rhs</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid substitution&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                    <span class="s1">&#39;expecting definition or LHS/RHS pair&#39;</span>
                <span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="n">full_balance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">repartition</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Tensor.rewrite"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.rewrite">[docs]</a>    <span class="k">def</span> <span class="nf">rewrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">,</span> <span class="n">new_amp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rewrite terms with the given vectors in terms of the new amplitude.</span>

<span class="sd">        This method will rewrite the terms whose vector part patches the given</span>
<span class="sd">        vectors in terms of the given new amplitude.  And all terms rewritten</span>
<span class="sd">        into the same form will be aggregated into a single term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vecs</span>
<span class="sd">            A vector or a product of vectors.  They should be written in terms</span>
<span class="sd">            of SymPy wild symbols when they need to be matched against different</span>
<span class="sd">            actual vectors.</span>

<span class="sd">        new_amp</span>
<span class="sd">            The amplitude that the matched terms should have.  They are usually</span>
<span class="sd">            written in terms of the same wild symbols as the wilds in the</span>
<span class="sd">            vectors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rewritten</span>
<span class="sd">            The tensor with the requested terms rewritten in term of the given</span>
<span class="sd">            amplitude.</span>

<span class="sd">        defs</span>
<span class="sd">            The actual definitions of the rewritten amplitude.  One for each</span>
<span class="sd">            rewritten term in the result.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vecs_terms</span> <span class="o">=</span> <span class="n">parse_terms</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>
        <span class="n">invalid_vecs</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Invalid vectors to rewrite&#39;</span><span class="p">,</span> <span class="n">vecs</span><span class="p">,</span>
            <span class="s1">&#39;expecting just vectors&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecs_terms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">invalid_vecs</span>
        <span class="n">vecs_term</span> <span class="o">=</span> <span class="n">vecs_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecs_term</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">vecs_term</span><span class="o">.</span><span class="n">amp</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">invalid_vecs</span>
        <span class="n">vecs</span> <span class="o">=</span> <span class="n">vecs_term</span><span class="o">.</span><span class="n">vecs</span>

        <span class="n">rewritten</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">term</span><span class="p">:</span> <span class="n">rewrite_term</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">vecs</span><span class="p">,</span> <span class="n">new_amp</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
        <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rewritten</span><span class="o">.</span><span class="n">countByKey</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">]</span>

        <span class="n">get_term</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">untouched_terms</span> <span class="o">=</span> <span class="n">rewritten</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">get_term</span><span class="p">)</span>
        <span class="n">new_defs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_terms</span><span class="p">:</span>
            <span class="n">def_terms</span> <span class="o">=</span> <span class="n">rewritten</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">get_term</span><span class="p">)</span>
            <span class="n">new_defs</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">amp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">def_terms</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">untouched_terms</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">new_terms</span><span class="p">)</span>
        <span class="p">)),</span> <span class="n">new_defs</span></div>

    <span class="c1">#</span>
    <span class="c1"># Analytic gradient</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.diff"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.diff">[docs]</a>    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wirtinger_conj</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Differentiate the tensor to get the analytic gradient.</span>

<span class="sd">        By this function, support is provided for evaluating the derivative with</span>
<span class="sd">        respect to either a plain symbol or a tensor component.  This is</span>
<span class="sd">        achieved by leveraging the core differentiation operation to SymPy.  So</span>
<span class="sd">        very wide range of expressions are supported.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            For non-analytic complex functions, this function gives the</span>
<span class="sd">            Wittinger derivative with respect to the given variable only.  The</span>
<span class="sd">            other non-vanishing derivative with respect to the conjugate needs</span>
<span class="sd">            to be evaluated by another invocation with ``wittinger_conj`` set to</span>
<span class="sd">            true.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The differentiation algorithm currently does **not** take the</span>
<span class="sd">            symmetry of the tensor to be differentiated with respect to into</span>
<span class="sd">            account.  For differentiate with respect to symmetric tensor,</span>
<span class="sd">            further symmetrization of the result might be needed.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        variable</span>
<span class="sd">            The variable to differentiate with respect to.  It should be either</span>
<span class="sd">            a plain SymPy symbol or a indexed quantity.  When it is an indexed</span>
<span class="sd">            quantity, the indices should be plain symbols with resolvable range.</span>

<span class="sd">        real : bool</span>
<span class="sd">            If the variable is going to be assumed to be real.  Real variables</span>
<span class="sd">            has conjugate equal to themselves.</span>

<span class="sd">        wirtinger_conj : bool</span>
<span class="sd">            If we evaluate the Wirtinger derivative with respect to the</span>
<span class="sd">            conjugate of the variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">real</span> <span class="ow">and</span> <span class="n">wirtinger_conj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Wittinger conjugate derivative vanishes for real variables&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>

            <span class="n">symms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span>
            <span class="n">if_symm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">base</span> <span class="ow">in</span> <span class="n">symms</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span> <span class="ow">in</span> <span class="n">symms</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_symm</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;Gradient wrt to symmetric tensor </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s1">&#39;might need further symmetrization&#39;</span>
                <span class="p">)</span>

            <span class="c1"># We need a copy.</span>
            <span class="n">excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_vars</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Invalid index&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;expecting plain symbol&#39;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">excl</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Invalid index&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                        <span class="s1">&#39;clashing with existing free symbols&#39;</span>
                    <span class="p">)</span>
                <span class="n">excl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_dumms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">excl</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid variable to differentiate&#39;</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diff</span><span class="p">(</span>
            <span class="n">terms</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="n">real</span><span class="p">,</span> <span class="n">wirtinger_conj</span><span class="o">=</span><span class="n">wirtinger_conj</span>
        <span class="p">),</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">wirtinger_conj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Differentiate the terms.&quot;&quot;&quot;</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">diff_term</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">wirtinger_conj</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># We have got to simplify here to avoid confuse users.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_deltas</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Term filter and cherry picking</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.filter"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filter out terms satisfying the given criterion.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">terms</span><span class="p">:</span> <span class="n">terms</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">crit</span><span class="p">),</span>
            <span class="n">free_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">repartitioned</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Advanced manipulations.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.map2scalars"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.map2scalars">[docs]</a>    <span class="k">def</span> <span class="nf">map2scalars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">skip_vecs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the given action to the scalars in the tensor.</span>

<span class="sd">        The given action should return SymPy expressions for SymPy expressions,</span>
<span class="sd">        the amplitude for each terms and the indices to the vectors, in the</span>
<span class="sd">        tensor.  Note that this function does not change the summations in the</span>
<span class="sd">        terms and the dummies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        action</span>
<span class="sd">            The callable to be applied to the scalars inside the tensor.</span>

<span class="sd">        skip_vecs</span>
<span class="sd">            When it is set, the callable will no longer be mapped to the indices</span>
<span class="sd">            to the vectors.  It could be used to boost the performance when we</span>
<span class="sd">            know that the action need no application on the indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">skip_vecs</span><span class="o">=</span><span class="n">skip_vecs</span><span class="p">)</span>
        <span class="p">))</span></div>

    <span class="c1">#</span>
    <span class="c1"># Operations from the drudge</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Tensor.__getattr__"><a class="viewcode-back" href="../../api/base.html#drudge.Tensor.__getattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to see if the item is a tensor method from the drudge.</span>

<span class="sd">        This enables individual drudges to dynamically add domain-specific</span>
<span class="sd">        operations on tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">meth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">get_tensor_method</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Invalid operation name on tensor&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TensorDef"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef">[docs]</a><span class="k">class</span> <span class="nc">TensorDef</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Definition of a tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;_tensor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_base&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_exts&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_is_scalar&#39;</span>
    <span class="p">]</span>

<div class="viewcode-block" id="TensorDef.__init__"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">tensor</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the tensor definition.</span>

<span class="sd">        In the same way as the initializer for the :py:class:`Tensor` class,</span>
<span class="sd">        this initializer is also unlikely to be used directly in user code.</span>
<span class="sd">        Drudge methods :py:meth:`Drudge.define` and</span>
<span class="sd">        :py:meth:`Drudge.define_einst` can be more convenient.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Vec</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">base</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_scalar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">base</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid base for tensor definition&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
                <span class="s1">&#39;expecting vector or scalar base&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span> <span class="o">=</span> <span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid LHS for tensor definition&#39;</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span>
                <span class="s1">&#39;expecting a tensor instance&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_exts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">:</span>
            <span class="n">valid_ext</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Range</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">valid_ext</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid external index&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                    <span class="s1">&#39;expecting dummy and range pair&#39;</span>
                <span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Additional processing for scalar replacement.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scalar</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid tensor&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span><span class="p">,</span> <span class="s1">&#39;for base&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">,</span>
                    <span class="s1">&#39;expecting a scalar&#39;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="o">.</span><span class="n">label</span></div>

    <span class="c1">#</span>
    <span class="c1"># Basic properties.</span>
    <span class="c1">#</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the tensor defined is a scalar.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_scalar</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the right-hand-side of the definition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhs_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gather the terms on the right-hand-side of the definition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span><span class="o">.</span><span class="n">local_terms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the standard left-hand-side of the definition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exts</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The base of the tensor definition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The external indices.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exts</span>

    <span class="c1">#</span>
    <span class="c1"># Simple operations.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="TensorDef.simplify"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the tensor in the definition.</span>

<span class="sd">        Due to the scarcity of the usefulness of keeping both the unsimplified</span>
<span class="sd">        and the simplified tensor definition, this method will mutate the tensor</span>
<span class="sd">        with its simplified form.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="TensorDef.__eq__"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare two tensor definitions for equality.</span>

<span class="sd">        Note that similar to the equality comparison of tensors, here we only</span>
<span class="sd">        compare the syntactic equality rather than the mathematical equality.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensorDef</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">lhs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">rhs</span></div>

    <span class="c1">#</span>
    <span class="c1"># Representations.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="TensorDef.__str__"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form simple readable string for a definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="s1">&#39; = &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)])</span></div>

<div class="viewcode-block" id="TensorDef.latex"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.latex">[docs]</a>    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the latex form for the tensor definition.</span>

<span class="sd">        The result will just be the form from :py:meth:`Tensor.latex` with the</span>
<span class="sd">        RHS prepended.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sep_lines : bool</span>
<span class="sd">            If terms should be put into separate lines by separating them with</span>
<span class="sd">            ``\\``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor</span><span class="o">.</span><span class="n">drudge</span><span class="o">.</span><span class="n">format_latex</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="n">sep_lines</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TensorDef.display"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">if_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the tensor definition in interactive notebook sessions.</span>

<span class="sd">        The parameters here all have the same meaning as in</span>
<span class="sd">        :py:meth:`Tensor.display`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">form</span> <span class="o">=</span> <span class="n">Math</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">sep_lines</span><span class="o">=</span><span class="n">sep_lines</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">if_return</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">form</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
            <span class="k">return</span></div>

    <span class="c1">#</span>
    <span class="c1"># Substitution.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="TensorDef.act"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.act">[docs]</a>    <span class="k">def</span> <span class="nf">act</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">wilds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Act the definition on a tensor.</span>

<span class="sd">        This method is the active voice version of the :py:meth:`Tensor.subst`</span>
<span class="sd">        function.  All appearances of the defined object in the tensor will be</span>
<span class="sd">        substituted.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">drudge</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tensor</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">wilds</span><span class="o">=</span><span class="n">wilds</span><span class="p">,</span> <span class="n">full_balance</span><span class="o">=</span><span class="n">full_balance</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TensorDef.__getitem__"><a class="viewcode-back" href="../../api/base.html#drudge.TensorDef.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the tensor when the definition is indexed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>

        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_exts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid subscripts&#39;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="s1">&#39;expecting&#39;</span><span class="p">,</span> <span class="n">n_exts</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">act</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base</span><span class="p">[</span><span class="n">item</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="Drudge"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge">[docs]</a><span class="k">class</span> <span class="nc">Drudge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The main drudge class.</span>

<span class="sd">    A drudge is a robot who can help you with the menial tasks of symbolic</span>
<span class="sd">    manipulation for tensorial and noncommutative alegbras.  Due to the</span>
<span class="sd">    diversity and non-uniformity of tensor and noncommutative algebraic</span>
<span class="sd">    problems, to set up a drudge, domain-specific information about the problem</span>
<span class="sd">    needs to be given.  Here this is a base class, where the basic operations</span>
<span class="sd">    are defined. Different problems could subclass this base class with</span>
<span class="sd">    customized behaviour.  Most importantly, the method :py:meth:`normal_order`</span>
<span class="sd">    should be overridden to give the commutation rules for the algebraic system</span>
<span class="sd">    studied.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We do not need slots here.  There is generally only one drudge instance.</span>

<div class="viewcode-block" id="Drudge.__init__"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">SparkContext</span><span class="p">,</span> <span class="n">num_partitions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the drudge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        ctx</span>
<span class="sd">            The Spark context to be used.</span>

<span class="sd">        num_partitions</span>
<span class="sd">            The preferred number of partitions.  By default, it is the default</span>
<span class="sd">            parallelism of the given Spark environment.  Or an explicit integral</span>
<span class="sd">            value can be given.  It can be set to None, which disable all</span>
<span class="sd">            explicit load-balancing by shuffling.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span> <span class="o">=</span> <span class="n">ctx</span>

        <span class="k">if</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_partitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="o">.</span><span class="n">defaultParallelism</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_partitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_partitions</span> <span class="o">=</span> <span class="n">num_partitions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid default partition&#39;</span><span class="p">,</span> <span class="n">num_partitions</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_full_simplify</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span> <span class="o">=</span> <span class="n">BCastVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symms</span> <span class="o">=</span> <span class="n">BCastVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolvers</span> <span class="o">=</span> <span class="n">BCastVar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="p">,</span> <span class="p">[])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_methods</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The Spark context of the drudge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The preferred number of partitions for data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_partitions</span>

    <span class="nd">@num_partitions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">num_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the preferred number of partitions for data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_partitions</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid default number of partitions&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                <span class="s1">&#39;expecting integer or None&#39;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If full simplification is to be performed on amplitudes.</span>

<span class="sd">        It can be used to disable full simplification of the amplitude</span>
<span class="sd">        expression by SymPy.  For simple polynomial amplitude, this option is</span>
<span class="sd">        generally safe to be disabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_simplify</span>

    <span class="nd">@full_simplify</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">full_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set if full simplification is going to be carried out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid full simplification option&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                <span class="s1">&#39;expecting boolean&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_simplify</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simple_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If only simple merge is to be carried out.</span>

<span class="sd">        When it is set to true, only terms with same factors involving dummies</span>
<span class="sd">        are going to be merged.  This might be helpful for cases where the</span>
<span class="sd">        amplitude are all simple polynomials of tensorial quantities.  Note that</span>
<span class="sd">        this could disable some SymPy simplification.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This option might not give much more than disabling full</span>
<span class="sd">            simplification but taketh away many simplifications.  It is in</span>
<span class="sd">            general not recommended to be used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge</span>

    <span class="nd">@simple_merge</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">simple_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set if simple merge is going to be carried out.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid simple merge setting&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                <span class="s1">&#39;expecting plain boolean&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_simple_merge</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1">#</span>
    <span class="c1"># Name archive utilities.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.set_name"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the object into the name archive of the drudge.</span>

<span class="sd">        For positional arguments, the str form of the given label is going to be</span>
<span class="sd">        used for the name of the object.  For keyword arguments, the keyword</span>
<span class="sd">        will be used for the name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">to_set</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_set</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name archive for the drudge.</span>

<span class="sd">        The name archive object can be used for convenient accessing of objects</span>
<span class="sd">        related to the problem.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span>

<div class="viewcode-block" id="Drudge.inject_names"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.inject_names">[docs]</a>    <span class="k">def</span> <span class="nf">inject_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inject the names in the name archive into the current global scope.</span>

<span class="sd">        This function is for the convenience of users, especially interactive</span>
<span class="sd">        users.  Itself is not used in official drudge code except its own tests.</span>

<span class="sd">        Note that this function injects the names in the name archive into the</span>
<span class="sd">        **global** scope of the caller, rather than the local scope, even when</span>
<span class="sd">        called inside a function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find the global scope for the caller.</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">globals_</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f_globals</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">stack</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">globals_</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">suffix</span><span class="p">])]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span></div>

    <span class="c1">#</span>
    <span class="c1"># General properties</span>
    <span class="c1">#</span>
    <span class="c1"># Subclasses normally just need to use the methods in this section to add</span>
    <span class="c1"># some additional information.  The method here generally does not need to</span>
    <span class="c1"># be overridden.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.set_dumms"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.set_dumms">[docs]</a>    <span class="k">def</span> <span class="nf">set_dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_</span><span class="p">:</span> <span class="n">Range</span><span class="p">,</span> <span class="n">dumms</span><span class="p">,</span>
                  <span class="n">set_range_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dumms_suffix</span><span class="o">=</span><span class="s1">&#39;_dumms&#39;</span><span class="p">,</span>
                  <span class="n">set_dumm_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the dummies for a range.</span>

<span class="sd">        Note that this function overwrites the existing dummies if the range has</span>
<span class="sd">        already been given.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_dumms</span> <span class="o">=</span> <span class="p">[</span><span class="n">ensure_symb</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dumms</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">range_</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dumms</span>

        <span class="k">if</span> <span class="n">set_range_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">range_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dumms_suffix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">range_</span><span class="p">)</span> <span class="o">+</span> <span class="n">dumms_suffix</span><span class="p">:</span> <span class="n">new_dumms</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">set_dumm_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_dumms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_dumms</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The broadcast form of the dummies dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="o">.</span><span class="n">bcast</span>

<div class="viewcode-block" id="Drudge.set_symm"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.set_symm">[docs]</a>    <span class="k">def</span> <span class="nf">set_symm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">symms</span><span class="p">,</span> <span class="n">valence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">set_base_name</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the symmetry for a given base.</span>

<span class="sd">        Permutation objects in the arguments are interpreted as single</span>
<span class="sd">        generators, other values will be attempted to be iterated over to get</span>
<span class="sd">        their entries, which should all be permutations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        base</span>
<span class="sd">            The SymPy indexed base object or vectors whose symmetry is to be</span>
<span class="sd">            set.</span>

<span class="sd">        symms</span>
<span class="sd">            The generators of the symmetry.  It can be a single None to remove</span>
<span class="sd">            the symmetry of the given base.</span>

<span class="sd">        valence : int</span>
<span class="sd">            When it is set, only the indexed quantity of the base with the given</span>
<span class="sd">            valence will have the given symmetry.</span>

<span class="sd">        set_base_name</span>
<span class="sd">            If the base name is to be added to the name archive of the drudge.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid empty symmetry, expecting generators!&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">symms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">symms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Perm</span><span class="p">):</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">gens</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid generator: &#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                    <span class="s1">&#39;expecting Perm or iterable of Perms&#39;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>

        <span class="n">valid_valence</span> <span class="o">=</span> <span class="p">(</span><span class="n">valence</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">valence</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">valence</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_valence</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid valence&#39;</span><span class="p">,</span> <span class="n">valence</span><span class="p">,</span> <span class="s1">&#39;expecting positive integer&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symms</span><span class="o">.</span><span class="n">var</span><span class="p">[</span>
            <span class="n">base</span> <span class="k">if</span> <span class="n">valence</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">valence</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

        <span class="k">if</span> <span class="n">set_base_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">label</span><span class="p">):</span> <span class="n">base</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">group</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The broadcast form of the symmetries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symms</span><span class="o">.</span><span class="n">bcast</span>

<div class="viewcode-block" id="Drudge.add_resolver"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.add_resolver">[docs]</a>    <span class="k">def</span> <span class="nf">add_resolver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolver</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append a resolver to the list of resolvers.</span>

<span class="sd">        The given resolver can be either a mapping from SymPy expression,</span>
<span class="sd">        including atomic symbols, to the corresponding ranges.  Or a callable to</span>
<span class="sd">        be called with SymPy expressions.  For callable resolvers, None can be</span>
<span class="sd">        returned to signal the incapability to resolve the expression.  Then the</span>
<span class="sd">        resolution will be dispatched to the next resolver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolvers</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resolver</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Drudge.add_resolver_for_dumms"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.add_resolver_for_dumms">[docs]</a>    <span class="k">def</span> <span class="nf">add_resolver_for_dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the resolver for the dummies for each range.</span>

<span class="sd">        With this method, the default dummies for each range will be resolved to</span>
<span class="sd">        be within the range for all of them.  This method should normally be</span>
<span class="sd">        called by all subclasses after the dummies for all ranges have been</span>
<span class="sd">        properly set.</span>

<span class="sd">        Note that dummies added later will not be automatically added.  This</span>
<span class="sd">        method can be called again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dumm_resolver</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="o">.</span><span class="n">ro</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">dumm_resolver</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="k">continue</span>
            <span class="k">continue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_resolver</span><span class="p">(</span><span class="n">dumm_resolver</span><span class="p">)</span></div>

<div class="viewcode-block" id="Drudge.add_default_resolver"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.add_default_resolver">[docs]</a>    <span class="k">def</span> <span class="nf">add_default_resolver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a default resolver.</span>

<span class="sd">        The default resolver will resolve *any* expression to the given range.</span>
<span class="sd">        Note that all later resolvers will not be invoked at all after this</span>
<span class="sd">        resolver is added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_resolver</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">_resolve_default_range</span><span class="p">,</span> <span class="n">range_</span><span class="o">=</span><span class="n">range_</span>
        <span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The broadcast form of the resolvers.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolvers</span><span class="o">.</span><span class="n">bcast</span>

<div class="viewcode-block" id="Drudge.set_tensor_method"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.set_tensor_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_tensor_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a new tensor method under the given name.</span>

<span class="sd">        A tensor method is a method that can be called from tensors created from</span>
<span class="sd">        the current drudge as if it is a method of the given tensor. This could</span>
<span class="sd">        give cleaner and more consistent code for all tensor manipulations.</span>

<span class="sd">        The given function, or bounded method, should be able to accept the</span>
<span class="sd">        tensor as the first argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_methods</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span></div>

<div class="viewcode-block" id="Drudge.get_tensor_method"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.get_tensor_method">[docs]</a>    <span class="k">def</span> <span class="nf">get_tensor_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a tensor method with given name.</span>

<span class="sd">        When the name cannot be resolved, KeyError will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensor_methods</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

    <span class="c1">#</span>
    <span class="c1"># Vector-related properties</span>
    <span class="c1">#</span>
    <span class="c1"># The methods here is highly likely to be overridden for different</span>
    <span class="c1"># non-commutative algebraic systems in different problems.</span>
    <span class="c1">#</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vec_colour</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The vector colour function.</span>

<span class="sd">        Note that this accessor accesses the **function**, rather than directly</span>
<span class="sd">        computes the colour for any vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Drudge.normal_order"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.normal_order">[docs]</a>    <span class="k">def</span> <span class="nf">normal_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normal order the terms in the given tensor.</span>

<span class="sd">        This method should be called with the RDD of some terms, and another RDD</span>
<span class="sd">        of terms, where all the vector parts are normal ordered according to</span>
<span class="sd">        domain-specific rules, should be returned.</span>

<span class="sd">        By default, we work for the free algebra.  So nothing is done by this</span>
<span class="sd">        function.  For noncommutative algebraic system, this function needs to</span>
<span class="sd">        be overridden to return an RDD for the normal-ordered terms from the</span>
<span class="sd">        given terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid arguments to free algebra normal order&#39;</span><span class="p">,</span> <span class="n">kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">terms</span></div>

    <span class="c1">#</span>
    <span class="c1"># Tensor creation</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.sum"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a tensor for the given summation.</span>

<span class="sd">        This is the core function for creating tensors from scratch.  The</span>
<span class="sd">        arguments should start with the summations, each of which should be</span>
<span class="sd">        given as a sequence, normally a tuple, starting with a SymPy symbol for</span>
<span class="sd">        the summation dummy in the first entry.  Then comes possibly multiple</span>
<span class="sd">        domains that the dummy is going to be summed over, which can be symbolic</span>
<span class="sd">        range, SymPy expression, or iterable over them.  When symbolic ranges</span>
<span class="sd">        are given as :py:class:`Range` objects, the given dummy will be set to</span>
<span class="sd">        be summed over the ranges symbolically.  When SymPy expressions are</span>
<span class="sd">        given, the given values will substitute all appearances of the dummy in</span>
<span class="sd">        the summand.  When we have multiple summations, terms in the result are</span>
<span class="sd">        generated from the Cartesian product of them.</span>

<span class="sd">        The last argument should give the actual thing to be summed, which can</span>
<span class="sd">        be something that can be interpreted as a collection of terms, or a</span>
<span class="sd">        callable that is going to return the summand when given a dictionary</span>
<span class="sd">        giving the action on each of the dummies.  The dictionary has an entry</span>
<span class="sd">        for all the dummies.  Dummies summed over symbolic ranges will have the</span>
<span class="sd">        actual range as its value, or the actual SymPy expression when it is</span>
<span class="sd">        given a concrete range.  In the returned summand, if dummies still</span>
<span class="sd">        exist, they are going to be treated in the same way as statically-given</span>
<span class="sd">        summands.</span>

<span class="sd">        The predicate can be a callable going to return a boolean when called</span>
<span class="sd">        with same dictionary.  False values can be used the skip some terms.  It</span>
<span class="sd">        is guaranteed that the same dictionary will be used for both predicate</span>
<span class="sd">        and the summand when they are given as callables.</span>

<span class="sd">        For instance, mostly commonly, we can create a tensor by having simple</span>
<span class="sd">        summations over symbolic ranges,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; dr = Drudge(SparkContext())</span>
<span class="sd">            &gt;&gt;&gt; r = Range(&#39;R&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a = Symbol(&#39;a&#39;)</span>
<span class="sd">            &gt;&gt;&gt; b = Symbol(&#39;b&#39;)</span>
<span class="sd">            &gt;&gt;&gt; x = IndexedBase(&#39;x&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = Vec(&#39;v&#39;)</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.sum((a, r), (b, r), x[a, b] * v[a] * v[b])</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;sum_{a, b} x[a, b] * v[a] * v[b]&#39;</span>

<span class="sd">        And we can also give multiple symbolic ranges for a single dummy to sum</span>
<span class="sd">        over all of them,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; s = Range(&#39;S&#39;)</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.sum((a, r, s), x[a] * v[a])</span>
<span class="sd">            &gt;&gt;&gt; print(str(tensor))</span>
<span class="sd">            sum_{a} x[a] * v[a]</span>
<span class="sd">             + sum_{a} x[a] * v[a]</span>

<span class="sd">        When the objects to sum over are not symbolic ranges, we are in the</span>
<span class="sd">        concrete summation mode, for instance,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; tensor = dr.sum((a, 1, 2), x[a] * v[a])</span>
<span class="sd">            &gt;&gt;&gt; print(str(tensor))</span>
<span class="sd">            x[1] * v[1]</span>
<span class="sd">             + x[2] * v[2]</span>

<span class="sd">        The concrete and symbolic summation mode can be put together freely in</span>
<span class="sd">        the same summation,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; tensor = dr.sum((a, r, s), (b, 1, 2), x[b, a] * v[a])</span>
<span class="sd">            &gt;&gt;&gt; print(str(tensor))</span>
<span class="sd">            sum_{a} x[1, a] * v[a]</span>
<span class="sd">             + sum_{a} x[2, a] * v[a]</span>
<span class="sd">             + sum_{a} x[1, a] * v[a]</span>
<span class="sd">             + sum_{a} x[2, a] * v[a]</span>

<span class="sd">        Note that this function can also be called on existing tensor objects</span>
<span class="sd">        with the same semantics on the terms.  Existing summations are not</span>
<span class="sd">        touched by it.  For instance,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; tensor = dr.sum(x[a] * v[a])</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;x[a] * v[a]&#39;</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.sum((a, r), tensor)</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;sum_{a} x[a] * v[a]&#39;</span>

<span class="sd">        where we have used summation with only summand (no sums) to create</span>
<span class="sd">        simple tensor of only one term without any summation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expecing summand!&#39;</span><span class="p">)</span>

        <span class="n">summand</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sum_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summand</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sum_term</span><span class="p">(</span><span class="n">sum_args</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span><span class="p">)</span>
            <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_tensor</span><span class="p">(</span><span class="n">sum_term</span><span class="p">(</span>
                <span class="n">sum_args</span><span class="p">,</span> <span class="n">summand</span><span class="p">,</span> <span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span>
            <span class="p">))</span></div>

<div class="viewcode-block" id="Drudge.einst"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.einst">[docs]</a>    <span class="k">def</span> <span class="nf">einst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summand</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a tensor from Einstein summation convention.</span>

<span class="sd">        By calling this function, summations according to the Einstein summation</span>
<span class="sd">        convention will be added to the terms.  Note that for a symbol to be</span>
<span class="sd">        recognized as a summation, it must appear exactly twice in its</span>
<span class="sd">        **original form** in indices, and its range needs to be able to be</span>
<span class="sd">        resolved.  When a symbol is suspiciously an Einstein summation dummy but</span>
<span class="sd">        does not satisfy the requirement precisely, it will **not** be added as</span>
<span class="sd">        a summation, but a warning will also be given for reference.</span>

<span class="sd">        For instance, we can have the following fairly conventional Einstein</span>
<span class="sd">        form,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; dr = Drudge(SparkContext())</span>
<span class="sd">            &gt;&gt;&gt; r = Range(&#39;R&#39;)</span>
<span class="sd">            &gt;&gt;&gt; a, b, c = dr.set_dumms(r, symbols(&#39;a b c&#39;))</span>
<span class="sd">            &gt;&gt;&gt; dr.add_resolver_for_dumms()</span>
<span class="sd">            &gt;&gt;&gt; x = IndexedBase(&#39;x&#39;)</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.einst(x[a, b] * x[b, c])</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;sum_{b} x[a, b]*x[b, c]&#39;</span>

<span class="sd">        However, when a dummy is not in the most conventional form, the</span>
<span class="sd">        summations cannot be automatically added.  For instance,</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; tensor = dr.einst(x[a, b] * x[b, b])</span>
<span class="sd">            &gt;&gt;&gt; str(tensor)</span>
<span class="sd">            &#39;x[a, b]*x[b, b]&#39;</span>

<span class="sd">        ``b`` is not summed over since it is repeated three times.  Note also</span>
<span class="sd">        that the symbol must be able to be resolved its range for it to be</span>
<span class="sd">        summed automatically.</span>

<span class="sd">        Note that in addition to creating tensors from scratch, this method can</span>
<span class="sd">        also be called on an existing tensor to add new summations.  In that</span>
<span class="sd">        case, no existing summations will be touched.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolvers</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>
            <span class="n">summand_terms</span> <span class="o">=</span> <span class="n">summand</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">terms</span>
            <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summand_terms</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">einst_term</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">resolvers</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="p">),</span> <span class="n">expanded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We need to expand the possibly parenthesized user input.</span>
            <span class="n">summand_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parse_terms</span><span class="p">(</span><span class="n">summand</span><span class="p">):</span>
                <span class="n">summand_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_tensor</span><span class="p">(</span>
                <span class="p">[</span><span class="n">einst_term</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">resolvers</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">summand_terms</span><span class="p">]</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Drudge.create_tensor"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.create_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">create_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a tensor with the terms given in the argument.</span>

<span class="sd">        The terms should be given as an iterable of Term objects.  This function</span>
<span class="sd">        should not be necessary in user code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">terms</span><span class="p">))</span></div>

    <span class="c1">#</span>
    <span class="c1"># Tensor definition creation.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.define"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.define">[docs]</a>    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDef</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make a tensor definition.</span>

<span class="sd">        This is a helper method for the creation of :py:class:`TensorDef`</span>
<span class="sd">        instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        initial arguments</span>
<span class="sd">            The left-hand side of the definition.  It can be given as an indexed</span>
<span class="sd">            quantity, either SymPy Indexed instances or an indexed vector, with</span>
<span class="sd">            all the indices being plain symbols whose range is able to be</span>
<span class="sd">            resolved.  Or a base can be given, followed by the symbol/range</span>
<span class="sd">            pairs for the external indices.</span>

<span class="sd">        final argument</span>
<span class="sd">            The definition of the LHS, can be tensor instances, or anything</span>
<span class="sd">            capable of being interpreted as such.  Note that no summation is</span>
<span class="sd">            going to be automatically added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expecting arguments for definition.&#39;</span><span class="p">)</span>

        <span class="n">base</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_def_lhs</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TensorDef</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="Drudge.define_einst"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.define_einst">[docs]</a>    <span class="k">def</span> <span class="nf">define_einst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDef</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Make a tensor definition based on Einstein summation convention.</span>

<span class="sd">        Basically the same function as the :py:meth:`define`, just the content</span>
<span class="sd">        will be interpreted according to the Einstein summation convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expecting arguments for definition.&#39;</span><span class="p">)</span>

        <span class="n">base</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_def_lhs</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">einst</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">TensorDef</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">tensor</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_parse_def_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the user-given LHS of tensor definitions.</span>

<span class="sd">        Here, very shallow checking is performed.  Detailed sanitation are to be</span>
<span class="sd">        performed in the tensor definition initializer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No LHS given for tensor definition.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">Indexed</span><span class="p">,</span> <span class="n">Vec</span><span class="p">)):</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">base</span>
                <span class="n">exts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                    <span class="n">range_</span> <span class="o">=</span> <span class="n">try_resolve_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">{},</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolvers</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">range_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Invalid index&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span>
                            <span class="s1">&#39;range cannot be resolved&#39;</span>
                        <span class="p">)</span>
                    <span class="n">exts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">range_</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg</span><span class="p">,</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">#</span>
    <span class="c1"># Printing</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.format_latex"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.format_latex">[docs]</a>    <span class="k">def</span> <span class="nf">format_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">sep_lines</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the LaTeX form of a given tensor or tensor definition.</span>

<span class="sd">        Subclasses should fine-tune the appearance of the resulted LaTeX form by</span>
<span class="sd">        overriding methods ``_latex_sympy``, ``_latex_vec``, and</span>
<span class="sd">        ``_latex_vec_mul``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">):</span>

            <span class="n">n_terms</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">n_terms</span>
            <span class="n">inp_terms</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">local_terms</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">TensorDef</span><span class="p">):</span>

            <span class="n">n_terms</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">n_terms</span>
            <span class="n">inp_terms</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">rhs_terms</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="p">(</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_latex_sympy</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">is_scalar</span> <span class="k">else</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_latex_vec</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                     <span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid object to form into LaTeX.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_terms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s1">&#39;0&#39;</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inp_terms</span><span class="p">):</span>
            <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latex_term</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">}:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span> <span class="o">+</span> <span class="n">term</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">term_sep</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39; </span><span class="se">\\</span><span class="s1"> &#39;</span> <span class="k">if</span> <span class="n">sep_lines</span> <span class="k">else</span> <span class="s1">&#39; &#39;</span>

        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">term_sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_latex_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format a term into LaTeX form.</span>

<span class="sd">        This method does not generally need to be overridden.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp_factors</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeff_latex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
            <span class="n">coeff_latex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff_latex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latex_sympy</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coeff_latex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="n">coeff_latex</span> <span class="o">=</span> <span class="n">coeff_latex</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sum_{{</span><span class="si">{}</span><span class="s1"> \in </span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">label</span>
        <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coeff_latex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff_latex</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latex_sympy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">)</span>

        <span class="n">vecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_latex_vec_mul</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_latex_vec</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">vecs</span>
        <span class="p">)</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_latex_sympy</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the LaTeX form of SymPy expressions.</span>

<span class="sd">        The default SymPy method will be used, subclasses can override this</span>
<span class="sd">        method for fine tuning of the form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">latex</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_latex_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the LaTeX form of a vector.</span>

<span class="sd">        By default, the vector name is going to be put into boldface, and the</span>
<span class="sd">        indices are put into the subscripts.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">head</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\mathbf{{</span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_latex_sympy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vec</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_{{</span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="n">_latex_vec_mul</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39; \otimes &#39;</span>

<div class="viewcode-block" id="Drudge.report"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.report">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a report for results.</span>

<span class="sd">        This function should be used within a ``with`` statement to open a</span>
<span class="sd">        report for results.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. doctest::</span>
<span class="sd">            :options: +SKIP</span>

<span class="sd">            &gt;&gt;&gt; dr = Drudge(SparkContext())</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.sum(IndexedBase(&#39;x&#39;)[Symbol(&#39;a&#39;)])</span>
<span class="sd">            &gt;&gt;&gt; with dr.report(&#39;report.html&#39;, &#39;A simple tensor&#39;) as report:</span>
<span class="sd">            ...     report.add(&#39;Simple tensor&#39;, tensor)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">report</span> <span class="o">=</span> <span class="n">Report</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">report</span>
        <span class="n">report</span><span class="o">.</span><span class="n">write</span><span class="p">()</span></div>

    <span class="c1">#</span>
    <span class="c1"># Pickling support</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="Drudge.pickle_env"><a class="viewcode-back" href="../../api/base.html#drudge.Drudge.pickle_env">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">pickle_env</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare the environment for unpickling contents with tensors.</span>

<span class="sd">        Pickled contents containing tensors cannot be directly unpickled by the</span>
<span class="sd">        functions from the pickle module directly.  They should be used within</span>
<span class="sd">        the context created by this function.  Note that the content does not</span>
<span class="sd">        have to have a single tensor object.  Anything containing tensor objects</span>
<span class="sd">        needs to be loaded within the context.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            All tensors read within this environment will have the current</span>
<span class="sd">            drudge as their drudge.  No checking is, or can be, done to make</span>
<span class="sd">            sure that the tensors are sensible for the current drudge.  Normally</span>
<span class="sd">            it should be the same drudge as the drudge used for their creation</span>
<span class="sd">            be used.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; dr = Drudge(SparkContext())</span>
<span class="sd">            &gt;&gt;&gt; tensor = dr.sum(IndexedBase(&#39;x&#39;)[Symbol(&#39;a&#39;)])</span>
<span class="sd">            &gt;&gt;&gt; import pickle</span>
<span class="sd">            &gt;&gt;&gt; serialized = pickle.dumps(tensor)</span>
<span class="sd">            &gt;&gt;&gt; with dr.pickle_env():</span>
<span class="sd">            ...     res = pickle.loads(serialized)</span>
<span class="sd">            &gt;&gt;&gt; print(tensor == res)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">global</span> <span class="n">_default_drudge</span>

        <span class="n">_default_drudge</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">yield</span> <span class="kc">None</span>
        <span class="n">_default_drudge</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<span class="c1">#</span>
<span class="c1"># Global for pickling</span>
<span class="c1">#</span>


<span class="n">_default_drudge</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1">#</span>
<span class="c1"># Small static utilities</span>
<span class="c1">#</span>


<span class="k">def</span> <span class="nf">_union</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Union the two sets and return the first.&quot;&quot;&quot;</span>
    <span class="n">orig</span> <span class="o">|=</span> <span class="n">new</span>
    <span class="k">return</span> <span class="n">orig</span>


<span class="k">def</span> <span class="nf">_decompose_term</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decompose a term for simple merging.</span>

<span class="sd">    The given term will be decomposed into a pair, where the first field has the</span>
<span class="sd">    summations, vectors, and product of factors containing at least one dummy.</span>
<span class="sd">    And the second field contains factors involving no dummies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp_factors</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">vecs</span><span class="p">,</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">)),</span>
        <span class="n">coeff</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_nonzero</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if a term is trivially non-zero.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span> <span class="o">!=</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_resolve_default_range</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">range_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Resolve any expression to the given range.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">range_</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jinmo Zhao and Gustavo E Scuseria.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>