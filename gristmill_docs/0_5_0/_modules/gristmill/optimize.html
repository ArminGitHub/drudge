
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>gristmill.optimize &#8212; gristmill 0.5.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gristmill.optimize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Optimizer for the contraction computations.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">drudge</span> <span class="k">import</span> <span class="n">TensorDef</span><span class="p">,</span> <span class="n">prod_</span><span class="p">,</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Range</span><span class="p">,</span> <span class="n">sum_</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Integer</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span>
    <span class="n">default_sort_key</span><span class="p">,</span> <span class="n">Pow</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">multiset_partitions</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Size</span><span class="p">,</span> <span class="n">get_total_size</span><span class="p">,</span> <span class="n">mul_sizes</span><span class="p">,</span> <span class="n">DSF</span><span class="p">,</span> <span class="n">Tuple4Cmp</span><span class="p">,</span> <span class="n">form_sized_range</span>
<span class="p">)</span>


<span class="c1">#</span>
<span class="c1">#  The public driver</span>
<span class="c1">#  -----------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="Strategy"><a class="viewcode-back" href="../../api.html#gristmill.Strategy">[docs]</a><span class="k">class</span> <span class="nc">Strategy</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The optimization strategy for tensor contractions.</span>

<span class="sd">    This class holds possible options for different aspects of the optimization</span>
<span class="sd">    strategy for tensor contractions.  Options for different aspects of the</span>
<span class="sd">    problem should be combined by using the bitwise-or ``|`` operator.</span>

<span class="sd">    For the optimization of the single-term contractions, we have</span>

<span class="sd">    ``GREEDY``</span>
<span class="sd">        The contraction within each term will be optimized greedily.  This</span>
<span class="sd">        should only be used for inputs having terms containing many factors by a</span>
<span class="sd">        very dense pattern.</span>

<span class="sd">    ``BEST``</span>
<span class="sd">        The global minimum of each tensor contraction will be found by the</span>
<span class="sd">        advanced algorithm in gristmill.  And only the optimal contraction(s)</span>
<span class="sd">        will be kept for the summation optimization.</span>

<span class="sd">    ``SEARCHED``</span>
<span class="sd">        The same strategy as ``BEST`` will be attempted for the optimization of</span>
<span class="sd">        contractions.  But all evaluations searched in the optimization process</span>
<span class="sd">        will be kept and considered in subsequent summation optimizations.</span>

<span class="sd">    ``ALL``</span>
<span class="sd">        All possible contraction sequences will be considered for all terms.</span>
<span class="sd">        This can be extremely slow.  But it might be helpful for problems having</span>
<span class="sd">        terms all with manageable number of factors.</span>

<span class="sd">    For the summation factorization, we have</span>

<span class="sd">    ``SUM``</span>
<span class="sd">        Factorize the summations in the result.</span>

<span class="sd">    ``INACCURATE``</span>
<span class="sd">        Do not accurately calculate the saving in summation optimization.  This</span>
<span class="sd">        will skip the exact arithmetic for the costs and use a special heuristic</span>
<span class="sd">        the estimate the actual saving.</span>

<span class="sd">    For the common factor optimization, we have</span>

<span class="sd">    ``COMMON``</span>
<span class="sd">        Skip computation of the same factor up to permutation of indices in</span>
<span class="sd">        summations.</span>

<span class="sd">    We also have the default optimization strategy as ``DEFAULT``, which will be</span>
<span class="sd">    ``SEARCHED | SUM | COMMON``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">GREEDY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">BEST</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">SEARCHED</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">ALL</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">PROD_MASK</span> <span class="o">=</span> <span class="mb">0b11</span>

    <span class="n">SUM</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
    <span class="n">INACCURATE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>

    <span class="n">COMMON</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>

    <span class="c1"># Internal options, not useful for users.  If evaluations with negative</span>
    <span class="c1"># local/global saving will be considered.  They turn out to be not quite</span>
    <span class="c1"># useful and is pending removal.</span>

    <span class="n">RUSH_LOCAL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
    <span class="n">RUSH_GLOBAL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>

    <span class="n">DEFAULT</span> <span class="o">=</span> <span class="n">SEARCHED</span> <span class="o">|</span> <span class="n">SUM</span> <span class="o">|</span> <span class="n">COMMON</span>

    <span class="n">MAX</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span></div>


<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../../api.html#gristmill.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span>
        <span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">substs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="o">=</span><span class="s1">&#39;tau^</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">Strategy</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Optimize the valuation of the given tensor contractions.</span>

<span class="sd">    This function will transform the given computations, given as tensor</span>
<span class="sd">    definitions, into another list of computations mathematically equivalent to</span>
<span class="sd">    the given computation while requiring less floating-point operations</span>
<span class="sd">    (FLOPs).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    computs</span>
<span class="sd">        The computations, can be given as an iterable of tensor definitions.</span>

<span class="sd">    substs</span>
<span class="sd">        A dictionary for making substitutions inside the sizes of ranges.  All</span>
<span class="sd">        the ranges need to have size in at most one undetermined variable after</span>
<span class="sd">        the substitution, so that they can be totally ordered.  When one symbol</span>
<span class="sd">        still remains in the sizes, the asymptotic cost (scaling and prefactor)</span>
<span class="sd">        will be optimized.  Or when all symbols are gone after the substitution,</span>
<span class="sd">        optimization is going to be based on the numeric sizes.  Numeric sizes</span>
<span class="sd">        tend to make the optimization faster due to the usage of built-in</span>
<span class="sd">        integer or floating point arithmetic in lieu of the more complex</span>
<span class="sd">        polynomial arithmetic.</span>

<span class="sd">    interm_fmt</span>
<span class="sd">        The format for the names of the intermediates.</span>

<span class="sd">    simplify</span>
<span class="sd">        If the input is going to be simplified before processing.  It can be</span>
<span class="sd">        disabled when the input is already simplified.</span>

<span class="sd">    strategy</span>
<span class="sd">        The optimization strategy, as explained in :py:class:`Strategy`.</span>

<span class="sd">    greedy_cutoff</span>
<span class="sd">        The depth cutoff for making greedy selection in summation optimization.</span>
<span class="sd">        Beyond this depth in the recursion tree (inclusive), only the choices</span>
<span class="sd">        making locally best saving will be considered.  With negative values,</span>
<span class="sd">        full Bron-Kerbosch backtracking is performed.</span>

<span class="sd">    drop_cutoff</span>
<span class="sd">        The depth cutoff for picking only a random one with greedy saving in</span>
<span class="sd">        summation optimization.  The difference with the option</span>
<span class="sd">        ``greedy_cutoff`` is that here only **one** choice giving the locally</span>
<span class="sd">        best saving will be considered, rather than all of them.  This could</span>
<span class="sd">        give better acceleration than ``greedy_cutoff`` at the presence of large</span>
<span class="sd">        degeneracy, while results could be less optimized.  For large inputs, a</span>
<span class="sd">        value of ``2`` is advised.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">substs</span>

    <span class="n">computs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">if</span> <span class="n">simplify</span> <span class="k">else</span> <span class="n">i</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">computs</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">computs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No computation is given!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">&gt;=</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">MAX</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid optimization strategy&#39;</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>

    <span class="n">opt</span> <span class="o">=</span> <span class="n">_Optimizer</span><span class="p">(</span>
        <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="o">=</span><span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="o">=</span><span class="n">interm_fmt</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span>
        <span class="n">greedy_cutoff</span><span class="o">=</span><span class="n">greedy_cutoff</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=</span><span class="n">drop_cutoff</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span></div>


<span class="c1">#</span>
<span class="c1"># The internal optimization engine</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>
<span class="c1"># General small type definitions and functions</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>
<span class="c1"># These named tuples should be upgraded when PySpark has support for Python 3.6</span>
<span class="c1"># in their stable version.</span>
<span class="c1">#</span>
<span class="c1"># For general optimization.</span>
<span class="c1">#</span>


<span class="n">_Grain</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Grain&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;base&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;terms&#39;</span>
<span class="p">])</span>

<span class="n">_IntermRef</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_IntermRef&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;coeff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;base&#39;</span><span class="p">,</span>
    <span class="s1">&#39;indices&#39;</span><span class="p">,</span>
    <span class="s1">&#39;power&#39;</span>
<span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_ref_from_interm_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_IntermRef</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the reference to intermediate without coefficient.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span>


<span class="n">_IntermRef</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_ref_from_interm_ref</span><span class="p">)</span>

<span class="c1"># Symbol/range pairs.</span>
<span class="c1">#</span>
<span class="c1"># This type is mostly for the convenience of annotation.</span>

<span class="n">_SrPairs</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Range</span><span class="p">]]</span>

<span class="c1">#</span>
<span class="c1"># Internals for summation and product optimization</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>
<span class="c1"># Summation optimization.</span>
<span class="c1">#</span>


<span class="c1"># Organized references to products in a summation.</span>
<span class="c1">#</span>
<span class="c1"># Intermediate base -&gt; (indices -&gt; coefficient)</span>

<span class="n">_OrgTerms</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">DefaultDict</span><span class="p">[</span>
    <span class="n">Symbol</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">DefaultDict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Expr</span><span class="p">]</span>
<span class="p">]</span>

<span class="c1">#</span>
<span class="c1"># Static description of the collection graph.</span>
<span class="c1">#</span>

<span class="n">_LEFT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_RIGHT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_OPPOS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">_LEFT</span><span class="p">:</span> <span class="n">_RIGHT</span><span class="p">,</span>
    <span class="n">_RIGHT</span><span class="p">:</span> <span class="n">_LEFT</span>
<span class="p">}</span>

<span class="c1"># For type annotation, actually is should be ``_LEFT | _RIGHT`` in Haskell</span>
<span class="c1"># algebraic data type notation.</span>

<span class="n">_LR</span> <span class="o">=</span> <span class="nb">int</span>

<span class="n">_Ranges</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Ranges&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;exts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sums&#39;</span>
<span class="p">])</span>

<span class="n">_Edge</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Edge&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;term&#39;</span><span class="p">,</span>
    <span class="s1">&#39;eval_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;base&#39;</span><span class="p">,</span>
    <span class="s1">&#39;coeff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exc_cost&#39;</span><span class="p">,</span>
<span class="p">])</span>

<span class="n">_Adjs</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
    <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">Term</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">Term</span><span class="p">,</span> <span class="n">_Edge</span><span class="p">]],</span>
    <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">Term</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">Term</span><span class="p">,</span> <span class="n">_Edge</span><span class="p">]]</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">_BaseInfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Information about a base referenced in a sum node.</span>

<span class="sd">    This is an open struct, with most of its manipulation done inside the</span>
<span class="sd">    optimizer class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;count&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cost&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the information.</span>

<span class="sd">        The count will be initialized to one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span>


<span class="k">class</span> <span class="nc">_BaseInfoDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mapping from symbol of bases to its information.</span>

<span class="sd">    Symbol -&gt; _BaseInfo.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the given base.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">_BaseInfo</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">remove_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">term_base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the terms from base information dictionary.</span>

<span class="sd">        The bases that have been updated by this will be returned in a</span>
<span class="sd">        set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">updated</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">term_base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">updated</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">updated</span>


<span class="c1">#</span>
<span class="c1"># Intermediate data and results for the Kron-Kerbosch process.</span>
<span class="c1">#</span>


<span class="c1"># Additional information about a node when it is used to augment the current</span>
<span class="c1"># biclique.</span>
<span class="n">_Delta</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Delta&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;coeff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;terms&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bases&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exc_cost&#39;</span><span class="p">,</span>
    <span class="s1">&#39;saving&#39;</span>
<span class="p">])</span>

<span class="c1"># Dictionary of the nodes that can possibly to used to augment the current</span>
<span class="c1"># biclique.  To be used for variables like ``subg`` and ``cand`` in the</span>
<span class="c1"># Bron-Kerbosch algorithm.</span>
<span class="n">_Nodes</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span>
    <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Term</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Delta</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">_Biclique</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Biclique&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;nodes&#39;</span><span class="p">,</span>  <span class="c1"># Left and right, nodes and coefficients.</span>
    <span class="s1">&#39;leading_coeff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;terms&#39;</span><span class="p">,</span>
    <span class="s1">&#39;saving&#39;</span>
<span class="p">])</span>

<span class="c1">#</span>
<span class="c1"># Cost-related utilities for the Kron-Kerbosch process.</span>
<span class="c1">#</span>


<span class="c1"># These coefficients cached here can make the computation of the saving of a</span>
<span class="c1"># biclique easy and fast.</span>

<span class="n">_CostCoeffs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_CostCoeffs&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1"># The final cost for contraction and make an addition of the results.</span>
    <span class="s1">&#39;final&#39;</span><span class="p">,</span>
    <span class="c1"># The cost of making an addition for left and right factors.</span>
    <span class="s1">&#39;preps&#39;</span>
<span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_cost_coeffs</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_CostCoeffs</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get the cost coefficients for the given ranges.&quot;&quot;&quot;</span>

    <span class="n">ext_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
        <span class="n">ranges</span><span class="o">.</span><span class="n">exts</span>
    <span class="p">))</span>

    <span class="n">final</span> <span class="o">=</span> <span class="n">_get_prod_final_cost</span><span class="p">(</span>
        <span class="n">ext_size</span><span class="p">,</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">ext_size</span>

    <span class="n">preps</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">get_total_size</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ranges</span><span class="o">.</span><span class="n">sums</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ranges</span><span class="o">.</span><span class="n">exts</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_CostCoeffs</span><span class="p">(</span><span class="n">final</span><span class="o">=</span><span class="n">final</span><span class="p">,</span> <span class="n">preps</span><span class="o">=</span><span class="n">preps</span><span class="p">)</span>


<span class="n">_Saving</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Saving&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="c1"># Total current saving.</span>
    <span class="s1">&#39;saving&#39;</span><span class="p">,</span>
    <span class="c1"># Additional saving when one more left/right factor is collected.</span>
    <span class="s1">&#39;deltas&#39;</span>
<span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_collect_saving</span><span class="p">(</span><span class="n">coeffs</span><span class="p">:</span> <span class="n">_CostCoeffs</span><span class="p">,</span> <span class="n">n_s</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Get the saving for collection.</span>

<span class="sd">    For the given ranges, when we make a collection of the given number of left</span>
<span class="sd">    factors and the given number of right factors, we have saving,</span>

<span class="sd">    .. math::</span>

<span class="sd">        n_l n_r C(s) e_l e_r s + (n_l n_r - 1) e_l e_r</span>
<span class="sd">        - (n_l - 1) e_l s - (n_r - 1) e_r s - C(s) e_l e_r s</span>

<span class="sd">    where :math:`C(s)` equals one for no summation and two for the presence of</span>
<span class="sd">    summations.  It also equals</span>

<span class="sd">    .. math::</span>

<span class="sd">        (n_l n_r - 1) (C(s) e_l e_r s + e_l e_r)</span>
<span class="sd">        - (n_l - 1) e_l s - (n_r - 1) e_r s</span>

<span class="sd">    When we collect terms with :math:`n_l`, it reads,</span>

<span class="sd">    .. math::</span>

<span class="sd">        n_l (</span>
<span class="sd">            n_r C(s) e_l e_r s + n_r e_l e_r - e_l s</span>
<span class="sd">        )</span>
<span class="sd">        - n_r e_r s</span>
<span class="sd">        + e_l s + e_r s - e_l e_r - C(s) e_l e_r s</span>

<span class="sd">    or symmetrically</span>

<span class="sd">    .. math::</span>

<span class="sd">        n_r (</span>
<span class="sd">            n_l C(s) e_l e_r s + n_l e_l e_r - e_r s</span>
<span class="sd">        )</span>
<span class="sd">        - n_l e_l s</span>
<span class="sd">        + e_l s + e_r s - e_l e_r - C(s) e_l e_r s</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">preps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="n">n_terms</span> <span class="o">=</span> <span class="n">mul_sizes</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span>

    <span class="n">saving</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_terms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">final</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">j</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">n_s</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">preps</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># for i, j in zip(reversed(n_s), coeffs.preps):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">preps</span><span class="p">):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This could allow bicliques empty in a direction to be augmented by</span>
            <span class="c1"># any left or right term.  A value of infinity has to be used to</span>
            <span class="c1"># mask the possible non-zero excess costs.</span>
            <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">n_s</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># This prevents a dimension get expanded without anything.</span>
            <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_s</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">final</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="k">return</span> <span class="n">_Saving</span><span class="p">(</span><span class="n">saving</span><span class="o">=</span><span class="n">saving</span><span class="p">,</span> <span class="n">deltas</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">deltas</span><span class="p">))</span>


<span class="c1">#</span>
<span class="c1"># The core classes.</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_BronKerbosch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterable for the maximal bicliques.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">adjs</span><span class="p">:</span> <span class="n">_Adjs</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">:</span> <span class="n">_BaseInfoDict</span><span class="p">,</span>
            <span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">,</span> <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">rush_local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inaccurate</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the iterator.&quot;&quot;&quot;</span>

        <span class="c1"># Static data during the recursion.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span> <span class="o">=</span> <span class="n">adjs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span> <span class="o">=</span> <span class="n">base_infos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cost_coeffs</span> <span class="o">=</span> <span class="n">_get_cost_coeffs</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span> <span class="o">=</span> <span class="n">greedy_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span> <span class="o">=</span> <span class="n">drop_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rush_local</span> <span class="o">=</span> <span class="n">rush_local</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rush_global</span> <span class="o">=</span> <span class="n">rush_global</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inaccurate</span> <span class="o">=</span> <span class="n">inaccurate</span>

        <span class="c1"># Dynamic data during the recursion.</span>
        <span class="c1">#</span>
        <span class="c1"># Nodes and coefficients, for left and right.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">([],</span> <span class="p">[]),</span>
            <span class="p">([],</span> <span class="p">[])</span>
        <span class="p">)</span>
        <span class="c1"># The set of terms currently in the biclique.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># type: typing.Set[Symbol]</span>
        <span class="c1"># The count of bases in the **uncollected** terms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">base_infos</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">count</span>
        <span class="c1"># The stack of excess costs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exc_costs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The leading coefficient.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the maximal bicliques.&quot;&quot;&quot;</span>

        <span class="c1"># All left and right nodes.</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> <span class="n">_Delta</span><span class="p">(</span>
                <span class="n">coeff</span><span class="o">=</span><span class="n">_UNITY</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">bases</span><span class="o">=</span><span class="p">{},</span> <span class="n">exc_cost</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">saving</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>

        <span class="c1"># If things all goes correctly, the stack should be reverted to initial</span>
        <span class="c1"># state by now.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">continue</span>
            <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exc_costs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">subg</span><span class="p">:</span> <span class="n">_Nodes</span><span class="p">,</span> <span class="n">curr_subg</span><span class="p">:</span> <span class="n">_Nodes</span><span class="p">,</span>
            <span class="n">cand</span><span class="p">:</span> <span class="n">_Nodes</span><span class="p">,</span> <span class="n">curr_cand</span><span class="p">:</span> <span class="n">_Nodes</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the bicliques from the current state.</span>

<span class="sd">        This is the core of the Bron-Kerbosch algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exc_costs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exc_costs</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exc_costs</span><span class="p">)</span>

        <span class="c1"># The current state.</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span>
        <span class="n">inaccurate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inaccurate</span>

        <span class="c1"># The code here are adapted from the code in NetworkX for maximal clique</span>
        <span class="c1"># problem of simple general graphs.  The original code are kept as much</span>
        <span class="c1"># as possible and put in comments.  The original code on which the code</span>
        <span class="c1"># is based can be found at,</span>
        <span class="c1">#</span>
        <span class="c1"># https://github.com/networkx/networkx/blob</span>
        <span class="c1"># /48f4b5736174844c77044fae90e3e7adf1dabc10/networkx/algorithms</span>
        <span class="c1"># /clique.py#L277-L299</span>
        <span class="c1">#</span>

        <span class="c1">#</span>
        <span class="c1"># u = max(subg, key=lambda u: len(cand &amp; adj[u]))</span>
        <span class="c1">#</span>
        <span class="c1"># Here it is very expensive to make sure that a node can be a pivot.</span>
        <span class="c1"># Hence currently we do not perform it here.</span>

        <span class="c1"># Recursion is stopped earlier than here.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_subg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">to_loop</span> <span class="o">=</span> <span class="n">curr_cand</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_loop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">cut_greedy</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span> <span class="o">&lt;=</span> <span class="n">depth</span>
        <span class="p">)</span>
        <span class="n">cut_full</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span> <span class="o">&lt;=</span> <span class="n">depth</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cut_greedy</span> <span class="ow">or</span> <span class="n">cut_full</span><span class="p">:</span>
            <span class="n">greedy_saving</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">saving</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span><span class="p">)</span>
            <span class="n">to_loop</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">saving</span> <span class="o">==</span> <span class="n">greedy_saving</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">cut_full</span><span class="p">:</span>
                <span class="n">to_loop</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">to_loop</span><span class="p">)]</span>

        <span class="c1">#</span>
        <span class="c1"># for q in cand - adj[u]:</span>
        <span class="c1">#</span>
        <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">to_loop</span><span class="p">:</span>

            <span class="c1">#</span>
            <span class="c1"># cand.remove(q)</span>
            <span class="c1">#</span>
            <span class="n">colour</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span>
            <span class="k">assert</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">cand</span>
            <span class="k">del</span> <span class="n">cand</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>

            <span class="c1">#</span>
            <span class="c1"># Q.append(q)</span>
            <span class="c1">#</span>
            <span class="n">new_terms</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">terms</span>
            <span class="n">new_bases</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">bases</span>
            <span class="n">curr</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">curr</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">terms</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
            <span class="n">terms</span> <span class="o">|=</span> <span class="n">new_terms</span>
            <span class="n">bases</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">new_bases</span><span class="p">)</span>
            <span class="n">exc_costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">exc_cost</span><span class="p">)</span>

            <span class="n">oppos</span> <span class="o">=</span> <span class="n">_OPPOS</span><span class="p">[</span><span class="n">colour</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">oppos</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">leading_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="n">node</span><span class="p">][</span>
                    <span class="n">curr</span><span class="p">[</span><span class="n">oppos</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="n">leading_edge</span><span class="o">.</span><span class="n">coeff</span>

            <span class="n">ns</span><span class="p">,</span> <span class="n">saving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_stack</span><span class="p">(</span><span class="n">inaccurate</span><span class="o">=</span><span class="n">inaccurate</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># adj_q = adj[q]</span>
            <span class="c1"># subg_q = subg &amp; adj_q</span>
            <span class="c1">#</span>
            <span class="n">subg_q</span><span class="p">,</span> <span class="n">curr_subg_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_nodes</span><span class="p">(</span>
                <span class="n">subg</span><span class="p">,</span> <span class="n">saving</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="n">node</span>
            <span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># if not subg_q:</span>
            <span class="c1">#    yield Q[:]</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_subg_q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># These cases cannot possibly give saving.</span>
                <span class="n">if_skip</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ns</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">if_skip</span><span class="p">:</span>

                    <span class="c1"># The total saving.</span>
                    <span class="k">if</span> <span class="n">inaccurate</span><span class="p">:</span>
                        <span class="n">saving</span> <span class="o">=</span> <span class="n">saving</span><span class="o">.</span><span class="n">saving</span>
                        <span class="n">has_saving</span> <span class="o">=</span> <span class="n">saving</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">assert</span> <span class="n">has_saving</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">saving</span> <span class="o">=</span> <span class="n">saving</span><span class="o">.</span><span class="n">saving</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exc_costs</span><span class="p">)</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rush_global</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">saving</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">*</span> <span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">v</span>
                                    <span class="p">)</span>

                        <span class="n">has_saving</span> <span class="o">=</span> <span class="n">saving</span> <span class="o">&gt;</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">has_saving</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">_Biclique</span><span class="p">(</span>
                            <span class="n">nodes</span><span class="o">=</span><span class="n">curr</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span><span class="p">,</span>
                            <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">,</span> <span class="n">saving</span><span class="o">=</span><span class="n">saving</span>
                        <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1"># cand_q = cand &amp; adj_q</span>
                <span class="c1">#</span>
                <span class="n">cand_q</span><span class="p">,</span> <span class="n">curr_cand_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_nodes</span><span class="p">(</span>
                    <span class="n">cand</span><span class="p">,</span> <span class="n">saving</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="n">node</span>
                <span class="p">)</span>

                <span class="c1"># if cand_q:</span>
                <span class="c1">#     for clique in expand(subg_q, cand_q):</span>
                <span class="c1">#         yield clique</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_cand_q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span>
                        <span class="n">subg_q</span><span class="p">,</span> <span class="n">curr_subg_q</span><span class="p">,</span> <span class="n">cand_q</span><span class="p">,</span> <span class="n">curr_cand_q</span>
                    <span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Q.pop()</span>
            <span class="c1">#</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">curr</span><span class="p">[</span><span class="n">colour</span><span class="p">]:</span>
                <span class="n">i</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">terms</span> <span class="o">-=</span> <span class="n">new_terms</span>
            <span class="n">bases</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_bases</span><span class="p">)</span>
            <span class="n">exc_costs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_filter_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">_Nodes</span><span class="p">,</span>
            <span class="n">saving</span><span class="p">:</span> <span class="n">_Saving</span><span class="p">,</span> <span class="n">new_colour</span><span class="p">:</span> <span class="n">_LR</span><span class="p">,</span> <span class="n">new_node</span><span class="p">:</span> <span class="n">Term</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Nodes</span><span class="p">,</span> <span class="n">_Nodes</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Filter the nodes for the current stack.</span>

<span class="sd">        In the original Bron-Kerbosch algorithm, both subg and cand are filtered</span>
<span class="sd">        by union with the adjacent nodes of the newly added node.  Now the</span>
<span class="sd">        computation can be a lot more complex than that.  We need to note,</span>

<span class="sd">        1. No term already contained can be decomposed in another way in a</span>
<span class="sd">        different evaluation.</span>

<span class="sd">        2. The coefficients need to match the existing proportion.</span>

<span class="sd">        We also have less to note in that we do not require any connectivity</span>
<span class="sd">        among nodes with the same colour.</span>

<span class="sd">        Here all expandable nodes and the profitable ones among them for the</span>
<span class="sd">        current step will be returned.  The profitable nodes for the current</span>
<span class="sd">        step contains only the nodes that is profitable right now.  The all</span>
<span class="sd">        expandable nodes has all nodes that are valid to be augmented into the</span>
<span class="sd">        current stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node_key</span><span class="p">,</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">colour</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node_key</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_delta</span><span class="p">(</span>
                <span class="n">new_colour</span><span class="p">,</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">saving</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">delta</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">all_</span><span class="p">[</span><span class="n">node_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">continue</span>

        <span class="n">curr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">saving</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">all_</span><span class="p">,</span> <span class="n">curr</span>

    <span class="k">def</span> <span class="nf">_update_delta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">new_colour</span><span class="p">,</span> <span class="n">new_node</span><span class="p">,</span> <span class="n">saving</span><span class="p">,</span> <span class="n">colour</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">delta</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Delta</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Update the delta when a new node is added to the stack.</span>

<span class="sd">        This is the performance bottleneck of the Bron-Kerbosch algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
        <span class="n">inaccurate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inaccurate</span>

        <span class="c1"># Most basic filtering.  The node with the same colour as the new node</span>
        <span class="c1"># will not be affected by the new addition.</span>
        <span class="k">if</span> <span class="n">colour</span> <span class="o">!=</span> <span class="n">new_colour</span> <span class="ow">and</span> <span class="n">new_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">oppos_curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">[</span><span class="n">_OPPOS</span><span class="p">[</span><span class="n">colour</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oppos_curr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">leading_edge</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">oppos_curr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leading_edge</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">colour</span> <span class="o">!=</span> <span class="n">new_colour</span><span class="p">:</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">new_node</span><span class="p">]</span>

            <span class="c1"># We have at least the new node was just added.</span>
            <span class="k">assert</span> <span class="n">leading_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_edge</span><span class="o">.</span><span class="n">coeff</span> <span class="o">/</span> <span class="n">leading_edge</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="n">oppos_curr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">res_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
            <span class="n">res_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_edge</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>

            <span class="n">res_bases</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
            <span class="n">res_bases</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span>
            <span class="n">res_bases</span><span class="p">[</span><span class="n">new_edge</span><span class="o">.</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">inaccurate</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res_exc_cost</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res_exc_cost</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">exc_cost</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_exc_cost</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">+</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">exc_cost</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_terms</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">terms</span>
            <span class="n">res_bases</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">bases</span>
            <span class="n">res_exc_cost</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">exc_cost</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res_terms</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">res_coeff</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">delta</span><span class="o">.</span><span class="n">coeff</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">leading_edge</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">leading_edge</span><span class="o">.</span><span class="n">coeff</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span>
        <span class="p">)</span>

        <span class="n">base_saving</span> <span class="o">=</span> <span class="n">saving</span><span class="o">.</span><span class="n">deltas</span><span class="p">[</span><span class="n">colour</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">inaccurate</span><span class="p">:</span>
            <span class="n">res_saving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_inaccurate_delta_saving</span><span class="p">(</span>
                <span class="n">base_saving</span><span class="p">,</span> <span class="n">res_exc_cost</span><span class="p">,</span> <span class="n">res_bases</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_saving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_delta_saving</span><span class="p">(</span>
                <span class="n">base_saving</span><span class="p">,</span> <span class="n">res_exc_cost</span><span class="p">,</span> <span class="n">res_bases</span>
            <span class="p">)</span>

        <span class="n">res_delta</span> <span class="o">=</span> <span class="n">_Delta</span><span class="p">(</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">res_coeff</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">res_terms</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">res_bases</span><span class="p">,</span>
            <span class="n">exc_cost</span><span class="o">=</span><span class="n">res_exc_cost</span><span class="p">,</span> <span class="n">saving</span><span class="o">=</span><span class="n">res_saving</span>
        <span class="p">)</span>

        <span class="c1"># Sanity checking, should be disabled in production.</span>
        <span class="c1"># assert res_delta == self._form_delta(colour, node, saving)</span>

        <span class="k">return</span> <span class="n">res_delta</span>

    <span class="k">def</span> <span class="nf">_get_delta_saving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_saving</span><span class="p">,</span> <span class="n">exc_cost</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Size</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the saving incurred by applying a given delta.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">base_saving</span> <span class="o">-</span> <span class="n">exc_cost</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rush_local</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bases</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">base_saving</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">cost</span> <span class="o">*</span> <span class="n">v</span>
                <span class="k">continue</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_get_inaccurate_delta_saving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_saving</span><span class="p">,</span> <span class="n">exc_cost</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the saving incurred by a delta in inaccurate mode.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">exc_cost</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">base_saving</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="n">res_saving</span> <span class="o">=</span> <span class="n">base_saving</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_saving</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">curbed_by_common</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rush_local</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bases</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bases</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">curbed_by_common</span><span class="p">:</span>
            <span class="n">res_saving</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">res_saving</span>

    <span class="k">def</span> <span class="nf">_count_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inaccurate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the current size of the stack.</span>

<span class="sd">        The saving will also be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_LEFT</span><span class="p">,</span> <span class="n">_RIGHT</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">inaccurate</span><span class="p">:</span>
            <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">ns</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">saving</span> <span class="o">=</span> <span class="n">_Saving</span><span class="p">(</span><span class="n">saving</span><span class="o">=</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ns</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deltas</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">deltas</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">saving</span> <span class="o">=</span> <span class="n">_get_collect_saving</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cost_coeffs</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ns</span><span class="p">,</span> <span class="n">saving</span>

    <span class="k">def</span> <span class="nf">_form_delta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">colour</span><span class="p">:</span> <span class="n">_LR</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Term</span><span class="p">,</span> <span class="n">saving</span><span class="p">:</span> <span class="n">_Saving</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Delta</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Form the delta for adding a new node from scratch.</span>

<span class="sd">        When it is expandable, the relevant node information will be</span>
<span class="sd">        returned, or None will be the result.</span>

<span class="sd">        THIS FUNCTION IS DEPRECATED AND PENDING REMOVAL.  Currently it is only</span>
<span class="sd">        used for the sanity checking of the optimized result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cache frequently used information.</span>
        <span class="n">oppos_colour</span> <span class="o">=</span> <span class="n">_OPPOS</span><span class="p">[</span><span class="n">colour</span><span class="p">]</span>
        <span class="n">adjs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">[</span><span class="n">colour</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span>

        <span class="n">base_coeff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">exc_cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">new_bases</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">oppos_colour</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adjs</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">adjs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="c1"># type: _Edge</span>

            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span> <span class="ow">or</span> <span class="n">edge</span><span class="o">.</span><span class="n">term</span> <span class="ow">in</span> <span class="n">new_terms</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">coeff</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">base_coeff</span> <span class="o">=</span> <span class="n">coeff</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">/</span> <span class="n">base_coeff</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="n">curr</span><span class="p">[</span><span class="n">oppos_colour</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span>

            <span class="n">exc_cost</span> <span class="o">+=</span> <span class="n">edge</span><span class="o">.</span><span class="n">exc_cost</span>
            <span class="n">new_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
            <span class="n">new_bases</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">continue</span>

        <span class="c1"># When we get here, it should be expandable now.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">base_coeff</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span>

        <span class="n">new_saving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_delta_saving</span><span class="p">(</span>
            <span class="n">saving</span><span class="o">.</span><span class="n">deltas</span><span class="p">[</span><span class="n">colour</span><span class="p">],</span> <span class="n">exc_cost</span><span class="p">,</span> <span class="n">new_bases</span>
        <span class="p">)</span>

        <span class="c1"># For empty stack, we always get here with base information (coeff=1,</span>
        <span class="c1"># new_terms=empty, exc_cost=0).</span>
        <span class="k">return</span> <span class="n">_Delta</span><span class="p">(</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">new_terms</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">new_bases</span><span class="p">,</span> <span class="n">exc_cost</span><span class="o">=</span><span class="n">exc_cost</span><span class="p">,</span>
            <span class="n">saving</span><span class="o">=</span><span class="n">new_saving</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_CollectGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Graph for the collectibles of a given range.</span>

<span class="sd">    This data structure, and the maximal biclique generation in Bron-Kerbosch</span>
<span class="sd">    style, are the core of the factorization algorithm for sums.</span>

<span class="sd">    We have separate graph for different ranges.  For each range, the graph has</span>
<span class="sd">    the factors as nodes, and actual evaluations with the factors as edges.</span>
<span class="sd">    Internally, the graph is stored as two sparse adjacent lists.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the collectible table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span>
            <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span> <span class="o">=</span> <span class="n">_BaseInfoDict</span><span class="p">()</span>

        <span class="c1"># The optimal biclique in the current graph.  None when it is not yet</span>
        <span class="c1"># determined,  zero when it is determined that there is no profitable</span>
        <span class="c1"># biclique in the current graph.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">eval_</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span>
            <span class="n">opt_cost</span><span class="p">,</span> <span class="n">eval_cost</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new edge to the graph.&quot;&quot;&quot;</span>

        <span class="n">edge</span> <span class="o">=</span> <span class="n">_Edge</span><span class="p">(</span>
            <span class="n">term</span><span class="o">=</span><span class="n">term</span><span class="p">,</span> <span class="n">eval_</span><span class="o">=</span><span class="n">eval_</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span>
            <span class="n">exc_cost</span><span class="o">=</span><span class="n">eval_cost</span> <span class="o">-</span> <span class="n">opt_cost</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span>
        <span class="p">)</span>

        <span class="n">left_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">[</span><span class="n">_LEFT</span><span class="p">][</span><span class="n">left</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left_adj</span><span class="p">:</span>
            <span class="n">left_adj</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># It is possible that two evaluations actually the same be recorded</span>
            <span class="c1"># twice in the evaluation of product nodes because of symmetry.</span>
            <span class="k">assert</span> <span class="n">left_adj</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">term</span>

        <span class="n">right_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">[</span><span class="n">_RIGHT</span><span class="p">][</span><span class="n">right</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">right_adj</span><span class="p">:</span>
            <span class="n">right_adj</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">right_adj</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">term</span>

        <span class="k">if</span> <span class="n">term</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

            <span class="c1"># We do not need actual cost here.  For optimization purpose, the</span>
            <span class="c1"># bases should always be read from the centralized base infos across</span>
            <span class="c1"># all graphs.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="o">.</span><span class="n">add_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_opt_biclique</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">:</span> <span class="n">_BaseInfoDict</span><span class="p">,</span>
            <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">rush_local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inaccurate</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Size</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Biclique</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get the optimal biclique in the current graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span>

        <span class="n">opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">biclique</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_bicliques</span><span class="p">(</span>
                <span class="n">ranges</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span>
                <span class="n">greedy_cutoff</span><span class="o">=</span><span class="n">greedy_cutoff</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=</span><span class="n">drop_cutoff</span><span class="p">,</span>
                <span class="n">rush_local</span><span class="o">=</span><span class="n">rush_local</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="n">rush_global</span><span class="p">,</span>
                <span class="n">inaccurate</span><span class="o">=</span><span class="n">inaccurate</span>
        <span class="p">):</span>

            <span class="n">saving</span> <span class="o">=</span> <span class="n">biclique</span><span class="o">.</span><span class="n">saving</span>

            <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">saving</span> <span class="o">&gt;</span> <span class="n">opt_saving</span><span class="p">:</span>
                <span class="n">opt_saving</span> <span class="o">=</span> <span class="n">saving</span>
                <span class="c1"># Make copy only when we need them.</span>
                <span class="n">opt_biclique</span> <span class="o">=</span> <span class="n">_Biclique</span><span class="p">(</span>
                    <span class="n">nodes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                        <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">biclique</span><span class="o">.</span><span class="n">nodes</span>
                    <span class="p">),</span>
                    <span class="n">leading_coeff</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">leading_coeff</span><span class="p">,</span>
                    <span class="n">terms</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">),</span>
                    <span class="n">saving</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">saving</span>
                <span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">opt_biclique</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inaccurate</span><span class="p">:</span>
                <span class="n">saving</span> <span class="o">=</span> <span class="n">_get_collect_saving</span><span class="p">(</span><span class="n">_get_cost_coeffs</span><span class="p">(</span><span class="n">ranges</span><span class="p">),</span> <span class="p">[</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">opt_biclique</span><span class="o">.</span><span class="n">nodes</span>
                <span class="p">])</span>
                <span class="n">opt_biclique</span> <span class="o">=</span> <span class="n">opt_biclique</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">saving</span><span class="o">=</span><span class="n">saving</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="n">opt_saving</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="n">opt_biclique</span>

        <span class="k">return</span> <span class="n">opt_saving</span><span class="p">,</span> <span class="n">opt_biclique</span>

    <span class="k">def</span> <span class="nf">gen_bicliques</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">:</span> <span class="n">_BaseInfoDict</span><span class="p">,</span>
            <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">rush_local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inaccurate</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">_Biclique</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Generate the bicliques within the graph.</span>

<span class="sd">        For performance reasons, the bicliques generated will contain references</span>
<span class="sd">        to internal mutable data.  It is the responsibility of the caller to</span>
<span class="sd">        make proper copy when it is necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">yield from</span> <span class="n">_BronKerbosch</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span>
            <span class="n">greedy_cutoff</span><span class="o">=</span><span class="n">greedy_cutoff</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=</span><span class="n">drop_cutoff</span><span class="p">,</span>
            <span class="n">rush_local</span><span class="o">=</span><span class="n">rush_local</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="n">rush_global</span><span class="p">,</span>
            <span class="n">inaccurate</span><span class="o">=</span><span class="n">inaccurate</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">AbstractSet</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">term_base</span><span class="p">,</span>
            <span class="n">updated_bases</span><span class="p">,</span> <span class="n">base_infos</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges and nodes involving the given terms.</span>

<span class="sd">        If a value of True is returned, we have an empty graph after the</span>
<span class="sd">        removal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">if_empty</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">if_updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">if_updated</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">new_adjs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">),</span>
                <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">if_empty</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span><span class="p">,</span> <span class="n">new_adjs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">conns</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_conns</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">to_node</span><span class="p">:</span> <span class="n">edge</span>
                        <span class="k">for</span> <span class="n">to_node</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">conns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">term</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">terms</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_conns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">if_empty</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">new</span><span class="p">[</span><span class="n">from_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_conns</span>
                    <span class="k">continue</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_adjs</span> <span class="o">=</span> <span class="n">new_adjs</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="o">.</span><span class="n">remove_terms</span><span class="p">(</span><span class="n">terms</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">,</span> <span class="n">term_base</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">-=</span> <span class="n">terms</span>

        <span class="c1"># We need to update the maximum biclique when a base is recently updated</span>
        <span class="c1"># such that it become exclusively-involved by this graph.</span>
        <span class="n">if_dirty</span> <span class="o">=</span> <span class="n">if_updated</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span> <span class="ow">and</span>
            <span class="n">base_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">updated_bases</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">if_dirty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">if_empty</span>


<span class="n">_Collectibles</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">DefaultDict</span><span class="p">[</span><span class="n">_Ranges</span><span class="p">,</span> <span class="n">_CollectGraph</span><span class="p">]</span>

<span class="c1">#</span>
<span class="c1"># For product optimization.</span>
<span class="c1">#</span>

<span class="n">_Part</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Part&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;ref&#39;</span><span class="p">,</span>
    <span class="s1">&#39;node&#39;</span>
<span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_prod_final_cost</span><span class="p">(</span><span class="n">exts_total_size</span><span class="p">,</span> <span class="n">sums_total_size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Size</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the final cost for a pairwise product evaluation.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sums_total_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">exts_total_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">exts_total_size</span> <span class="o">*</span> <span class="n">sums_total_size</span>


<span class="c1">#</span>
<span class="c1"># Core evaluation DAG nodes</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_EvalNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A node in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span>

        <span class="c1"># For optimization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[_EvalNode]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For result finalization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_substs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get substitutions and symbols requiring exclusion before indexing.</span>

<span class="sd">        First resetting dummies excluding the returned symbols and then making</span>
<span class="sd">        the returned substitution on each term could achieve indexing.  Since</span>
<span class="sd">        the real free symbols are already gather from all inputs, the free</span>
<span class="sd">        symbols are not considered here.  But they should be added for the</span>
<span class="sd">        resetting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">dumm</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">substs</span><span class="p">[</span><span class="n">dumm</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">excl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dumm</span><span class="p">)</span>
            <span class="n">excl</span> <span class="o">|=</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span>


<span class="k">class</span> <span class="nc">_Sum</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sum nodes in the evaluation graph.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span> <span class="o">=</span> <span class="n">sum_terms</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Sum(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, sum_terms=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_Prod</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product nodes in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sums</span> <span class="o">=</span> <span class="n">sums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Prod(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, sums=</span><span class="si">{}</span><span class="s1">, coeff=</span><span class="si">{}</span><span class="s1">, factors=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sums</span><span class="p">),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
        <span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Core optimizer class</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_Optimizer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Optimizer for tensor contraction computations.</span>

<span class="sd">    This internal optimizer can only be used once for one set of input.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Public functions.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span>
            <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the optimizer.&quot;&quot;&quot;</span>

        <span class="c1"># Information to be read from the input computations.</span>
        <span class="c1">#</span>
        <span class="c1"># The only drudge for the inputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># The only variable for range sizes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Mapping from the substituted range to original range.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Symbols that should not be used for dummies.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Read, process, and verify user input.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_form_grain</span><span class="p">(</span><span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span> <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span>
        <span class="p">]</span>

        <span class="c1"># Dummies stock in terms of the substituted range.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Other internal data preparation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interm_fmt</span> <span class="o">=</span> <span class="n">interm_fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span> <span class="o">=</span> <span class="n">greedy_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span> <span class="o">=</span> <span class="n">drop_cutoff</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># From intermediate base to actual evaluation node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># From the canonical form to intermediate base.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given computations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

        <span class="n">res_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize</span><span class="p">(</span><span class="n">res_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

    <span class="c1">#</span>
    <span class="c1"># User input pre-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_form_grain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form grain for a given computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_drudge</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">drudge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="n">curr_drudge</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">curr_drudge</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid computations to optimize, containing two drudges&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">curr_drudge</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Externals processing.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>
        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">}</span>

        <span class="c1"># Terms processing.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs_terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid term to optimize&#39;</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="s1">&#39;expecting scalar&#39;</span>
                <span class="p">)</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span>

            <span class="c1"># Add the true free symbols to the exclusion set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|=</span> <span class="n">term</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">-</span> <span class="n">ext_symbs</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()))</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_proc_sums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a summation list.</span>

<span class="sd">        The ranges will be replaced with substituted sizes.  Relevant members of</span>
<span class="sd">        the optimizer will also be updated.  User error will also be reported.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">range_</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>

            <span class="n">new_range</span><span class="p">,</span> <span class="n">range_var</span> <span class="o">=</span> <span class="n">form_sized_range</span><span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">range_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="n">range_var</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">!=</span> <span class="n">range_var</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Invalid range&#39;</span><span class="p">,</span> <span class="n">range_</span><span class="p">,</span> <span class="s1">&#39;unexpected symbol&#39;</span><span class="p">,</span>
                        <span class="n">range_var</span><span class="p">,</span> <span class="s1">&#39;conflicting with&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">new_range</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_</span>
            <span class="k">elif</span> <span class="n">range_</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid ranges&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]),</span>
                    <span class="s1">&#39;duplicated labels&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">symb</span><span class="p">,</span> <span class="n">new_range</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Optimization result post-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_linearize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">optimized</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_EvalNode</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Linearize optimized forms of the evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Separate the intermediates and the results so that the results can be</span>
        <span class="c1"># guaranteed to be at the end of the evaluation sequence.</span>
        <span class="n">interms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">interms</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">interms</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_set_n_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set reference counts from an evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># We need to find an evaluation with optimal cost.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
        <span class="p">)]</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="n">possible_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">possible_refs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible_refs</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dep_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
            <span class="n">dep_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">dep_node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linearize evaluation rooted in the given node into the result.</span>

<span class="sd">        If keep if set to True, the evaluation of the given node will not be</span>
<span class="sd">        appended to the result list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">generated</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">def_</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">node</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">def_</span>

    <span class="k">def</span> <span class="nf">_form_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of an evaluation node.</span>

<span class="sd">        The dependencies will also be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a product evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
        <span class="n">term</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">eval_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="p">),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_prod_def_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the term in the final definition of a product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">coeff</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">interm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">interm</span><span class="p">):</span>
                    <span class="c1"># Inline trivial reference to an input.</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span> <span class="o">**</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_sum_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a sum evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">exts_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span>

        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">((),</span> <span class="n">term</span><span class="p">,</span> <span class="p">()))</span>
                <span class="c1"># No dependency for pure scalars.</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Higher power not possible in sum.</span>

            <span class="c1"># Sum term are guaranteed to be formed from references to products,</span>
            <span class="c1"># never directly written in terms of input.</span>
            <span class="n">term_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">term_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">term_node</span><span class="p">):</span>
                <span class="c1"># Inline intermediates only used here and simple input</span>
                <span class="c1"># references.</span>

                <span class="n">eval_</span> <span class="o">=</span> <span class="n">term_node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
                <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">factors</span><span class="p">,</span> <span class="n">term_coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">exts_dict</span>
                <span class="p">)</span>

                <span class="c1"># Switch back to evaluation node for using the facilities for</span>
                <span class="c1"># product nodes.</span>
                <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                    <span class="n">term_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">term_coeff</span><span class="p">,</span> <span class="n">factors</span>
                <span class="p">)</span>
                <span class="n">new_term</span><span class="p">,</span> <span class="n">term_deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">tmp_node</span><span class="p">)</span>

                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_term</span><span class="p">)</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term_deps</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span>
                    <span class="p">(),</span> <span class="n">term</span><span class="p">,</span> <span class="p">()</span>
                <span class="p">))</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span>
        <span class="p">),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_inline_sum_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">res</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inline the summation terms from single-reference terms.</span>

<span class="sd">        This function mutates the given result list rather than returning the</span>
<span class="sd">        result to avoid repeated list creation in recursive calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sum_term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">if_inline</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_inline</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
                    <span class="p">}</span>

                <span class="n">proced_sum_terms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sum_term</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">proced_sum_terms</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_is_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a product node is just a trivial reference to an input.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">_Grain</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Finalize the linearization result.</span>

<span class="sd">        Things will be cast to drudge tensor definitions, with intermediates</span>
<span class="sd">        holding names formed from the format given by user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># For normal substitution of bases.</span>
        <span class="n">repls</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># For removed shallow intermediates</span>

        <span class="k">def</span> <span class="nf">proc_amp</span><span class="p">(</span><span class="n">amp</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Process the amplitude by making the found substitutions.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">repls</span><span class="p">):</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">amp</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span><span class="p">:</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="n">if_scalar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="n">comput</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">proc_amp</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">sums</span>
                <span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">terms</span>
            <span class="p">]</span>

            <span class="c1"># No internal intermediates should be leaked.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">free_vars</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Remove shallow intermediates.  The saving might be too</span>
                    <span class="c1"># modest to justify the additional memory consumption.</span>
                    <span class="c1">#</span>
                    <span class="c1"># TODO: Move it earlier to a better place.</span>
                    <span class="n">repl_lhs</span> <span class="o">=</span> <span class="n">base</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">_WILD_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
                    <span class="p">)]</span>
                    <span class="n">repl_rhs</span> <span class="o">=</span> <span class="n">proc_amp</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">_WILD_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)}</span>
                    <span class="p">))</span>
                    <span class="n">repls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">repl_lhs</span><span class="p">,</span> <span class="n">repl_rhs</span><span class="p">))</span>
                    <span class="k">continue</span>  <span class="c1"># No new intermediate added.</span>

                <span class="n">final_base</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Symbol</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">IndexedBase</span>
                <span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interm_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">next_idx</span><span class="p">))</span>
                <span class="n">next_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">substs</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_base</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TensorDef</span><span class="p">(</span>
                <span class="n">final_base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">create_tensor</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">())</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="c1">#</span>
    <span class="c1"># Internal support utilities.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_get_next_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the symbol for the next internal intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillInternalIntermediate</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_write_in_orig_ranges</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the summations in terms of undecorated bare ranges.</span>

<span class="sd">        The labels in the ranges are assumed to be decorated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sums</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_canon_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Term</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Form a canonical label for a list of terms.</span>

<span class="sd">        The new summation list is prepended to the summation list of all terms.</span>
<span class="sd">        The coefficient ahead of the canonical form is returned before the</span>
<span class="sd">        canonical form.  And the permuted new summation list is also returned</span>
<span class="sd">        after the canonical form.  Note that this list contains the original</span>
<span class="sd">        dummies given in the new summation list, while the terms has reset new</span>
<span class="sd">        dummies.</span>

<span class="sd">        Note that the ranges in the new summation list are assumed to be</span>
<span class="sd">        decorated with labels earlier than _SUMMED.  In the result, they are</span>
<span class="sd">        still in decorated forms and are guaranteed to be permuted in the same</span>
<span class="sd">        way for all given terms.  The summations from the terms will be</span>
<span class="sd">        internally decorated but written in bare ranges in the final result.</span>

<span class="sd">        Note that this is definitely a poor man&#39;s version of canonicalization of</span>
<span class="sd">        multi-term tensor definitions with external indices.  A lot of cases</span>
<span class="sd">        cannot be handled well.  Hopefully it can be replaced with a systematic</span>
<span class="sd">        treatment some day in the future.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_dumms</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_sums</span><span class="p">}</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">candidates</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">term</span><span class="p">,</span> <span class="n">canon_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">)</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

            <span class="n">candidates</span><span class="p">[</span>
                <span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
            <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">canon_sums</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="c1"># Poor man&#39;s canonicalization of external indices.</span>
        <span class="c1">#</span>
        <span class="c1"># This algorithm is not guaranteed to work.  Here we just choose an</span>
        <span class="c1"># ordering of the external indices that is as safe as possible.  But</span>
        <span class="c1"># certainly it is not guaranteed to work for all cases.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Fix it!</span>

        <span class="n">chosen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">new_dumms</span><span class="p">),</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_key</span>
        <span class="p">))</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">chosen</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">canon_new_sums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Internal deficiency: &#39;</span>
                <span class="s1">&#39;summation intermediate may not be fully canonicalized&#39;</span>
            <span class="p">)</span>
        <span class="c1"># This could also fail when the chosen term has symmetry among the new</span>
        <span class="c1"># summations not present in any other term.  This can be hard to check.</span>

        <span class="n">canon_new_sum</span> <span class="o">=</span> <span class="n">canon_new_sums</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">preferred</span> <span class="o">=</span> <span class="n">prod_</span><span class="p">(</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">[</span><span class="n">chosen</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="n">canon_coeff</span> <span class="o">=</span> <span class="n">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">canon_term</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">canon_new_sum</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># TODO: Add support for complex conjugation.</span>
            <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">canon_coeff</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">canon_coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">res_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">canon_new_sum</span>

    <span class="k">def</span> <span class="nf">_canon_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonicalize a single term.</span>

<span class="sd">        Internal method for _canon_terms, not supposed to be directly called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_EXT</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_sums</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">fix_new</span> <span class="k">else</span> <span class="n">new_sums</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_SUMMED</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="p">)</span>
        <span class="p">)),</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">canoned</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">canon_sums</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">sums</span>
        <span class="n">canon_orig_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">canon_sums</span><span class="p">)</span>

        <span class="n">dumm_reset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="n">canon_orig_sums</span><span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="n">dumms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span>
        <span class="p">)</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">term_new_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">term_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i_new</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dumm_reset</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">canon_sums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">_SUMMED</span><span class="p">:</span>
                <span class="c1"># Existing summations.</span>
                <span class="n">term_sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fix_new</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_sums</span><span class="p">[</span><span class="n">i_new</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">range_</span> <span class="o">=</span> <span class="n">new_sums</span><span class="p">[</span><span class="n">i_new</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">range_</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">canon_new_sums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_</span><span class="p">))</span>
                <span class="n">term_new_sums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_</span><span class="p">))</span>
                <span class="n">i_new</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">dumm_reset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">term_new_sums</span><span class="p">,</span> <span class="n">term_sums</span>
        <span class="p">))),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">canon_new_sums</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_interm_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_IntermRef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parse an expression that is possibly an intermediate reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="n">base</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">power</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="n">ref</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>
                <span class="k">assert</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_IntermRef</span><span class="p">(</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interm_ref</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the content of an intermediate reference.</span>

<span class="sd">        This function might be removed after the new factorization algorithm is</span>
<span class="sd">        implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">interm_ref</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_sum</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">i</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_power</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_index_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the sum node&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">term_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term_def</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_index_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the evaluation node.&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">),</span> <span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">excl</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_raise_power</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Term</span><span class="p">],</span> <span class="n">exp</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Raise the sum of the given terms to the given power.&quot;&quot;&quot;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[Term]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">exp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: Make the multiplication more efficient.</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">mul_term</span><span class="p">(</span>
                    <span class="n">j</span><span class="p">,</span> <span class="n">dumms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span>
                    <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">i</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">|</span> <span class="n">j</span><span class="o">.</span><span class="n">free_vars</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">terms</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">curr</span>

    <span class="c1">#</span>
    <span class="c1"># General optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_form_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grain</span><span class="p">:</span> <span class="n">_Grain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation node from a tensor definition.</span>

<span class="sd">        This is the entry point for optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We assume it is fully simplified and expanded by grist preparation.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">terms</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span>
            <span class="n">grain</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">terms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given node.</span>

<span class="sd">        The evaluation methods will be filled with, possibly multiple, method of</span>
<span class="sd">        evaluations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sum</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_prod</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_interm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">_EvalNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Form a product intermediate.</span>

<span class="sd">        The factors are assumed to be all non-trivial factors needing</span>
<span class="sd">        processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_EXT</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sums</span><span class="p">),</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="p">())</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span>
            <span class="n">decored_exts</span><span class="p">,</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">key_term</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">key_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
            <span class="n">key_sums</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]</span>

            <span class="c1"># The external symbols will automatically be considered in</span>
            <span class="c1"># get_amp_factors since they are in the summation list right now.</span>
            <span class="n">key_factors</span><span class="p">,</span> <span class="n">key_coeff</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">)</span>
            <span class="n">interm</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">key_exts</span><span class="p">,</span> <span class="n">key_sums</span><span class="p">,</span> <span class="n">key_coeff</span><span class="p">,</span> <span class="n">key_factors</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">interm</span>

        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">_index</span><span class="p">(</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">canon_exts</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_form_sum_interm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Term</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">_EvalNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Form a sum intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_EXT</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">canon_terms</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">canon_terms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">canon_terms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">canon_terms</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">node_exts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">node_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">canon_terms</span><span class="p">:</span>
                <span class="n">term_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">node_exts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node_exts</span> <span class="o">=</span> <span class="n">term_exts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">node_exts</span> <span class="o">==</span> <span class="n">term_exts</span>
                <span class="n">node_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]))</span>
                <span class="k">continue</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">node_exts</span><span class="p">,</span> <span class="n">node_terms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">_index</span><span class="p">(</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">canon_exts</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_form_sum_from_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Term</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a summation node for given the terms.</span>

<span class="sd">        No processing is done in this method.  It just forms the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plain_scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plain_scalars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interm_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
                <span class="n">sum_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interm_ref</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plain_scalars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sum_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_</span><span class="p">(</span><span class="n">plain_scalars</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Sum optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the summation node.&quot;&quot;&quot;</span>

        <span class="c1"># We first optimize the common terms.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">scalars</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_organize_sum_terms</span><span class="p">(</span><span class="n">sum_node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">SUM</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_terms</span><span class="p">,</span> <span class="n">old_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factorize_sum</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="n">terms</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">COMMON</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_common_symmtrization</span><span class="p">(</span><span class="n">old_terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="n">scalars</span> <span class="o">+</span> <span class="n">old_terms</span> <span class="o">+</span> <span class="n">new_terms</span>
        <span class="n">sum_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Sum</span><span class="p">(</span>
            <span class="n">sum_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">res_terms</span>
        <span class="p">)]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_organize_sum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">_OrgTerms</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Organize terms in the summation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Intermediate base -&gt; (indices -&gt; coefficient)</span>
        <span class="c1">#</span>
        <span class="c1"># This first gather terms with the same reference to deeper nodes.</span>
        <span class="n">org_terms</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_ZERO</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">plain_scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plain_scalars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">org_terms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">][</span><span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span>
            <span class="k">continue</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">org_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                    <span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">plain_scalars</span><span class="p">,</span> <span class="n">res_terms</span><span class="p">,</span> <span class="n">org_terms</span>

    <span class="k">def</span> <span class="nf">_optimize_common_symmtrization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize common symmetrization in the intermediate references.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exts_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">scalars</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">org_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_organize_sum_terms</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Indices, coeffs tuple -&gt; base, coeff</span>
        <span class="n">pull_info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">org_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Here we use name for sorting directly, since here we cannot</span>
                <span class="c1"># have general expressions hence no need to use the expensive</span>
                <span class="c1"># sort_key.</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># Indices/coefficient pairs.</span>
                <span class="n">raw</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">leading_coeff</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">pull_info</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">/</span> <span class="n">leading_coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">raw</span>
                <span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="p">))</span>

        <span class="c1"># Now we treat the terms from which new intermediates might be pulled</span>
        <span class="c1"># out.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pull_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># No need to form a new intermediate.</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pivot_ref</span> <span class="o">=</span> <span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need to form an intermediate here.</span>
                <span class="n">interm_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">exts_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivot</span>
                <span class="p">)</span>
                <span class="n">interm_terms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">term</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">pivot</span><span class="p">))</span>
                <span class="p">]</span>
                <span class="n">pivot_ref</span><span class="p">,</span> <span class="n">interm_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span>
                    <span class="n">interm_exts</span><span class="p">,</span> <span class="n">interm_terms</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">interm_node</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pivot_ref</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res_terms</span>

    <span class="k">def</span> <span class="nf">_factorize_sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Factorize the summations greedily.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">if_keep</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">]</span>
        <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">collectibles</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span> <span class="n">term_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_collectibles</span><span class="p">(</span>
            <span class="n">terms</span><span class="p">,</span> <span class="n">exts</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">ranges</span><span class="p">,</span> <span class="n">biclique</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_collectible</span><span class="p">(</span>
                <span class="n">collectibles</span><span class="p">,</span> <span class="n">base_infos</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ranges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_factored_term</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">biclique</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clean_up_collected</span><span class="p">(</span>
                <span class="n">biclique</span><span class="p">,</span> <span class="n">collectibles</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span> <span class="n">term_base</span><span class="p">,</span> <span class="n">if_keep</span>
            <span class="p">)</span>

            <span class="k">continue</span>
        <span class="c1"># End Main loop.</span>

        <span class="n">old_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">if_keep</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_terms</span><span class="p">,</span> <span class="n">old_terms</span>

    <span class="k">def</span> <span class="nf">_find_collectibles</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Collectibles</span><span class="p">,</span> <span class="n">_BaseInfoDict</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Find all collectibles for the given terms..</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coll</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">_CollectGraph</span><span class="p">)</span>  <span class="c1"># type: _Collectibles</span>
        <span class="n">base_infos</span> <span class="o">=</span> <span class="n">_BaseInfoDict</span><span class="p">()</span>
        <span class="n">term_base</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term_idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">term_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">eval_idx</span><span class="p">,</span> <span class="n">eval_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_find_collectibles_eval</span><span class="p">(</span>
                    <span class="n">term_idx</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">eval_idx</span><span class="p">,</span> <span class="n">eval_</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">coll</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">base_infos</span><span class="o">.</span><span class="n">add_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">total_cost</span><span class="p">)</span>
            <span class="n">term_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coll</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span> <span class="n">term_base</span>

    <span class="k">def</span> <span class="nf">_find_collectibles_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">term_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">_IntermRef</span><span class="p">,</span> <span class="n">eval_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span>
            <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">_Collectibles</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the collectibles for a particular evaluations of a product.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">eval_cost</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">total_cost</span>
        <span class="n">opt_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">total_cost</span>

        <span class="n">eval_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">eval_term</span> <span class="o">=</span> <span class="n">eval_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">}</span>

        <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">eval_term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span>
        <span class="p">)</span>
        <span class="n">coeff</span> <span class="o">*=</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span>
        <span class="k">assert</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sums</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span>
            <span class="n">eval_term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">))</span>

        <span class="n">excl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">ext_symbs</span>
        <span class="n">symms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Information about the (two) factors,</span>
        <span class="c1">#</span>
        <span class="c1"># expr: The original expression for the factor.</span>
        <span class="c1"># exts: Indices of the involved externals.</span>
        <span class="c1"># canon_content: The canonicalized content for the factor.</span>
        <span class="n">factor_infos</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">types</span><span class="o">.</span><span class="n">SimpleNamespace</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factors</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">f_i</span> <span class="ow">in</span> <span class="n">factor_infos</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">f_i</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">symbs</span> <span class="o">=</span> <span class="n">f_i</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="n">f_i</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">symbs</span>
            <span class="p">)</span>  <span class="c1"># Index only.</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbs</span>

            <span class="c1"># In order to really make sure, the content will be re-canonicalized</span>
            <span class="c1"># based on the current ambient.</span>
            <span class="n">canon_content</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="n">symms</span><span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">excl</span> <span class="o">|</span> <span class="n">content</span><span class="o">.</span><span class="n">free_vars</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">canon_coeff</span> <span class="o">=</span> <span class="n">canon_content</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span>
            <span class="p">)</span>
            <span class="n">f_i</span><span class="o">.</span><span class="n">canon_content</span> <span class="o">=</span> <span class="n">canon_content</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">canon_coeff</span><span class="p">,</span> <span class="n">skip_vecs</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">canon_coeff</span>

            <span class="k">continue</span>

        <span class="n">factor_infos</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>

        <span class="n">l_exts</span><span class="p">,</span> <span class="n">r_exts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">exts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factor_infos</span>
        <span class="p">]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">_Ranges</span><span class="p">(</span><span class="n">exts</span><span class="o">=</span><span class="p">(</span><span class="n">l_exts</span><span class="p">,</span> <span class="n">r_exts</span><span class="p">),</span> <span class="n">sums</span><span class="o">=</span><span class="n">sums</span><span class="p">)</span>

        <span class="c1"># When the left and right externals differ, the two factors have</span>
        <span class="c1"># determined colour, or we need to add one of them for each colour</span>
        <span class="c1"># assignment.</span>
        <span class="n">lr_factor_idxes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">l_exts</span> <span class="o">==</span> <span class="n">r_exts</span><span class="p">:</span>
            <span class="n">lr_factor_idxes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">lr_factors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">canon_content</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lr_factor_idxes</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lr_factors</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">ranges</span><span class="p">]</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">term</span><span class="o">=</span><span class="n">term_idx</span><span class="p">,</span> <span class="n">eval_</span><span class="o">=</span><span class="n">eval_idx</span><span class="p">,</span>
                <span class="n">base</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">opt_cost</span><span class="o">=</span><span class="n">opt_cost</span><span class="p">,</span>
                <span class="n">eval_cost</span><span class="o">=</span><span class="n">eval_cost</span>
            <span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_choose_collectible</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">collectibles</span><span class="p">:</span> <span class="n">_Collectibles</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">:</span> <span class="n">_BaseInfoDict</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Choose the most profitable collectible factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rush_local</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">RUSH_LOCAL</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">rush_global</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">RUSH_GLOBAL</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">inaccurate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">INACCURATE</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_ranges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">collectibles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">curr_opt_saving</span><span class="p">,</span> <span class="n">curr_opt_biclique</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">get_opt_biclique</span><span class="p">(</span>
                <span class="n">ranges</span><span class="p">,</span> <span class="n">base_infos</span><span class="p">,</span>
                <span class="n">greedy_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span><span class="p">,</span>
                <span class="n">drop_cutoff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span><span class="p">,</span>
                <span class="n">rush_local</span><span class="o">=</span><span class="n">rush_local</span><span class="p">,</span> <span class="n">rush_global</span><span class="o">=</span><span class="n">rush_global</span><span class="p">,</span>
                <span class="n">inaccurate</span><span class="o">=</span><span class="n">inaccurate</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">curr_opt_saving</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr_opt_saving</span> <span class="o">&gt;</span> <span class="n">opt_saving</span><span class="p">:</span>
                <span class="n">opt_saving</span> <span class="o">=</span> <span class="n">curr_opt_saving</span>
                <span class="n">opt_ranges</span> <span class="o">=</span> <span class="n">ranges</span>
                <span class="n">opt_biclique</span> <span class="o">=</span> <span class="n">curr_opt_biclique</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">opt_ranges</span><span class="p">,</span> <span class="n">opt_biclique</span>

    <span class="k">def</span> <span class="nf">_form_factored_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">,</span> <span class="n">biclique</span><span class="p">:</span> <span class="n">_Biclique</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form the factored term for the given factorization.&quot;&quot;&quot;</span>

        <span class="c1"># Form and optimize the two new summation nodes.</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">biclique</span><span class="o">.</span><span class="n">leading_coeff</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">exts_i</span><span class="p">,</span> <span class="n">nodes_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">biclique</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
            <span class="n">scaled_terms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">nodes_i</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">exts</span> <span class="o">=</span> <span class="n">exts_i</span> <span class="o">+</span> <span class="n">ranges</span><span class="o">.</span><span class="n">sums</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaled_terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">scaled_terms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scaled_term</span> <span class="o">=</span> <span class="n">scaled_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span>
                    <span class="n">exts</span><span class="p">,</span> <span class="n">scaled_term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="p">[</span><span class="n">scaled_term</span><span class="o">.</span><span class="n">amp</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">eval_node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Form the contraction node for the two new summation nodes.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">exts</span><span class="p">)),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">))</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span>
            <span class="n">exts</span><span class="p">,</span> <span class="n">ranges</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">factors</span>
        <span class="p">)</span>

        <span class="c1"># Make phony optimization of the intermediate.</span>
        <span class="n">eval_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">eval_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_node</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_clean_up_collected</span><span class="p">(</span>
            <span class="n">biclique</span><span class="p">:</span> <span class="n">_Biclique</span><span class="p">,</span> <span class="n">collectibles</span><span class="p">:</span> <span class="n">_Collectibles</span><span class="p">,</span>
            <span class="n">base_infos</span><span class="p">:</span> <span class="n">_BaseInfoDict</span><span class="p">,</span> <span class="n">term_base</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span>
            <span class="n">if_keep</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up the collectibles and the terms after factorization.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">if_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">if_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>

        <span class="n">updated_bases</span> <span class="o">=</span> <span class="n">base_infos</span><span class="o">.</span><span class="n">remove_terms</span><span class="p">(</span><span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">term_base</span><span class="p">)</span>

        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">graph</span> <span class="ow">in</span> <span class="n">collectibles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">if_empty</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">remove_terms</span><span class="p">(</span>
                <span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">term_base</span><span class="p">,</span> <span class="n">updated_bases</span><span class="p">,</span> <span class="n">base_infos</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_empty</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">collectibles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">continue</span>

    <span class="c1">#</span>
    <span class="c1"># Product optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_factors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_factors</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod_node</span><span class="p">)</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">_get_prod_final_cost</span><span class="p">(</span>
                <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span>
                <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">&amp;</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">PROD_MASK</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span>
        <span class="n">optimal_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts_gen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_factor_parts</span><span class="p">(</span>
                <span class="n">prod_node</span>
        <span class="p">):</span>
            <span class="k">def</span> <span class="nf">need_break</span><span class="p">():</span>
                <span class="sd">&quot;&quot;&quot;If we need to break the current loop.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">GREEDY</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">BEST</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">SEARCHED</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">final_cost</span> <span class="o">&gt;</span> <span class="n">optimal_cost</span>
                <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">optimal_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">need_break</span><span class="p">():</span>
                <span class="k">break</span>
            <span class="c1"># Else</span>

            <span class="k">for</span> <span class="n">parts</span> <span class="ow">in</span> <span class="n">parts_gen</span><span class="p">:</span>

                <span class="c1"># Recurse, two parts.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">total_cost</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">final_cost</span>
                    <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                    <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                <span class="p">)</span>

                <span class="n">if_new_optimal</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">optimal_cost</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">optimal_cost</span> <span class="o">&gt;</span> <span class="n">total_cost</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">if_new_optimal</span><span class="p">:</span>
                    <span class="n">optimal_cost</span> <span class="o">=</span> <span class="n">total_cost</span>
                    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">BEST</span><span class="p">:</span>
                        <span class="n">evals</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="c1"># New optimal is always added.</span>
                <span class="k">def</span> <span class="nf">need_add_eval</span><span class="p">():</span>
                    <span class="sd">&quot;&quot;&quot;If the current evaluation need to be added.&quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="n">Strategy</span><span class="o">.</span><span class="n">BEST</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">total_cost</span> <span class="o">==</span> <span class="n">optimal_cost</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">if_new_optimal</span> <span class="ow">or</span> <span class="n">need_add_eval</span><span class="p">():</span>
                    <span class="n">new_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_eval</span><span class="p">(</span>
                        <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts</span>
                    <span class="p">)</span>
                    <span class="n">new_eval</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">total_cost</span>
                    <span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_eval</span><span class="p">)</span>

                <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">optimal_cost</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_gen_factor_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all the partitions of factors in a product node.&quot;&quot;&quot;</span>

        <span class="c1"># Compute things invariant to different summations for performance.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">exts_total_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

        <span class="n">factor_atoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span>
        <span class="p">]</span>
        <span class="n">sum_involve</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factor_atoms</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span>
        <span class="p">]</span>

        <span class="n">dumm2index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Indices of external and internal dummies involved by each factors.</span>
        <span class="n">factor_infos</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dumm2index</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">factor_atoms</span>
        <span class="p">]</span>

        <span class="c1"># Actual generation.</span>
        <span class="k">for</span> <span class="n">broken_size</span><span class="p">,</span> <span class="n">kept</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_kept_sums</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="n">broken_sums</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">kept</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">final_cost</span> <span class="o">=</span> <span class="n">_get_prod_final_cost</span><span class="p">(</span>
                <span class="n">exts_total_size</span><span class="p">,</span> <span class="n">broken_size</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_parts_w_kept_sums</span><span class="p">(</span>
                <span class="n">prod_node</span><span class="p">,</span> <span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span>
            <span class="p">)</span>
            <span class="k">continue</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_kept_sums</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate kept summations in increasing size of broken summations.</span>

<span class="sd">        The results will be given as boolean array giving if the corresponding</span>
<span class="sd">        entry is to be kept.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">]</span>
        <span class="n">n_sums</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="n">kept</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Wrap the kept summation with its size.&quot;&quot;&quot;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">prod_</span><span class="p">(</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">kept</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Tuple4Cmp</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">kept</span><span class="p">))</span>

        <span class="n">init</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_sums</span>  <span class="c1"># Everything is kept.</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_size</span><span class="p">(</span><span class="n">init</span><span class="p">)]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">curr</span>
            <span class="n">curr_kept</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sums</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">curr_kept</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">new_kept</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_kept</span><span class="p">)</span>
                    <span class="n">new_kept</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">get_size</span><span class="p">(</span><span class="n">new_kept</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">continue</span>

    <span class="k">def</span> <span class="nf">_gen_parts_w_kept_sums</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all partitions with given summations kept.</span>

<span class="sd">        First we the factors are divided into chunks indivisible according to</span>
<span class="sd">        the kept summations.  Then their bipartitions which really break the</span>
<span class="sd">        broken sums are generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dsf</span> <span class="o">=</span> <span class="n">DSF</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">dsf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="n">dsf</span><span class="o">.</span><span class="n">sets</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_parts_from_chunks</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_form_part</span><span class="p">(</span><span class="n">prod_node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">part</span>
            <span class="p">)</span>

        <span class="k">return</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_parts_from_chunks</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate factor partitions from chunks.</span>

<span class="sd">        Here special care is taken to respect the broken summations in the</span>
<span class="sd">        result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_chunks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">chunks_part</span> <span class="ow">in</span> <span class="n">multiset_partitions</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">factors_part</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span>
                <span class="n">factor_i</span> <span class="k">for</span> <span class="n">chunk_i</span> <span class="ow">in</span> <span class="n">chunk_part_i</span>
                <span class="k">for</span> <span class="n">factor_i</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">[</span><span class="n">chunk_i</span><span class="p">]</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">chunk_part_i</span> <span class="ow">in</span> <span class="n">chunks_part</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kept</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Now we have broken sum, it need to be involved by both parts.</span>
                <span class="n">involve</span> <span class="o">=</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">involve</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">factors_part</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">factors_part</span>

    <span class="k">def</span> <span class="nf">_form_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">,</span> <span class="n">factor_idxes</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a partition for the given factors.&quot;&quot;&quot;</span>

        <span class="n">involved_exts</span><span class="p">,</span> <span class="n">involved_sums</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factor_idxes</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factor_idxes</span><span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">involved_exts</span>
        <span class="p">]</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">factor_idxes</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">factor_idxes</span><span class="p">:</span>
                <span class="n">sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">ref</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Part</span><span class="p">(</span><span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_form_prod_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Part</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation for a product node.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">curr_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">curr_ref</span><span class="o">.</span><span class="n">coeff</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_ref</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_Prod</span><span class="p">(</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span>
            <span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span>
        <span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Utility constants.</span>
<span class="c1">#</span>


<span class="n">_ZERO</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_NEG_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">_EXT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SUMMED_EXT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_SUMMED</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">_SUBSTED_EVAL_BASE</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillSubstitutedEvalBase&#39;</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Utility static functions.</span>
<span class="c1">#</span>

<span class="k">class</span> <span class="nc">_SymbFactory</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A small symbol factory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillInternalSymbol</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="n">_SYMB_FACTORY</span> <span class="o">=</span> <span class="n">_SymbFactory</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_WildFactory</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A small wild symbol factory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;gristmillInternalWild</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="n">_WILD_FACTORY</span> <span class="o">=</span> <span class="n">_WildFactory</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the canonical coefficient from a list of coefficients.&quot;&quot;&quot;</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="n">v</span> <span class="o">*</span> <span class="n">_SYMB_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">together</span><span class="p">()</span>

    <span class="n">frac</span> <span class="o">=</span> <span class="n">_UNITY</span>  <span class="c1"># The fractional part.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Pow</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">continue</span>
        <span class="n">expr</span> <span class="o">/=</span> <span class="n">frac</span>

    <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primitive</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span>
        <span class="n">_SYMB_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="c1"># Initial coefficient without phase.</span>
    <span class="n">init_coeff</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">frac</span>

    <span class="c1"># The primitive computation does not take phase into account.</span>
    <span class="n">negs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">poses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">/=</span> <span class="n">init_coeff</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">negs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="n">neg_sig</span><span class="p">,</span> <span class="n">pos_sig</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">default_sort_key</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">negs</span><span class="p">,</span> <span class="n">poses</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">neg_sig</span> <span class="o">&gt;</span> <span class="n">pos_sig</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_NEG_UNITY</span>
    <span class="k">elif</span> <span class="n">pos_sig</span> <span class="o">&gt;</span> <span class="n">neg_sig</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_UNITY</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">preferred_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_NEG_UNITY</span> <span class="k">if</span> <span class="n">preferred</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">preferred</span><span class="o">.</span><span class="n">is_negative</span>
            <span class="k">else</span> <span class="n">_UNITY</span>
        <span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">preferred_phase</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Index the given base with indices.</span>

<span class="sd">    When strip is set to true, the indices are assumed to be symbol/range pairs</span>
<span class="sd">    list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">base</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="n">base</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>


<span class="c1">#</span>
<span class="c1"># Optimization result verification</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="verify_eval_seq"><a class="viewcode-back" href="../../api.html#gristmill.verify_eval_seq">[docs]</a><span class="k">def</span> <span class="nf">verify_eval_seq</span><span class="p">(</span>
        <span class="n">eval_seq</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">res</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span>
        <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Verify the correctness of an evaluation sequence for the results.</span>

<span class="sd">    The last entries of the evaluation sequence should be in one-to-one</span>
<span class="sd">    correspondence with the original form in the ``res`` argument.  This</span>
<span class="sd">    function returns ``True`` when the evaluation sequence is symbolically</span>
<span class="sd">    equivalent to the given raw form.  When a difference is found,</span>
<span class="sd">    ``ValueError`` will be raised with relevant information.</span>

<span class="sd">    Note that this function can be very slow for large evaluations.  But it is</span>
<span class="sd">    advised to be used for all optimizations in mission-critical tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    eval_seq</span>
<span class="sd">        The evaluation sequence to verify, can be the output from</span>
<span class="sd">        :py:func:`optimize` directly.</span>

<span class="sd">    res</span>
<span class="sd">        The original result to test the evaluation sequence against.  It can be</span>
<span class="sd">        the input to :py:func:`optimize` directly.</span>

<span class="sd">    simplify</span>
<span class="sd">        If simplification is going to be performed after each step of the</span>
<span class="sd">        back-substitution.  It is advised for larger complex evaluations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">n_interms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_res</span>

    <span class="n">substed_eval_seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">defs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eval_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eval_seq</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">base</span>
        <span class="n">free_vars</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="n">curr_defs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">defs_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">free_vars</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">defs_dict</span>
        <span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">}</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">subst_all</span><span class="p">(</span><span class="n">curr_defs</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">new_def</span> <span class="o">=</span> <span class="n">TensorDef</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">substed_eval_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_def</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n_interms</span><span class="p">:</span>
            <span class="n">defs_dict</span><span class="p">[</span>
                <span class="n">base</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">new_def</span>

        <span class="k">continue</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">substed_eval_seq</span><span class="p">[</span><span class="o">-</span><span class="n">n_res</span><span class="p">:],</span> <span class="n">res</span><span class="p">):</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">ref</span><span class="o">.</span><span class="n">lhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal left-hand sides&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">lhs</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">rhs</span> <span class="o">-</span> <span class="n">ref</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal definition for &#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">j</span>
            <span class="p">)</span>
        <span class="k">continue</span>

    <span class="k">return</span> <span class="kc">True</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jinmo Zhao and Gustavo E Scuseria.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>