
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>gristmill.optimize &#8212; gristmill 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gristmill.optimize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Optimizer for the contraction computations.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">drudge</span> <span class="k">import</span> <span class="n">TensorDef</span><span class="p">,</span> <span class="n">prod_</span><span class="p">,</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Range</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Integer</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">primitive</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="k">import</span> <span class="n">multiset_partitions</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">get_cost_key</span><span class="p">,</span> <span class="n">add_costs</span><span class="p">,</span> <span class="n">get_total_size</span><span class="p">,</span> <span class="n">DSF</span>


<span class="c1">#</span>
<span class="c1">#  The public driver</span>
<span class="c1">#  -----------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../../api.html#gristmill.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span>
        <span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">substs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="o">=</span><span class="s1">&#39;tau^</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Optimize the valuation of the given tensor contractions.</span>

<span class="sd">    This function will transform the given computations, given as tensor</span>
<span class="sd">    definitions, into another list computations mathematically equivalent to the</span>
<span class="sd">    given computation while requiring less floating-point operations (FLOPs).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    computs</span>
<span class="sd">        The computations, can be given as an iterable of tensor definitions.</span>

<span class="sd">    substs</span>
<span class="sd">        A dictionary for making substitutions inside the sizes of ranges.  All</span>
<span class="sd">        the ranges need to have size in at most one undetermined variable after</span>
<span class="sd">        the substitution so that they can be totally ordered.</span>

<span class="sd">    interm_fmt</span>
<span class="sd">        The format for the names of the intermediates.</span>

<span class="sd">    simplify</span>
<span class="sd">        If the input is going to be simplified before processing.  It can be</span>
<span class="sd">        disabled when the input is already simplified.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">substs</span>

    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="n">computs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">computs</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">computs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">computs</span><span class="p">)</span>

    <span class="n">opt</span> <span class="o">=</span> <span class="n">_Optimizer</span><span class="p">(</span>
        <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="o">=</span><span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="o">=</span><span class="n">interm_fmt</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span></div>


<span class="c1">#</span>
<span class="c1"># The internal optimization engine</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>
<span class="c1"># Internal small type definitions</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="c1">#</span>
<span class="c1"># Small type definitions.</span>
<span class="c1">#</span>


<span class="n">_Grain</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Grain&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;base&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;terms&#39;</span>
<span class="p">])</span>

<span class="c1">#</span>
<span class="c1"># The information on collecting a collectible.</span>
<span class="c1">#</span>
<span class="c1"># Interpretation, after the substitutions given in ``substs``, the ``lr`` factor</span>
<span class="c1"># in the evaluation ``eval_`` will be turned into ``coeff`` times the actual</span>
<span class="c1"># collectible.</span>
<span class="c1">#</span>

<span class="n">_CollectInfo</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_CollectInfo&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;eval_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;coeff&#39;</span><span class="p">,</span>
    <span class="s1">&#39;substs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ranges&#39;</span>
<span class="p">])</span>

<span class="n">_Ranges</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Ranges&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;involved_exts&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sums&#39;</span><span class="p">,</span>
    <span class="s1">&#39;other_exts&#39;</span>
<span class="p">])</span>

<span class="n">_Collectible</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Term</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

<span class="n">_CollectInfos</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_CollectInfo</span><span class="p">]</span>

<span class="n">_Collectibles</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">_Collectible</span><span class="p">,</span> <span class="n">_CollectInfos</span><span class="p">]</span>

<span class="n">_Part</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;_Part&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="s1">&#39;ref&#39;</span><span class="p">,</span>
    <span class="s1">&#39;node&#39;</span>
<span class="p">])</span>


<span class="c1">#</span>
<span class="c1"># Core evaluation DAG nodes.</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_EvalNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A node in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[_EvalNode]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_substs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get substitutions and symbols requiring exclusion before indexing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">dumm</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">substs</span><span class="p">[</span><span class="n">dumm</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">excl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dumm</span><span class="p">)</span>
            <span class="n">excl</span> <span class="o">|=</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span>


<span class="k">class</span> <span class="nc">_Sum</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sum nodes in the evaluation graph.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span> <span class="o">=</span> <span class="n">sum_terms</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Sum(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, sum_terms=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_Prod</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product nodes in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sums</span> <span class="o">=</span> <span class="n">sums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Prod(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, coeff=</span><span class="si">{}</span><span class="s1">, factors=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
        <span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Core optimizer class</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_Optimizer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Optimizer for tensor contraction computations.</span>

<span class="sd">    This internal optimizer can only be used once for one set of input.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the optimizer.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_grist</span><span class="p">(</span><span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interm_fmt</span> <span class="o">=</span> <span class="n">interm_fmt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given computations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

        <span class="n">res_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize</span><span class="p">(</span><span class="n">res_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

    <span class="c1">#</span>
    <span class="c1"># User input pre-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_prepare_grist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare tensor definitions for optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># The only variable for range sizes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Substituted range to original range.</span>

        <span class="c1"># Form pre-grist, basically everything is set except the dummy variables</span>
        <span class="c1"># for external indices and summations.</span>
        <span class="n">pre_grist</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_form_pre_grist</span><span class="p">(</span><span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span> <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span>
            <span class="p">]</span>

        <span class="c1"># Finalize grist formation by resetting the dummies.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_reset_dumms</span><span class="p">(</span><span class="n">grain</span><span class="p">)</span> <span class="k">for</span> <span class="n">grain</span> <span class="ow">in</span> <span class="n">pre_grist</span><span class="p">]</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_form_pre_grist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form grist from a given computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_drudge</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">drudge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="n">curr_drudge</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">curr_drudge</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid computations to optimize, containing two drudges&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">curr_drudge</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Externals processing.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>
        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">}</span>

        <span class="c1"># Terms processing.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs_terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid term to optimize&#39;</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="s1">&#39;expecting scalar&#39;</span>
                <span class="p">)</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span>

            <span class="c1"># Add the true free symbols to the exclusion set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|=</span> <span class="n">term</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">-</span> <span class="n">ext_symbs</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()))</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">comput</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_proc_sums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a summation list.</span>

<span class="sd">        The ranges will be replaced with substitution sizes.  Relevant members</span>
<span class="sd">        of the object will also be updated.  User error will also be reported.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">range_</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">range_</span><span class="o">.</span><span class="n">bounded</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid range for optimization&#39;</span><span class="p">,</span> <span class="n">range_</span><span class="p">,</span>
                    <span class="s1">&#39;expecting explicit bound&#39;</span>
                <span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_range_var</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">),</span> <span class="n">range_</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">range_</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">range_</span><span class="o">.</span><span class="n">upper</span><span class="p">]</span>
                <span class="p">]</span>

            <span class="n">new_range</span> <span class="o">=</span> <span class="n">Range</span><span class="p">(</span><span class="n">range_</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_range</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_</span>
            <span class="k">elif</span> <span class="n">range_</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid ranges&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]),</span>
                    <span class="s1">&#39;duplicated labels&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">symb</span><span class="p">,</span> <span class="n">new_range</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_range_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">range_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check size expression for valid symbol presence.&quot;&quot;&quot;</span>

        <span class="n">range_vars</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">range_var</span> <span class="o">=</span> <span class="n">range_vars</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="n">range_var</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">!=</span> <span class="n">range_var</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid range&#39;</span><span class="p">,</span> <span class="n">range_</span><span class="p">,</span> <span class="s1">&#39;unexpected symbol&#39;</span><span class="p">,</span>
                    <span class="n">range_var</span><span class="p">,</span> <span class="s1">&#39;conflicting with&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid range&#39;</span><span class="p">,</span> <span class="n">range_</span><span class="p">,</span> <span class="s1">&#39;containing multiple symbols&#39;</span><span class="p">,</span>
                <span class="n">range_vars</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">_reset_dumms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the dummies in a grain.&quot;&quot;&quot;</span>

        <span class="n">exts</span><span class="p">,</span> <span class="n">ext_substs</span><span class="p">,</span> <span class="n">dummbegs</span> <span class="o">=</span> <span class="n">Term</span><span class="o">.</span><span class="n">reset_sums</span><span class="p">(</span>
            <span class="n">grain</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span>
        <span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">grain</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="n">sums</span><span class="p">,</span> <span class="n">curr_substs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Term</span><span class="o">.</span><span class="n">reset_sums</span><span class="p">(</span>
                <span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span>
                <span class="n">dummbegs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">dummbegs</span><span class="p">),</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span>
            <span class="p">)</span>
            <span class="n">curr_substs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ext_substs</span><span class="p">)</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">curr_substs</span><span class="p">),</span> <span class="n">sums</span><span class="o">=</span><span class="n">sums</span>
            <span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">grain</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Optimization result post-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_linearize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">optimized</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_EvalNode</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Linearize optimized forms of the evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">interms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">interms</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">interms</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_set_n_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set reference counts from an evaluation node.</span>

<span class="sd">        It is always the first evaluation that is going to be used, all rest</span>
<span class="sd">        will be removed to avoid further complications.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">del</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">refs</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">dep</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">ref</span>
            <span class="n">dep_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span>
            <span class="n">dep_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">dep_node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linearize evaluation rooted in the given node into the result.</span>

<span class="sd">        If keep if set to True, the evaluation of the given node will not be</span>
<span class="sd">        appended to the result list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">generated</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">def_</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">node</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">def_</span>

    <span class="k">def</span> <span class="nf">_form_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of an evaluation node.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a product evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
        <span class="n">term</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">eval_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">term</span><span class="p">]),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_prod_def_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the term in the final definition of a product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">coeff</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_interm_ref</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
                <span class="n">dep</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">factor</span>
                <span class="n">interm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">dep</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">interm</span><span class="p">):</span>
                    <span class="c1"># Inline trivial reference to an input.</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_def</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_sum_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a sum evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span>

        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>

            <span class="n">coeff</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

            <span class="c1"># Sum term are guaranteed to be formed from references to products,</span>
            <span class="c1"># never directly written in terms of input.</span>
            <span class="n">term_base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">ref</span>
            <span class="n">term_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">term_base</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">term_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">term_node</span><span class="p">):</span>
                <span class="c1"># Inline intermediates only used here and simple input</span>
                <span class="c1"># references.</span>

                <span class="n">eval_</span> <span class="o">=</span> <span class="n">term_node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="p">()</span>
                <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">factors</span><span class="p">,</span> <span class="n">term_coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp_factors</span>

                <span class="c1"># Switch back to evaluation node for using the facilities for</span>
                <span class="c1"># product nodes.</span>
                <span class="n">new_term</span><span class="p">,</span> <span class="n">term_deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">_Prod</span><span class="p">(</span>
                    <span class="n">term_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">term_coeff</span><span class="p">,</span> <span class="n">factors</span>
                <span class="p">))</span>

                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_term</span><span class="p">)</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term_deps</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span>
                    <span class="p">(),</span> <span class="n">term</span><span class="p">,</span> <span class="p">()</span>
                <span class="p">))</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term_base</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_inline_sum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inline the summation terms from single-reference terms.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sum_term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span>
                <span class="n">ref</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">ref</span>
            <span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">if_inline</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_inline</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
                        <span class="p">}</span>

                <span class="n">proced_sum_terms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sum_term</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
                    <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">proced_sum_terms</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_is_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a product node is just a trivial reference to an input.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_interm_ref</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">_Grain</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Finalize the linearization result.</span>

<span class="sd">        Things will be cast to drudge tensor definitions, with intermediates</span>
<span class="sd">        holding names formed from the format given by user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">),</span> <span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">sums</span>
            <span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">terms</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">:</span>
                <span class="n">final_base</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">base</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interm_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">next_idx</span><span class="p">))</span>
                <span class="n">next_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">substs</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_base</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TensorDef</span><span class="p">(</span>
                <span class="n">final_base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">create_tensor</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="c1">#</span>
    <span class="c1"># Internal support utilities.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_get_next_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the base or symbol for the next internal intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Symbol</span> <span class="k">if</span> <span class="n">symbol</span> <span class="k">else</span> <span class="n">IndexedBase</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="s1">&#39;gristmillInternalIntermediate</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_write_in_orig_ranges</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the summations in terms of undecorated bare ranges.</span>

<span class="sd">        The labels in the ranges are assumed to be decorated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sums</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_canon_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a canonical label for a list of terms.</span>

<span class="sd">        The new summation list is prepended to the summation list of all terms.</span>
<span class="sd">        The coefficient ahead of the canonical form is returned before the</span>
<span class="sd">        canonical form.  And the permuted new summation list is also returned</span>
<span class="sd">        after the canonical form.  Note that this list contains the original</span>
<span class="sd">        dummies given in the new summation list, while the terms has reset new</span>
<span class="sd">        dummies.</span>

<span class="sd">        Note that the ranges in the new summation list are assumed to be</span>
<span class="sd">        decorated with labels earlier than _SUMMED.  In the result, they are</span>
<span class="sd">        still in decorated forms and are guaranteed to be permuted in the same</span>
<span class="sd">        way for all given terms.  The summations from the terms will be</span>
<span class="sd">        internally decorated but written in bare ranges in the final result.</span>

<span class="sd">        Note that this is definitely a poor man&#39;s version of canonicalization of</span>
<span class="sd">        multi-term tensor definitions with external indices.  A lot of cases</span>
<span class="sd">        cannot be handled well.  Hopefully it can be replaced with a systematic</span>
<span class="sd">        treatment some day in the future.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_dumms</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_sums</span><span class="p">}</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">candidates</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">term</span><span class="p">,</span> <span class="n">canon_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp_factors</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

            <span class="n">candidates</span><span class="p">[</span>
                <span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
            <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_sums</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Poor man&#39;s canonicalization of external indices.</span>
        <span class="c1">#</span>
        <span class="c1"># This algorithm is not guaranteed to work.  Here we just choose an</span>
        <span class="c1"># ordering of the external indices that is as safe as possible.  But</span>
        <span class="c1"># certainly it is not guaranteed to work for all cases.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Fix it!</span>

        <span class="n">chosen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">new_dumms</span><span class="p">),</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_key</span>
        <span class="p">))</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chosen</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">canon_new_sums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Internal deficiency: &#39;</span>
                <span class="s1">&#39;summation intermediate may not be fully canonicalized&#39;</span>
            <span class="p">)</span>
        <span class="c1"># This could also fail when the chosen term has symmetry among the new</span>
        <span class="c1"># summations not present in any other term.  This can be hard to check.</span>

        <span class="n">canon_new_sum</span> <span class="o">=</span> <span class="n">canon_new_sums</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">preferred</span> <span class="o">=</span> <span class="n">chosen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">canon_coeff</span> <span class="o">=</span> <span class="n">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">canon_term</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">canon_new_sum</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># TODO: Add support for complex conjugation.</span>
            <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">canon_coeff</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">canon_coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">res_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">canon_new_sum</span>

    <span class="k">def</span> <span class="nf">_canon_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonicalize a single term.</span>

<span class="sd">        Internal method for _canon_terms, not supposed to be directly called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sums</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_EXT</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_sums</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">fix_new</span> <span class="k">else</span> <span class="n">new_sums</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_SUMMED</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="p">)</span>
        <span class="p">)),</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">canoned</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">canon_sums</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">sums</span>
        <span class="n">canon_orig_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">canon_sums</span><span class="p">)</span>

        <span class="n">dumm_reset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="n">canon_orig_sums</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="n">dumms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span>
        <span class="p">)</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="n">new_sums</span> <span class="k">if</span> <span class="n">fix_new</span> <span class="k">else</span> <span class="n">canon_sums</span><span class="p">[:</span><span class="n">n_new</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dumm_reset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dumm_reset</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">canon_new_sums</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">dumm_reset</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_new</span><span class="p">:]</span>
        <span class="p">))),</span> <span class="n">canon_new_sums</span>

    <span class="k">def</span> <span class="nf">_parse_interm_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_term</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the coefficient and pure intermediate reference in a reference.</span>

<span class="sd">        Despite being SymPy expressions, actually intermediate reference, for</span>
<span class="sd">        instance in a term in an summation node, is very rigid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_term</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">sum_term</span><span class="o">.</span><span class="n">args</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_interm_ref</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">args</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_interm_ref</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_UNITY</span><span class="p">,</span> <span class="n">sum_term</span>

    <span class="k">def</span> <span class="nf">_is_interm_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if an expression is a reference to an intermediate.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interm_ref</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the definition of an intermediate reference.</span>

<span class="sd">        The intermediate reference need to be a pure intermediate reference</span>
<span class="sd">        without any factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interm_ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">interm_ref</span><span class="o">.</span><span class="n">base</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">interm_ref</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interm_ref</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">interm_ref</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid intermediate reference&#39;</span><span class="p">,</span> <span class="n">interm_ref</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid intermediate base&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_sum</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_index_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the sum node&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">))</span>
            <span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_def</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_index_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the evaluation node.&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># TODO: Add handling of sum intermediate reference in factors.</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">),</span> <span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">excl</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>

    <span class="c1">#</span>
    <span class="c1"># General optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_form_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grain</span><span class="p">:</span> <span class="n">_Grain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation node from a tensor definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We assume it is fully simplified and expanded by grist preparation.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">terms</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>  <span class="c1"># Should be removed by grist preparation.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span><span class="n">grain</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given node.</span>

<span class="sd">        The evaluation methods will be filled with, possibly multiple, method of</span>
<span class="sd">        evaluations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sum</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_prod</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_interm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">_EvalNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Form a product intermediate.</span>

<span class="sd">        The factors are assumed to be all non-trivial factors needing</span>
<span class="sd">        processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_EXT</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sums</span><span class="p">),</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span> <span class="p">())</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span>
            <span class="n">decored_exts</span><span class="p">,</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">(</span><span class="n">n_exts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">key_term</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">key_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
            <span class="n">key_sums</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]</span>
            <span class="n">key_factors</span><span class="p">,</span> <span class="n">key_coeff</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">amp_factors</span>
            <span class="n">interm</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">key_exts</span><span class="p">,</span> <span class="n">key_sums</span><span class="p">,</span> <span class="n">key_coeff</span><span class="p">,</span> <span class="n">key_factors</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">interm</span>

        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">canon_exts</span>
        <span class="p">)]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_form_sum_interm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">_EvalNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Form a sum intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_EXT</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">canon_terms</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">canon_terms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">canon_terms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">(</span><span class="n">n_exts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">node_exts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">node_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">canon_terms</span><span class="p">:</span>
                <span class="n">term_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">node_exts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node_exts</span> <span class="o">=</span> <span class="n">term_exts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">node_exts</span> <span class="o">==</span> <span class="n">term_exts</span>
                <span class="n">node_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]</span>
                <span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">node_exts</span><span class="p">,</span> <span class="n">node_terms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">canon_exts</span>
        <span class="p">)]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_form_sum_from_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a summation node for given the terms.</span>

<span class="sd">        No processing is done in this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp_factors</span>
            <span class="n">interm_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
            <span class="n">sum_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interm_ref</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Sum optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the summation node.&quot;&quot;&quot;</span>

        <span class="c1"># We first optimize the common terms.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">new_term_idxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_common_terms</span><span class="p">(</span><span class="n">sum_node</span><span class="p">)</span>

        <span class="c1"># Now we embark upon the heroic factorization.</span>
        <span class="n">collectibles</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># type: _Collectibles</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">new_term_idxes</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="c1"># Loop over collectibles the new term can offer.</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_collectibles</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
                    <span class="n">infos</span> <span class="o">=</span> <span class="n">collectibles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
                        <span class="c1"># The same term cannot provide the same collectible</span>
                        <span class="c1"># twice.</span>
                        <span class="n">infos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">continue</span>

                <span class="k">continue</span>
            <span class="n">new_term_idxes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="n">to_collect</span><span class="p">,</span> <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_collectible</span><span class="p">(</span><span class="n">collectibles</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">to_collect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">new_term_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">infos</span><span class="p">)</span>
            <span class="n">new_term_idxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_term_idx</span><span class="p">)</span>

            <span class="k">del</span> <span class="n">collectibles</span><span class="p">[</span><span class="n">to_collect</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infos</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">collectibles</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">continue</span>
        <span class="c1"># End Main loop.</span>

        <span class="n">rem_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">sum_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Sum</span><span class="p">(</span>
            <span class="n">sum_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">rem_terms</span>
        <span class="p">)]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_optimize_common_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Perform optimization of common intermediate references.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exts_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>

        <span class="c1"># Intermediate base -&gt; (indices -&gt; coefficient)</span>
        <span class="c1">#</span>
        <span class="c1"># This also gather terms with the same reference to deeper nodes.</span>
        <span class="n">interm_refs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

            <span class="n">interm_refs</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
            <span class="k">continue</span>

        <span class="c1"># Intermediate referenced only once goes to the result directly and wait</span>
        <span class="c1"># to be factored, others wait to be pulled and do not participate in</span>
        <span class="c1"># factorization.</span>
        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res_collectible_idxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Indices, coeffs tuple -&gt; base, coeff</span>
        <span class="n">pull_info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">interm_refs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res_collectible_idxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res_terms</span><span class="p">))</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Here we use name for sorting directly, since here we cannot</span>
                <span class="c1"># have general expressions hence no need to use the expensive</span>
                <span class="c1"># sort_key.</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)))</span>
                <span class="n">leading_coeff</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">pull_info</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">/</span> <span class="n">leading_coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">raw</span>
                <span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="p">))</span>

        <span class="c1"># Now we treat the terms from which new intermediates might be pulled</span>
        <span class="c1"># out.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pull_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># No need to form a new intermediate.</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pivot_ref</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need to form an intermediate here.</span>
                <span class="n">interm_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">exts_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivot</span>
                <span class="p">)</span>
                <span class="n">pivot_ref</span><span class="p">,</span> <span class="n">interm_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span><span class="n">interm_exts</span><span class="p">,</span> <span class="p">[</span>
                    <span class="n">term</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_def</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pivot</span><span class="p">])</span>
                    <span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">interm_node</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pivot_ref</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span> <span class="o">/</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res_terms</span><span class="p">,</span> <span class="n">res_collectible_idxes</span>

    <span class="k">def</span> <span class="nf">_find_collectibles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">term</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the collectibles from a given term.</span>

<span class="sd">        Collectibles are going to be yielded as key and infos pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[typing.Tuple[_Collectible, _CollectInfo]]</span>

        <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># TODO: Add attempt to collect the coefficient.</span>
            <span class="c1">#</span>
            <span class="c1"># This could give some minor saving.</span>
            <span class="k">pass</span>

        <span class="n">prod_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">ref</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">prod_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Single-factor does not offer collectible,</span>
            <span class="c1"># collectible * (something + 1) is so rare in real applications.</span>

            <span class="k">for</span> <span class="n">eval_i</span> <span class="ow">in</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_collectibles_eval</span><span class="p">(</span>
                    <span class="n">exts</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">eval_i</span>
                <span class="p">))</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_find_collectibles_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the collectibles for a particular evaluations of a product.&quot;&quot;&quot;</span>

        <span class="c1"># To begin, we first need to substitute the external indices in for this</span>
        <span class="c1"># particular evaluation inside its ambient.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span>
            <span class="n">eval_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">eval_term</span> <span class="o">=</span> <span class="n">eval_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">eval_term</span><span class="o">.</span><span class="n">amp_factors</span>
            <span class="n">eval_</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                <span class="n">_SUBSTED_EVAL_BASE</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">eval_term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span>
            <span class="p">)</span>

        <span class="n">sums</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sums</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="c1"># Each evaluation could give two collectibles.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="n">lr</span><span class="p">]</span>
            <span class="n">collectible</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">substs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_collectible_interm</span><span class="p">(</span>
                <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factor</span>
            <span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">collectible</span><span class="p">,</span> <span class="n">_CollectInfo</span><span class="p">(</span>
                <span class="n">eval_</span><span class="o">=</span><span class="n">eval_</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span>
                <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">substs</span><span class="o">=</span><span class="n">substs</span><span class="p">,</span> <span class="n">ranges</span><span class="o">=</span><span class="n">ranges</span>
            <span class="p">)))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_get_collectible_interm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">interm_ref</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a collectible from an intermediate reference.&quot;&quot;&quot;</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_def</span><span class="p">(</span><span class="n">interm_ref</span><span class="p">)</span>
        <span class="n">involved_symbs</span> <span class="o">=</span> <span class="n">interm_ref</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>

        <span class="n">involved_exts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other_exts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">symb</span><span class="p">,</span> <span class="n">range_</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">if</span> <span class="n">symb</span> <span class="ow">in</span> <span class="n">involved_symbs</span><span class="p">:</span>
                <span class="n">involved_exts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                    <span class="n">symb</span><span class="p">,</span> <span class="n">range_</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_EXT</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">range_</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_exts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">symb</span><span class="p">,</span> <span class="n">range_</span><span class="p">))</span>  <span class="c1"># Undecorated.</span>
            <span class="k">continue</span>

        <span class="n">involved_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>
            <span class="c1"># Sums not involved in both should be pushed in.</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">involved_symbs</span>
            <span class="n">involved_sums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">_SUMMED_EXT</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
            <span class="p">))</span>
            <span class="k">continue</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">all_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">involved_exts</span><span class="p">,</span> <span class="n">involved_sums</span><span class="p">)),</span> <span class="n">terms</span>
        <span class="p">)</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="n">_Ranges</span><span class="p">(</span>
            <span class="n">involved_exts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">involved_exts</span><span class="p">),</span>
            <span class="n">sums</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">involved_sums</span><span class="p">),</span>
            <span class="n">other_exts</span><span class="o">=</span><span class="n">other_exts</span>
        <span class="p">)</span>

        <span class="n">new_sums</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_sums</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">_SUMMED_EXT</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">involved_sums</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">)</span>
            <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_choose_collectible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collectibles</span><span class="p">:</span> <span class="n">_Collectibles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Choose the most profitable collectible factor.&quot;&quot;&quot;</span>

        <span class="n">with_saving</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">collectibles</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">with_saving</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">get_cost_key</span><span class="p">(</span>
                <span class="c1"># Any range is sufficient for the determination of savings.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_collectible_saving</span><span class="p">(</span>
                    <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">ranges</span>
                <span class="p">)</span>
            <span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_collectible_saving</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="n">_Ranges</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the saving factor for a collectible.&quot;&quot;&quot;</span>

        <span class="n">other_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">other_exts</span><span class="p">)</span>
        <span class="n">sum_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>
        <span class="n">ext_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">ranges</span><span class="o">.</span><span class="n">involved_exts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other_size</span> <span class="o">*</span> <span class="n">add_costs</span><span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">sum_size</span> <span class="o">*</span> <span class="n">ext_size</span><span class="p">,</span> <span class="n">ext_size</span><span class="p">,</span> <span class="o">-</span><span class="n">sum_size</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">collect_infos</span><span class="p">:</span> <span class="n">_CollectInfos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collect the given collectible factor.</span>

<span class="sd">        This function will mutate the given terms list.  Set one of the</span>
<span class="sd">        collected terms to the new sum term, whose index is going to be</span>
<span class="sd">        returned, with all the rest collected terms set to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">residue_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">residue_exts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_term_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">collect_infos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collect_infos</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">eval_</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">eval_</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">coeff</span>  <span class="c1"># Three levels of coefficients.</span>

            <span class="n">residue_terms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">i</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_def</span><span class="p">(</span>
                    <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">lr</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">substs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">curr_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ranges</span><span class="o">.</span><span class="n">other_exts</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ranges</span><span class="o">.</span><span class="n">sums</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">residue_exts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">residue_exts</span> <span class="o">=</span> <span class="n">curr_exts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">residue_exts</span> <span class="o">==</span> <span class="n">curr_exts</span>

            <span class="k">continue</span>

        <span class="n">new_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span><span class="n">residue_exts</span><span class="p">,</span> <span class="n">residue_terms</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collect_infos</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">new_term_idx</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_collected</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="n">new_ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">new_term_idx</span>

    <span class="k">def</span> <span class="nf">_form_collected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="n">_CollectInfo</span><span class="p">,</span> <span class="n">new_ref</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form new sum term with some factors collected based on a term.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">eval_</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">eval_</span>
        <span class="n">collected_factor</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">lr</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">substs</span><span class="p">)</span>

        <span class="n">interm_coeff</span><span class="p">,</span> <span class="n">interm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">new_ref</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">interm_coeff</span> <span class="o">/</span> <span class="n">info</span><span class="o">.</span><span class="n">coeff</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">orig_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">orig_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span>
            <span class="n">orig_ref</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">)</span> <span class="k">else</span> <span class="n">orig_ref</span>
        <span class="p">]</span>
        <span class="n">orig_exts</span> <span class="o">=</span> <span class="n">orig_node</span><span class="o">.</span><span class="n">exts</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">new_node</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">orig_exts</span><span class="p">,</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="p">[</span>
            <span class="n">collected_factor</span><span class="p">,</span> <span class="n">interm</span>
        <span class="p">])</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">orig_exts</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span>
        <span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Product optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_factors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_factors</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod_node</span><span class="p">)</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prod_final_cost</span><span class="p">(</span>
                <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span>
                <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">evals</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span>
        <span class="n">optimal_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts_gen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_factor_parts</span><span class="p">(</span>
                <span class="n">prod_node</span>
        <span class="p">):</span>
            <span class="n">if_break</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">optimal_cost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">get_cost_key</span><span class="p">(</span><span class="n">final_cost</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">optimal_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_break</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># Else</span>

            <span class="k">for</span> <span class="n">parts</span> <span class="ow">in</span> <span class="n">parts_gen</span><span class="p">:</span>

                <span class="c1"># Recurse, two parts.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">total_cost</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">final_cost</span>
                    <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                    <span class="o">+</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                <span class="p">)</span>
                <span class="n">total_cost_key</span> <span class="o">=</span> <span class="n">get_cost_key</span><span class="p">(</span><span class="n">total_cost</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">optimal_cost</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">optimal_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">total_cost_key</span><span class="p">:</span>
                    <span class="n">optimal_cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_cost_key</span><span class="p">,</span> <span class="n">total_cost</span><span class="p">)</span>
                    <span class="n">evals</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_eval</span><span class="p">(</span>
                        <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts</span>
                    <span class="p">))</span>
                <span class="k">elif</span> <span class="n">optimal_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">total_cost_key</span><span class="p">:</span>
                    <span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_eval</span><span class="p">(</span>
                        <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts</span>
                    <span class="p">))</span>

                <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">optimal_cost</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_gen_factor_parts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all the partitions of factors in a product node.&quot;&quot;&quot;</span>

        <span class="c1"># Compute things invariant to different summations for performance.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">exts_total_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

        <span class="n">factor_atoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span>
            <span class="p">]</span>
        <span class="n">sum_involve</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factor_atoms</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span>
            <span class="p">]</span>

        <span class="n">dumm2index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Indices of external and internal dummies involved by each factors.</span>
        <span class="n">factor_infos</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dumm2index</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">factor_atoms</span>
            <span class="p">]</span>

        <span class="c1"># Actual generation.</span>
        <span class="k">for</span> <span class="n">broken_size</span><span class="p">,</span> <span class="n">kept</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_kept_sums</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="n">broken_sums</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">kept</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">final_cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prod_final_cost</span><span class="p">(</span>
                <span class="n">exts_total_size</span><span class="p">,</span> <span class="n">broken_size</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_parts_w_kept_sums</span><span class="p">(</span>
                <span class="n">prod_node</span><span class="p">,</span> <span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span>
            <span class="p">)</span>
            <span class="k">continue</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_kept_sums</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate kept summations in increasing size of broken summations.</span>

<span class="sd">        The results will be given as boolean array giving if the corresponding</span>
<span class="sd">        entry is to be kept.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">]</span>
        <span class="n">n_sums</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="n">kept</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Wrap the kept summation with its size.&quot;&quot;&quot;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">prod_</span><span class="p">(</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">kept</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">j</span>
            <span class="p">))</span>
            <span class="k">return</span> <span class="n">get_cost_key</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">kept</span>

        <span class="n">init</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_sums</span>  <span class="c1"># Everything is kept.</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_size</span><span class="p">(</span><span class="n">init</span><span class="p">)]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">curr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">curr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">curr_kept</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sums</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">curr_kept</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">new_kept</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_kept</span><span class="p">)</span>
                    <span class="n">new_kept</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">get_size</span><span class="p">(</span><span class="n">new_kept</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">continue</span>

    <span class="k">def</span> <span class="nf">_gen_parts_w_kept_sums</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all partitions with given summations kept.</span>

<span class="sd">        First we the factors are divided into chunks indivisible according to</span>
<span class="sd">        the kept summations.  Then their bipartitions which really break the</span>
<span class="sd">        broken sums are generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dsf</span> <span class="o">=</span> <span class="n">DSF</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">dsf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="n">dsf</span><span class="o">.</span><span class="n">sets</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_parts_from_chunks</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_form_part</span><span class="p">(</span><span class="n">prod_node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">part</span>
            <span class="p">)</span>

        <span class="k">return</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_parts_from_chunks</span><span class="p">(</span><span class="n">kept</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate factor partitions from chunks.</span>

<span class="sd">        Here special care is taken to respect the broken summations in the</span>
<span class="sd">        result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_chunks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">chunks_part</span> <span class="ow">in</span> <span class="n">multiset_partitions</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">factors_part</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span>
                <span class="n">factor_i</span> <span class="k">for</span> <span class="n">chunk_i</span> <span class="ow">in</span> <span class="n">chunk_part_i</span>
                <span class="k">for</span> <span class="n">factor_i</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">[</span><span class="n">chunk_i</span><span class="p">]</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">chunk_part_i</span> <span class="ow">in</span> <span class="n">chunks_part</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kept</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Now we have broken sum, it need to be involved by both parts.</span>
                <span class="n">involve</span> <span class="o">=</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">involve</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">factors_part</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">factors_part</span>

    <span class="k">def</span> <span class="nf">_form_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">,</span> <span class="n">factor_idxes</span><span class="p">,</span> <span class="n">sum_involve</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a partition for the given factors.&quot;&quot;&quot;</span>

        <span class="n">involved_exts</span><span class="p">,</span> <span class="n">involved_sums</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factor_idxes</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span>

        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factor_idxes</span><span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">involved_exts</span>
            <span class="p">]</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">factor_idxes</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">sum_involve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">factor_idxes</span><span class="p">:</span>
                <span class="n">sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">ref</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Part</span><span class="p">(</span><span class="n">ref</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_prod_final_cost</span><span class="p">(</span><span class="n">exts_total_size</span><span class="p">,</span> <span class="n">sums_total_size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute the final cost for a pairwise product evaluation.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sums_total_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exts_total_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_TWO</span> <span class="o">*</span> <span class="n">exts_total_size</span> <span class="o">*</span> <span class="n">sums_total_size</span>

    <span class="k">def</span> <span class="nf">_form_prod_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">parts</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Part</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation for a product node.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">curr_coeff</span><span class="p">,</span> <span class="n">curr_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">curr_coeff</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_ref</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Prod</span><span class="p">(</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span>
            <span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span>
        <span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Utility constants.</span>
<span class="c1">#</span>


<span class="n">_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_NEG_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_TWO</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">_EXT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SUMMED_EXT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_SUMMED</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">_SUBSTED_EVAL_BASE</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillSubstitutedEvalBase&#39;</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Utility static functions.</span>
<span class="c1">#</span>

<span class="k">class</span> <span class="nc">_SymbFactory</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A small symbol factory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillInternalSymbol</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="n">_SYMB_FACTORY</span> <span class="o">=</span> <span class="n">_SymbFactory</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the canonical coefficient from a list of coefficients.&quot;&quot;&quot;</span>

    <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primitive</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span>
        <span class="n">v</span> <span class="o">*</span> <span class="n">_SYMB_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="p">))</span>

    <span class="c1"># The primitive computation does not take phase into account.</span>
    <span class="n">n_neg</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">n_neg</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="n">n_neg</span> <span class="o">&gt;</span> <span class="n">n_pos</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_NEG_UNITY</span>
    <span class="k">elif</span> <span class="n">n_pos</span> <span class="o">&gt;</span> <span class="n">n_neg</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_UNITY</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">preferred_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_NEG_UNITY</span> <span class="k">if</span> <span class="n">preferred</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">preferred</span><span class="o">.</span><span class="n">is_negative</span>
            <span class="k">else</span> <span class="n">_UNITY</span>
        <span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">preferred_phase</span>

    <span class="k">return</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">phase</span>


<span class="c1">#</span>
<span class="c1"># Optimization result verification</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="verify_eval_seq"><a class="viewcode-back" href="../../api.html#gristmill.verify_eval_seq">[docs]</a><span class="k">def</span> <span class="nf">verify_eval_seq</span><span class="p">(</span>
        <span class="n">eval_seq</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">res</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span>
        <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Verify the correctness of an evaluation sequence for the results.</span>

<span class="sd">    The last entries of the evaluation sequence should be in one-to-one</span>
<span class="sd">    correspondence with the original form in the ``res`` argument.  This</span>
<span class="sd">    function returns ``True`` when the evaluation sequence is symbolically</span>
<span class="sd">    equivalent to the given raw form.  When a difference is found,</span>
<span class="sd">    ``ValueError`` will be raised with relevant information.</span>

<span class="sd">    Note that this function can be very slow for large evaluations.  But it is</span>
<span class="sd">    advised to be used for all optimizations in mission-critical tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    eval_seq</span>
<span class="sd">        The evaluation sequence to verify, can be the output from</span>
<span class="sd">        :py:func:`optimize` directly.</span>

<span class="sd">    res</span>
<span class="sd">        The original result to test the evaluation sequence against.  It can be</span>
<span class="sd">        the input to :py:func:`optimize` directly.</span>

<span class="sd">    simplify</span>
<span class="sd">        If simplification is going to be performed after each step of the</span>
<span class="sd">        back-substitution.  It is advised for larger complex evaluations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">substed_eval_seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">defs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">eval_</span> <span class="ow">in</span> <span class="n">eval_seq</span><span class="p">:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">base</span>
        <span class="n">free_vars</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="n">curr_defs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">defs_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">free_vars</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">defs_dict</span>
            <span class="p">]</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">subst_all</span><span class="p">(</span><span class="n">curr_defs</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
        <span class="n">new_def</span> <span class="o">=</span> <span class="n">TensorDef</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">substed_eval_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_def</span><span class="p">)</span>
        <span class="n">defs_dict</span><span class="p">[</span>
            <span class="n">base</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">new_def</span>
        <span class="k">continue</span>

    <span class="n">n_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">substed_eval_seq</span><span class="p">[</span><span class="o">-</span><span class="n">n_res</span><span class="p">:],</span> <span class="n">res</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">j</span><span class="o">.</span><span class="n">lhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal left-hand sides&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;for&#39;</span><span class="p">,</span> <span class="n">j</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">rhs</span> <span class="o">-</span> <span class="n">j</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal definition for &#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">j</span>
            <span class="p">)</span>
        <span class="k">continue</span>

    <span class="k">return</span> <span class="kc">True</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jinmo Zhao and Gustavo E Scuseria.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>