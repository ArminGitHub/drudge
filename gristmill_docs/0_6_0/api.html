
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>API Reference &#8212; gristmill 0.6.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="0.6.0" href="releases/0_6_0.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal"><span class="pre">gristmill</span></code> package can be divided into two orthogonal parts,</p>
<dl class="docutils">
<dt>The evaluation optimization part,</dt>
<dd>which transforms tensor definitions into a mathematically equivalent
definition sequence with less floating-point operations required.</dd>
<dt>The code generation part,</dt>
<dd>which takes tensor definitions, either optimized or not, into computer code
snippets.</dd>
</dl>
<div class="section" id="evaluation-optimization">
<h2>Evaluation Optimization<a class="headerlink" href="#evaluation-optimization" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="gristmill.optimize">
<code class="descclassname">gristmill.</code><code class="descname">optimize</code><span class="sig-paren">(</span><em>computs: typing.Iterable[drudge.drudge.TensorDef], substs=None, simplify=True, interm_fmt='tau^{}', contr_strat=&lt;ContrStrat.TRAV: 2&gt;, opt_sum=True, opt_symm=True, req_an_opt=False, greedy_cutoff=-1, drop_cutoff=-1, remove_shallow=True</em><span class="sig-paren">)</span> &#x2192; typing.List[drudge.drudge.TensorDef]<a class="reference internal" href="_modules/gristmill/optimize.html#optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the evaluation of the given tensor computations.</p>
<p>This function will transform the given computations, given as tensor
definitions, into another list of computations mathematically equivalent
to the given computations, while requiring less arithmetic operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>computs</strong> – The computations, can be given as an iterable of tensor definitions.</li>
<li><strong>substs</strong> – A dictionary for making substitutions inside the sizes of ranges.  All
the ranges need to have size in at most one undetermined variable after
the substitution, so that they can be totally ordered.  When one symbol
still remains in the sizes, the asymptotic cost (scaling and prefactor)
will be optimized.  Or when all symbols are gone after the substitution,
optimization is going to be based on the numeric sizes.  Numeric sizes
tend to make the optimization faster due to the usage of built-in
integer or floating point arithmetic in lieu of the more complex
polynomial arithmetic.</li>
<li><strong>simplify</strong> – If the input is going to be simplified before processing.  It can be
disabled when the input is already simplified.</li>
<li><strong>interm_fmt</strong> – The format for the names of the intermediates.</li>
<li><strong>contr_strat</strong> – The strategy for handling contractions, as explained in
<a class="reference internal" href="#gristmill.ContrStrat" title="gristmill.ContrStrat"><code class="xref py py-class docutils literal"><span class="pre">ContrStrat</span></code></a>.</li>
<li><strong>opt_sum</strong> – If sums of multiple terms will be attempted to be optimized by using
constriction (factorization).</li>
<li><strong>opt_symm</strong> – If common symmetrization of multiple tensors, input or intermediate,
is going to be optimized.  For instance, with it, <span class="math">\(x_{a,
b} + y_{a, b} - 2 x_{b, a} - 2 y_{b, a}\)</span> can be optimized into first
computing <span class="math">\(p_{a, b} = x_{a, b} + y_{a, b}\)</span> followed by
<span class="math">\(p_{a, b} - 2 p_{b, a}\)</span>.</li>
<li><strong>req_an_opt</strong> – If each constriction operation is required to have optimal
parenthesization for at lease one of its terms.  This requirement
attempts to accelerate the constriction searching by having a smaller
number of branches at the first-edge level of the recursion tree.
However, it has a chance of giving deteriorated optimization, and it is
not guaranteed to be faster since pivoting at this level have to be
disabled.  So it is set as False by default.  It might be worth
experimenting for large inputs, especially with exhaust strategy for
contractions, or when greedy is turned on.</li>
<li><strong>greedy_cutoff</strong> – The depth cutoff for making greedy selection in constriction. Beyond
this depth in the recursion tree (inclusive), only the choices making
locally best saving will be considered.  With negative values,
full Bron-Kerbosch backtracking is performed.</li>
<li><strong>drop_cutoff</strong> – The depth cutoff for picking only a random one with greedy saving in
summation optimization.  The difference with the option
<code class="docutils literal"><span class="pre">greedy_cutoff</span></code> is that here only <strong>one</strong> choice giving the locally
best saving will be considered, rather than all of them.  This could
give better acceleration than <code class="docutils literal"><span class="pre">greedy_cutoff</span></code> at the presence of large
degeneracy, while results could be less optimized.  For large inputs, a
value of <code class="docutils literal"><span class="pre">2</span></code> is advised.</li>
<li><strong>remove_shallow</strong> – Shallow intermediates are outer-product intermediates that come with no
summations.  Normally these intermediates cannot give saving big enough
to justify their memory usage.  So by default, they just dropped, with
their content inlined into places where they are referenced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gristmill.ContrStrat">
<em class="property">class </em><code class="descclassname">gristmill.</code><code class="descname">ContrStrat</code><a class="reference internal" href="_modules/gristmill/optimize.html#ContrStrat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.ContrStrat" title="Permalink to this definition">¶</a></dt>
<dd><p>The strategies for handling tensor contractions.</p>
<p>This class holds possible options for different ways of handling
contractions in the optimization, for both the termination of the main
loop and the retention of parenthesizations for sum optimization.
Specifically, we have options</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GREEDY</span></code></dt>
<dd>The contraction within each term will be optimized greedily.  This
accelerates the optimization with big sacrifice of the result
quality.  So it should only be used for inputs having terms
containing many factors by a very dense pattern.</dd>
<dt><code class="docutils literal"><span class="pre">OPT</span></code></dt>
<dd>The global minimum of each tensor contraction will be found by the
advanced algorithm in gristmill.  And only the optimal contraction(s)
will be kept for the sum optimization.</dd>
<dt><code class="docutils literal"><span class="pre">TRAV</span></code></dt>
<dd>The same strategy as <code class="docutils literal"><span class="pre">OPT</span></code> will be attempted for the optimization
of contractions.  But all evaluations traversed in the optimization
process will be kept and considered in subsequent summation
optimizations.</dd>
<dt><code class="docutils literal"><span class="pre">EXHAUST</span></code></dt>
<dd>All possible parenthesizations will be considered for all terms. This
can be extremely slow.  But it might be helpful for problems having
terms all with manageable number of factors.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="gristmill.verify_eval_seq">
<code class="descclassname">gristmill.</code><code class="descname">verify_eval_seq</code><span class="sig-paren">(</span><em>eval_seq: typing.Sequence[drudge.drudge.TensorDef], res: typing.Sequence[drudge.drudge.TensorDef], simplify=False</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/gristmill/optimize.html#verify_eval_seq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.verify_eval_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify the correctness of an evaluation sequence for the results.</p>
<p>The last entries of the evaluation sequence should be in one-to-one
correspondence with the original form in the <code class="docutils literal"><span class="pre">res</span></code> argument.  This
function returns <code class="docutils literal"><span class="pre">True</span></code> when the evaluation sequence is symbolically
equivalent to the given raw form.  When a difference is found,
<code class="docutils literal"><span class="pre">ValueError</span></code> will be raised with relevant information.</p>
<p>Note that this function can be very slow for large evaluations.  But it is
advised to be used for all optimizations in mission-critical tasks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eval_seq</strong> – The evaluation sequence to verify, can be the output from
<a class="reference internal" href="#gristmill.optimize" title="gristmill.optimize"><code class="xref py py-func docutils literal"><span class="pre">optimize()</span></code></a> directly.</li>
<li><strong>res</strong> – The original result to test the evaluation sequence against.  It can be
the input to <a class="reference internal" href="#gristmill.optimize" title="gristmill.optimize"><code class="xref py py-func docutils literal"><span class="pre">optimize()</span></code></a> directly.</li>
<li><strong>simplify</strong> – If simplification is going to be performed after each step of the
back-substitution.  It is advised for larger complex evaluations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gristmill.get_flop_cost">
<code class="descclassname">gristmill.</code><code class="descname">get_flop_cost</code><span class="sig-paren">(</span><em>eval_seq: typing.Iterable[drudge.drudge.TensorDef], leading=False, ignore_consts=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/utils.html#get_flop_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.get_flop_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the FLOP cost for the given evaluation sequence.</p>
<p>This function gives the count of floating-point operations, addition and
multiplication, involved by the evaluation sequence.  Note that the cost of
copying and initialization are not counted.  And this function is only
applicable where the amplitude of the terms are simple products.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eval_seq</strong> – The evaluation sequence whose FLOP cost is to be estimated.  It should
be given as an iterable of tensor definitions.</li>
<li><strong>leading</strong> – If only the cost terms with leading scaling be given.  When multiple
symbols are present in the range sizes, terms with the highest total
scaling is going to be picked.</li>
<li><strong>ignore_consts</strong> – If the cost of scaling with constants can be ignored.  <span class="math">\(2 x_i y_j\)</span>
could count as just one FLOP when it is set, otherwise it would be two.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="code-generation">
<h2>Code generation<a class="headerlink" href="#code-generation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="gristmill.BasePrinter">
<em class="property">class </em><code class="descclassname">gristmill.</code><code class="descname">BasePrinter</code><span class="sig-paren">(</span><em>scal_printer: sympy.printing.printer.Printer</em>, <em>indexed_proc_cb=&lt;function BasePrinter.&lt;lambda&gt;&gt;</em>, <em>add_globals=None</em>, <em>add_filters=None</em>, <em>add_tests=None</em>, <em>add_templ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#BasePrinter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.BasePrinter" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for tensor printers.</p>
<dl class="method">
<dt id="gristmill.BasePrinter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>scal_printer: sympy.printing.printer.Printer</em>, <em>indexed_proc_cb=&lt;function BasePrinter.&lt;lambda&gt;&gt;</em>, <em>add_globals=None</em>, <em>add_filters=None</em>, <em>add_tests=None</em>, <em>add_templ=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#BasePrinter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.BasePrinter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a base printer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scal_printer</strong> – The SymPy printer for scalar quantities.</li>
<li><strong>indexed_proc_cb</strong> – It is going to be called with context nodes with <code class="docutils literal"><span class="pre">base</span></code> and
<code class="docutils literal"><span class="pre">indices</span></code> (in both the root and for each indexed factors, as
described in <a class="reference internal" href="#gristmill.BasePrinter.transl" title="gristmill.BasePrinter.transl"><code class="xref py py-meth docutils literal"><span class="pre">transl()</span></code></a>) to do additional processing.  For
most tasks, <a class="reference internal" href="#gristmill.mangle_base" title="gristmill.mangle_base"><code class="xref py py-func docutils literal"><span class="pre">mangle_base()</span></code></a> can be helpful.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gristmill.BasePrinter.transl">
<code class="descname">transl</code><span class="sig-paren">(</span><em>tensor_def: drudge.drudge.TensorDef</em><span class="sig-paren">)</span> &#x2192; types.SimpleNamespace<a class="reference internal" href="_modules/gristmill/generate.html#BasePrinter.transl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.BasePrinter.transl" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate tensor definition into context for template rendering.</p>
<p>This function will translate the given tensor definition into a simple
namespace that could be easily used as the context in the actual Jinja
template rendering.</p>
<p>The context contains fields,</p>
<dl class="docutils">
<dt>base</dt>
<dd>A printed form for the base of the tensor definition.</dd>
<dt>indices</dt>
<dd>A list of external indices.  For each entry, keys <code class="docutils literal"><span class="pre">index</span></code> and
<code class="docutils literal"><span class="pre">range</span></code> are present to give the printed form of the index and the
range object that it is over. For convenience, <code class="docutils literal"><span class="pre">lower</span></code>, <code class="docutils literal"><span class="pre">upper</span></code>,
and <code class="docutils literal"><span class="pre">size</span></code> have the printed form of lower/upper bounds and the
size of the range.  We also have <code class="docutils literal"><span class="pre">lower_expr</span></code>, <code class="docutils literal"><span class="pre">upper_expr</span></code>, and
<code class="docutils literal"><span class="pre">size_expr</span></code> for the unprinted expression of them.</dd>
<dt>terms</dt>
<dd><p class="first">A list of terms for the tensor, with each entry being a simple
namespace with keys,</p>
<dl class="last docutils">
<dt>sums</dt>
<dd>A list of summations in the tensor term.  Its entries are in the
same format as the external indices for tarrays.</dd>
<dt>phase</dt>
<dd><code class="docutils literal"><span class="pre">+</span></code> sign or <code class="docutils literal"><span class="pre">-</span></code> sign.  For the phase of the term.</dd>
<dt>numerator</dt>
<dd>The printed form of the numerator of the coefficient of the
term.  It can be a simple <code class="docutils literal"><span class="pre">1</span></code> string.</dd>
<dt>denominator</dt>
<dd>The printed form of the denominator.</dd>
<dt>indexed_factors</dt>
<dd>The indexed factors of the term.  Each is given as a simple
namespace with key <code class="docutils literal"><span class="pre">base</span></code> for the printed form of the base,
and a key <code class="docutils literal"><span class="pre">indices</span></code> giving the indices to the key, in the same
format as the <code class="docutils literal"><span class="pre">indices</span></code> field of the base context.</dd>
<dt>other_factors</dt>
<dd>Factors which are not simple indexed quantity, given as a list
of the printed form directly.</dd>
</dl>
</dd>
</dl>
<p>The actual content of the context can also be customized by overriding
the <a class="reference internal" href="#gristmill.BasePrinter.proc_ctx" title="gristmill.BasePrinter.proc_ctx"><code class="xref py py-meth docutils literal"><span class="pre">proc_ctx()</span></code></a> in subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.BasePrinter.proc_ctx">
<code class="descname">proc_ctx</code><span class="sig-paren">(</span><em>tensor_def: drudge.drudge.TensorDef, term: typing.Union[drudge.term.Term, NoneType], tensor_entry: types.SimpleNamespace, term_entry: typing.Union[types.SimpleNamespace, NoneType]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#BasePrinter.proc_ctx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.BasePrinter.proc_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Make additional processing of the rendering context.</p>
<p>This method can be override to make additional processing on the
rendering context described in <a class="reference internal" href="#gristmill.BasePrinter.transl" title="gristmill.BasePrinter.transl"><code class="xref py py-meth docutils literal"><span class="pre">transl()</span></code></a> to perform additional
customization or to make more information available.</p>
<p>It will be called for each of the terms during the processing.  And
finally it will be called again with the term given as None for a final
processing.</p>
<p>By default, the indexed quantities nodes are processed by the user-given
call-back.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.BasePrinter.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>templ_name: str</em>, <em>ctx: types.SimpleNamespace</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/gristmill/generate.html#BasePrinter.render"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.BasePrinter.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the given context for the given template.</p>
<p>Meaningful subclass methods can call this function for actual
functionality.</p>
</dd></dl>

<dl class="attribute">
<dt id="gristmill.BasePrinter.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#gristmill.BasePrinter.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="gristmill.mangle_base">
<code class="descclassname">gristmill.</code><code class="descname">mangle_base</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#mangle_base"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.mangle_base" title="Permalink to this definition">¶</a></dt>
<dd><p>Mangle the base names in the indexed nodes in template context.</p>
<p>A function taking the printed string for an indexed base and a list of its
indices, as described in <a class="reference internal" href="#gristmill.BasePrinter.transl" title="gristmill.BasePrinter.transl"><code class="xref py py-meth docutils literal"><span class="pre">BasePrinter.transl()</span></code></a>, to return a new
mangled base name can be given to get a function call-back compatible with
the <code class="docutils literal"><span class="pre">indexed_proc_cb</span></code> argument of <a class="reference internal" href="#gristmill.BasePrinter.__init__" title="gristmill.BasePrinter.__init__"><code class="xref py py-meth docutils literal"><span class="pre">BasePrinter.__init__()</span></code></a>
constructor.</p>
<p>This function can also be used as a function decorator.  For instance, for a
tensor with name <code class="docutils literal"><span class="pre">f</span></code>, when we have operations on subspaces of the indices
but the tensor is stored as a whole, we might want to print the base as
slices depending on the range of the indices given to it.  If we have two
ranges stored in variables <code class="docutils literal"><span class="pre">o</span></code> and <code class="docutils literal"><span class="pre">v</span></code> and they are over the indices
<code class="docutils literal"><span class="pre">0:m</span></code> and <code class="docutils literal"><span class="pre">m:n</span></code>, the following function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@mangle_base</span>
<span class="k">def</span> <span class="nf">print_indexed_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
    <span class="n">o_slice</span> <span class="o">=</span> <span class="s1">&#39;0:m&#39;</span>
    <span class="n">v_slice</span> <span class="o">=</span> <span class="s1">&#39;m:n&#39;</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;f[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">o_slice</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">range</span> <span class="o">==</span> <span class="n">o</span> <span class="k">else</span> <span class="n">v_slice</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
        <span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
</pre></div>
</div>
<p>can be given to the <code class="docutils literal"><span class="pre">indexed_proc_cb</span></code> argument of
<a class="reference internal" href="#gristmill.BasePrinter.__init__" title="gristmill.BasePrinter.__init__"><code class="xref py py-meth docutils literal"><span class="pre">BasePrinter.__init__()</span></code></a> constructor, so that all appearances of
<code class="docutils literal"><span class="pre">f</span></code> will be printed as the correct slice depending on the range of the
indices.  When different slices of <code class="docutils literal"><span class="pre">f</span></code> are actually stored in different
variables, we can also return the correct variable name inside the function.</p>
</dd></dl>

<dl class="class">
<dt id="gristmill.ImperativeCodePrinter">
<em class="property">class </em><code class="descclassname">gristmill.</code><code class="descname">ImperativeCodePrinter</code><span class="sig-paren">(</span><em>scal_printer: sympy.printing.printer.Printer</em>, <em>print_indexed_cb</em>, <em>global_indent=1</em>, <em>indent_size=4</em>, <em>max_width=80</em>, <em>line_cont=''</em>, <em>breakable_regex='(\s*[+-]\s*)'</em>, <em>stmt_end=''</em>, <em>add_globals=None</em>, <em>add_filters=None</em>, <em>add_tests=None</em>, <em>add_templ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#ImperativeCodePrinter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.ImperativeCodePrinter" title="Permalink to this definition">¶</a></dt>
<dd><p>Printer for automatic generation of naive imperative code.</p>
<p>This printer supports the printing of the evaluation of tensor
expressions by simple loops and arithmetic operations.</p>
<p>This is mostly a base class that is going to be subclassed for different
languages.  For each language, mostly just the options for the language
could be given in the super initializer.  Most important ones are the
printer for the scalar expressions and the formatter of loops, as well as
some definition of literals and operators.</p>
<dl class="method">
<dt id="gristmill.ImperativeCodePrinter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>scal_printer: sympy.printing.printer.Printer</em>, <em>print_indexed_cb</em>, <em>global_indent=1</em>, <em>indent_size=4</em>, <em>max_width=80</em>, <em>line_cont=''</em>, <em>breakable_regex='(\\s*[+-]\\s*)'</em>, <em>stmt_end=''</em>, <em>add_globals=None</em>, <em>add_filters=None</em>, <em>add_tests=None</em>, <em>add_templ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#ImperativeCodePrinter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.ImperativeCodePrinter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the automatic code printer.</p>
<dl class="docutils">
<dt>scal_printer</dt>
<dd>A sympy printer used for the printing of scalar expressions.</dd>
<dt>print_indexed_cb</dt>
<dd>It will be called with the printed base, and the list of indices (as
described in <a class="reference internal" href="#gristmill.BasePrinter.transl" title="gristmill.BasePrinter.transl"><code class="xref py py-meth docutils literal"><span class="pre">BasePrinter.transl()</span></code></a>) to return the string for
the printed form.  This will be called after the given processing of
indexed nodes.</dd>
<dt>global_indent</dt>
<dd>The base global indentation of the generated code.</dd>
<dt>indent_size</dt>
<dd>The size of the indentation.</dd>
<dt>max_width</dt>
<dd>The maximum width for each line.</dd>
<dt>line_cont</dt>
<dd>The string used for indicating line continuation.</dd>
<dt>breakable_regex</dt>
<dd>The regular expression used to break long expressions.</dd>
<dt>stmt_end</dt>
<dd>The ending of the statements.</dd>
<dt>index_paren</dt>
<dd>The pair of parenthesis for indexing arrays.</dd>
</dl>
<p>All options to the base class <a class="reference internal" href="#gristmill.BasePrinter" title="gristmill.BasePrinter"><code class="xref py py-class docutils literal"><span class="pre">BasePrinter</span></code></a> are also
supported.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.ImperativeCodePrinter.proc_ctx">
<code class="descname">proc_ctx</code><span class="sig-paren">(</span><em>tensor_def: drudge.drudge.TensorDef, term: typing.Union[drudge.term.Term, NoneType], tensor_entry: types.SimpleNamespace, term_entry: typing.Union[types.SimpleNamespace, NoneType]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#ImperativeCodePrinter.proc_ctx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.ImperativeCodePrinter.proc_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the context.</p>
<p>The indexed nodes will be printed by user-given printer and given to
<code class="docutils literal"><span class="pre">indexed</span></code> attributes of the same node.  Also the term contexts will be
given an attribute named <code class="docutils literal"><span class="pre">amp</span></code> for the whole amplitude part put
together.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.ImperativeCodePrinter.print_eval">
<code class="descname">print_eval</code><span class="sig-paren">(</span><em>ctx: types.SimpleNamespace</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#ImperativeCodePrinter.print_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.ImperativeCodePrinter.print_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the evaluation of a tensor definition.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="gristmill.CCodePrinter">
<code class="descclassname">gristmill.</code><code class="descname">CCodePrinter</code><a class="reference internal" href="_modules/sympy/printing/ccode.html#CCodePrinter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.CCodePrinter" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">wrapper</span></code></p>
</dd></dl>

<dl class="class">
<dt id="gristmill.FortranPrinter">
<em class="property">class </em><code class="descclassname">gristmill.</code><code class="descname">FortranPrinter</code><span class="sig-paren">(</span><em>openmp=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#FortranPrinter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.FortranPrinter" title="Permalink to this definition">¶</a></dt>
<dd><p>Fortran code printer.</p>
<p>In this class, just some parameters for the <em>new</em> Fortran programming
language is fixed relative to the base <a class="reference internal" href="#gristmill.ImperativeCodePrinter" title="gristmill.ImperativeCodePrinter"><code class="xref py py-class docutils literal"><span class="pre">ImperativeCodePrinter</span></code></a>.</p>
<dl class="method">
<dt id="gristmill.FortranPrinter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>openmp=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#FortranPrinter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.FortranPrinter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a Fortran code printer.</p>
<p>The printer class, the name of the template, and the line continuation
symbol will be set automatically.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.FortranPrinter.print_decl_eval">
<code class="descname">print_decl_eval</code><span class="sig-paren">(</span><em>tensor_defs: typing.Iterable[drudge.drudge.TensorDef], decl_type='real', explicit_bounds=False</em><span class="sig-paren">)</span> &#x2192; typing.Tuple[typing.List[str], typing.List[str]]<a class="reference internal" href="_modules/gristmill/generate.html#FortranPrinter.print_decl_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.FortranPrinter.print_decl_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Print Fortran declarations and evaluations of tensor definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tensor_defs</strong> – The tensor definitions to print.</li>
<li><strong>decl_type</strong> – The type to be declared for the tarrays.</li>
<li><strong>explicit_bounds</strong> – If the lower and upper bounds should be written explicitly in the
declaration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><em>decls</em> – The list of declaration strings.</li>
<li><em>evals</em> – The list of evaluation strings.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gristmill.FortranPrinter.print_decl">
<code class="descname">print_decl</code><span class="sig-paren">(</span><em>ctx</em>, <em>decl_type</em>, <em>explicit_bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#FortranPrinter.print_decl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.FortranPrinter.print_decl" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the Fortran declaration of the LHS of a tensor definition.</p>
<p>A string will be returned that forms the naive declaration of the
given tarrays as local variables.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gristmill.EinsumPrinter">
<em class="property">class </em><code class="descclassname">gristmill.</code><code class="descname">EinsumPrinter</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#EinsumPrinter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.EinsumPrinter" title="Permalink to this definition">¶</a></dt>
<dd><p>Printer for the einsum function.</p>
<p>For tensors that are classical tensor contractions, this printer generates
code based on the NumPy <code class="docutils literal"><span class="pre">einsum</span></code> function.  For contractions supported,
the code from this printer can also be used for Tensorflow.</p>
<dl class="method">
<dt id="gristmill.EinsumPrinter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/gristmill/generate.html#EinsumPrinter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.EinsumPrinter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the printer.</p>
<p>All keyword arguments are forwarded to the base class
<a class="reference internal" href="#gristmill.BasePrinter" title="gristmill.BasePrinter"><code class="xref py py-class docutils literal"><span class="pre">BasePrinter</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="gristmill.EinsumPrinter.print_eval">
<code class="descname">print_eval</code><span class="sig-paren">(</span><em>tensor_defs: typing.Iterable[drudge.drudge.TensorDef], base_indent=4</em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/gristmill/generate.html#EinsumPrinter.print_eval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gristmill.EinsumPrinter.print_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the evaluation of the tensor definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tensor_defs</strong> – The tensor definitions for the evaluations.</li>
<li><strong>base_indent</strong> – The base indent of the generated code.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The code for evaluations.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API Reference</a><ul>
<li><a class="reference internal" href="#evaluation-optimization">Evaluation Optimization</a></li>
<li><a class="reference internal" href="#code-generation">Code generation</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="releases/0_6_0.html" title="previous chapter">0.6.0</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jinmo Zhao and Gustavo E Scuseria.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>