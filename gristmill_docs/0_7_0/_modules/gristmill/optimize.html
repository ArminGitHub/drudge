
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>gristmill.optimize &#8212; gristmill 0.7.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for gristmill.optimize</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Optimizer for the contraction computations.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">drudge</span> <span class="k">import</span> <span class="n">TensorDef</span><span class="p">,</span> <span class="n">prod_</span><span class="p">,</span> <span class="n">Term</span><span class="p">,</span> <span class="n">Range</span><span class="p">,</span> <span class="n">sum_</span>
<span class="kn">from</span> <span class="nn">networkx</span> <span class="k">import</span> <span class="n">Graph</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Integer</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">primitive</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span>
    <span class="n">default_sort_key</span><span class="p">,</span> <span class="n">Pow</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Size</span><span class="p">,</span> <span class="n">get_total_size</span><span class="p">,</span> <span class="n">DSF</span><span class="p">,</span> <span class="n">Tuple4Cmp</span><span class="p">,</span> <span class="n">form_sized_range</span>
<span class="p">)</span>


<span class="c1">#</span>
<span class="c1">#  The public driver</span>
<span class="c1">#  -----------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="ContrStrat"><a class="viewcode-back" href="../../api.html#gristmill.ContrStrat">[docs]</a><span class="k">class</span> <span class="nc">ContrStrat</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The strategies for handling tensor contractions.</span>

<span class="sd">    This class holds possible options for different ways of handling</span>
<span class="sd">    contractions in the optimization, for both the termination of the main</span>
<span class="sd">    loop and the retention of parenthesizations for sum optimization.</span>
<span class="sd">    Specifically, we have options</span>

<span class="sd">    ``GREEDY``</span>
<span class="sd">        The contraction within each term will be optimized greedily.  This</span>
<span class="sd">        accelerates the optimization with big sacrifice of the result</span>
<span class="sd">        quality.  So it should only be used for inputs having terms</span>
<span class="sd">        containing many factors by a very dense pattern.</span>

<span class="sd">    ``OPT``</span>
<span class="sd">        The global minimum of each tensor contraction will be found by the</span>
<span class="sd">        advanced algorithm in gristmill.  And only the optimal contraction(s)</span>
<span class="sd">        will be kept for the sum optimization.</span>

<span class="sd">    ``TRAV``</span>
<span class="sd">        The same strategy as ``OPT`` will be attempted for the optimization</span>
<span class="sd">        of contractions.  But all evaluations traversed in the optimization</span>
<span class="sd">        process will be kept and considered in subsequent summation</span>
<span class="sd">        optimizations.</span>

<span class="sd">    ``EXHAUST``</span>
<span class="sd">        All possible parenthesizations will be considered for all terms. This</span>
<span class="sd">        can be extremely slow.  But it might be helpful for problems having</span>
<span class="sd">        terms all with manageable number of factors.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">GREEDY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">OPT</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">TRAV</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">EXHAUST</span> <span class="o">=</span> <span class="mi">3</span></div>


<div class="viewcode-block" id="RepeatedTermsStrat"><a class="viewcode-back" href="../../api.html#gristmill.RepeatedTermsStrat">[docs]</a><span class="k">class</span> <span class="nc">RepeatedTermsStrat</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimization for repeated terms in a sum.</span>

<span class="sd">    In some sum of tensor contractions, some terms might be different components</span>
<span class="sd">    of the same computed tensor.  For instance, in</span>

<span class="sd">    .. math::</span>

<span class="sd">        r_{a, b} = s_a t_b + s_b t_a</span>

<span class="sd">    if we define</span>

<span class="sd">    .. math::</span>

<span class="sd">        i_{a, b} = s_a t_b</span>

<span class="sd">    the two terms are actually :math:`i_{a, b}` and :math:`i_{b, a}`.  For</span>
<span class="sd">    problem with repeated terms, we have strategies,</span>

<span class="sd">    ``SKIP``</span>

<span class="sd">        Repeated terms are simply skipped during the optimization by</span>
<span class="sd">        factorization.  In this way, repeated terms are guaranteed not to be</span>
<span class="sd">        computed twice even implicitly.</span>

<span class="sd">    ``NATURAL``</span>

<span class="sd">        Repeated terms participates factorization only when faster evaluation is</span>
<span class="sd">        given by this.  Technically, this is achieved by setting the excess cost</span>
<span class="sd">        of the evaluation of the terms to be the **full cost** of the</span>
<span class="sd">        evaluation, rather than the difference with the optimal cost.  This</span>
<span class="sd">        setting should give acceptable result for most purposes.</span>

<span class="sd">    ``IGNORE``</span>

<span class="sd">        Ignore the fact that the terms are repeated.  They are going to be</span>
<span class="sd">        treated exactly like other terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SKIP</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">NATURAL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">IGNORE</span> <span class="o">=</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../../api.html#gristmill.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">substs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">interm_fmt</span><span class="o">=</span><span class="s1">&#39;tau^</span><span class="si">{}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">contr_strat</span><span class="o">=</span><span class="n">ContrStrat</span><span class="o">.</span><span class="n">TRAV</span><span class="p">,</span> <span class="n">opt_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">repeated_terms_strat</span><span class="o">=</span><span class="n">RepeatedTermsStrat</span><span class="o">.</span><span class="n">NATURAL</span><span class="p">,</span>
             <span class="n">opt_symm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">req_an_opt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">greedy_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">remove_shallow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given tensor computations.</span>

<span class="sd">    This function will transform the given computations, given as tensor</span>
<span class="sd">    definitions, into another list of computations mathematically equivalent</span>
<span class="sd">    to the given computations, while requiring less arithmetic operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    computs</span>
<span class="sd">        The computations, can be given as an iterable of tensor definitions.</span>

<span class="sd">    substs</span>
<span class="sd">        A dictionary for making substitutions inside the sizes of ranges.  All</span>
<span class="sd">        the ranges need to have size in at most one undetermined variable after</span>
<span class="sd">        the substitution, so that they can be totally ordered.  When one symbol</span>
<span class="sd">        still remains in the sizes, the asymptotic cost (scaling and prefactor)</span>
<span class="sd">        will be optimized.  Or when all symbols are gone after the substitution,</span>
<span class="sd">        optimization is going to be based on the numeric sizes.  Numeric sizes</span>
<span class="sd">        tend to make the optimization faster due to the usage of built-in</span>
<span class="sd">        integer or floating point arithmetic in lieu of the more complex</span>
<span class="sd">        polynomial arithmetic.</span>

<span class="sd">    simplify</span>
<span class="sd">        If the input is going to be simplified before processing.  It can be</span>
<span class="sd">        disabled when the input is already simplified.</span>

<span class="sd">    interm_fmt</span>
<span class="sd">        The format for the names of the intermediates.</span>

<span class="sd">    contr_strat</span>
<span class="sd">        The strategy for handling contractions, as explained in</span>
<span class="sd">        :py:class:`ContrStrat`.</span>

<span class="sd">    repeated_terms_strat</span>
<span class="sd">        The strategy for handling repeated terms in sums, as explained in</span>
<span class="sd">        :py:class:`RepeatedTermsStrat`.</span>

<span class="sd">    opt_sum</span>
<span class="sd">        If sums of multiple terms will be attempted to be optimized by using</span>
<span class="sd">        constriction (factorization).</span>

<span class="sd">    opt_symm</span>
<span class="sd">        If common symmetrization of multiple tensors, input or intermediate,</span>
<span class="sd">        is going to be optimized.  For instance, with it, :math:`x_{a,</span>
<span class="sd">        b} + y_{a, b} - 2 x_{b, a} - 2 y_{b, a}` can be optimized into first</span>
<span class="sd">        computing :math:`p_{a, b} = x_{a, b} + y_{a, b}` followed by</span>
<span class="sd">        :math:`p_{a, b} - 2 p_{b, a}`.</span>

<span class="sd">    req_an_opt</span>
<span class="sd">        If each constriction operation is required to have optimal</span>
<span class="sd">        parenthesization for at lease one of its terms.  This requirement</span>
<span class="sd">        attempts to accelerate the constriction searching by having a smaller</span>
<span class="sd">        number of branches at the first-edge level of the recursion tree.</span>
<span class="sd">        However, it has a chance of giving deteriorated optimization, and it is</span>
<span class="sd">        not guaranteed to be faster since pivoting at this level have to be</span>
<span class="sd">        disabled.  So it is set as False by default.  It might be worth</span>
<span class="sd">        experimenting for large inputs, especially with exhaust strategy for</span>
<span class="sd">        contractions, or when greedy is turned on.</span>

<span class="sd">    greedy_cutoff</span>
<span class="sd">        The depth cutoff for making greedy selection in constriction. Beyond</span>
<span class="sd">        this depth in the recursion tree (inclusive), only the choices making</span>
<span class="sd">        locally best saving will be considered.  With negative values,</span>
<span class="sd">        full Bron-Kerbosch backtracking is performed.</span>

<span class="sd">    drop_cutoff</span>
<span class="sd">        The depth cutoff for picking only a random one with greedy saving in</span>
<span class="sd">        summation optimization.  The difference with the option</span>
<span class="sd">        ``greedy_cutoff`` is that here only **one** choice giving the locally</span>
<span class="sd">        best saving will be considered, rather than all of them.  This could</span>
<span class="sd">        give better acceleration than ``greedy_cutoff`` at the presence of large</span>
<span class="sd">        degeneracy, while results could be less optimized.  For large inputs, a</span>
<span class="sd">        value of ``2`` is advised.</span>

<span class="sd">    remove_shallow</span>
<span class="sd">        Shallow intermediates are outer-product intermediates that come with no</span>
<span class="sd">        summations.  Normally these intermediates cannot give saving big enough</span>
<span class="sd">        to justify their memory usage.  So by default, they just dropped, with</span>
<span class="sd">        their content inlined into places where they are referenced.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This interface function is primarily just for sanity checking and</span>
    <span class="c1"># normalization of the input.</span>

    <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">substs</span>

    <span class="n">computs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">if</span> <span class="n">simplify</span> <span class="k">else</span> <span class="n">i</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">computs</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">computs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No computation is given!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">contr_strat</span><span class="p">,</span> <span class="n">ContrStrat</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid contraction strategy&#39;</span><span class="p">,</span> <span class="n">contr_strat</span><span class="p">)</span>

    <span class="n">opt</span> <span class="o">=</span> <span class="n">_Optimizer</span><span class="p">(</span>
        <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="o">=</span><span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="o">=</span><span class="n">interm_fmt</span><span class="p">,</span>
        <span class="n">contr_strat</span><span class="o">=</span><span class="n">contr_strat</span><span class="p">,</span> <span class="n">opt_sum</span><span class="o">=</span><span class="n">opt_sum</span><span class="p">,</span>
        <span class="n">repeated_terms_strat</span><span class="o">=</span><span class="n">repeated_terms_strat</span><span class="p">,</span>
        <span class="n">opt_symm</span><span class="o">=</span><span class="n">opt_symm</span><span class="p">,</span> <span class="n">req_an_opt</span><span class="o">=</span><span class="n">req_an_opt</span><span class="p">,</span>
        <span class="n">greedy_cutoff</span><span class="o">=</span><span class="n">greedy_cutoff</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="o">=</span><span class="n">drop_cutoff</span><span class="p">,</span>
        <span class="n">remove_shallow</span><span class="o">=</span><span class="n">remove_shallow</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span></div>


<span class="c1">#</span>
<span class="c1"># The internal optimization engine</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>
<span class="c1"># General small type definitions</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>

<span class="c1"># Base for tensor definitions.</span>
<span class="c1">#</span>
<span class="c1"># Symbol for 0-order tensors, IndexedBase for other cases.</span>

<span class="n">_Base</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">]</span>

<span class="c1"># Symbol/range pairs.</span>

<span class="n">_SrPairs</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Range</span><span class="p">]]</span>

<span class="c1"># Sequences of terms.</span>

<span class="n">_Terms</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Term</span><span class="p">]</span>

<span class="c1"># Indices to tensor bases.</span>

<span class="n">_Indices</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_Grain</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A piece of grain ready for optimization.</span>

<span class="sd">    Basically it is a tensor definition with localized terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span><span class="p">:</span> <span class="n">_Base</span>
    <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="n">terms</span><span class="p">:</span> <span class="n">_Terms</span>


<span class="k">class</span> <span class="nc">_IntermRef</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A reference to an intermediate.&quot;&quot;&quot;</span>
    <span class="n">coeff</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">base</span><span class="p">:</span> <span class="n">_Base</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">_Indices</span>
    <span class="n">power</span><span class="p">:</span> <span class="nb">int</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The reference to intermediate without coefficient.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">power</span>


<span class="c1">#</span>
<span class="c1"># Utility constants</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="n">_ZERO</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_NEG_UNITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">_EXT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_SUMMED_EXT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_SUMMED</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">_SUBSTED_EVAL_BASE</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillSubstitutedEvalBase&#39;</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Global factories</span>
<span class="c1"># ~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_SymbFactory</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A small symbol factory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillInternalSymbol</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="n">_SYMB_FACTORY</span> <span class="o">=</span> <span class="n">_SymbFactory</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_WildFactory</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A small wild symbol factory.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Wild</span><span class="p">(</span><span class="s1">&#39;gristmillInternalWild</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="n">_WILD_FACTORY</span> <span class="o">=</span> <span class="n">_WildFactory</span><span class="p">()</span>


<span class="c1">#</span>
<span class="c1"># Utility static functions</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">def</span> <span class="nf">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the canonical coefficient from a list of coefficients.&quot;&quot;&quot;</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="n">v</span> <span class="o">*</span> <span class="n">_SYMB_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">together</span><span class="p">()</span>

    <span class="n">frac</span> <span class="o">=</span> <span class="n">_UNITY</span>  <span class="c1"># The fractional part.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Pow</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">continue</span>
        <span class="n">expr</span> <span class="o">/=</span> <span class="n">frac</span>

    <span class="n">coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">primitive</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span>
        <span class="n">_SYMB_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="c1"># Initial coefficient without phase.</span>
    <span class="n">init_coeff</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">frac</span>

    <span class="c1"># The primitive computation does not take phase into account.</span>
    <span class="n">negs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">poses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">/=</span> <span class="n">init_coeff</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="n">negs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">poses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">continue</span>

    <span class="n">neg_sig</span><span class="p">,</span> <span class="n">pos_sig</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">default_sort_key</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">negs</span><span class="p">,</span> <span class="n">poses</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">neg_sig</span> <span class="o">&gt;</span> <span class="n">pos_sig</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_NEG_UNITY</span>
    <span class="k">elif</span> <span class="n">pos_sig</span> <span class="o">&gt;</span> <span class="n">neg_sig</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">_UNITY</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">preferred_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_NEG_UNITY</span> <span class="k">if</span> <span class="n">preferred</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">_NEG_UNITY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">preferred</span><span class="o">.</span><span class="n">is_negative</span>
            <span class="k">else</span> <span class="n">_UNITY</span>
        <span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">preferred_phase</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Index the given base with indices.</span>

<span class="sd">    When strip is set to true, the indices are assumed to be symbol/range pairs</span>
<span class="sd">    list.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">base</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="n">base</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>


<span class="c1">#</span>
<span class="c1"># Core evaluation DAG nodes</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_EvalNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A node in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span>

        <span class="c1"># For optimization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[_EvalNode]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For result finalization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_substs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get substitutions and symbols requiring exclusion before indexing.</span>

<span class="sd">        First resetting dummies excluding the returned symbols and then making</span>
<span class="sd">        the returned substitution on each term could achieve indexing.  Since</span>
<span class="sd">        the real free symbols are already gather from all inputs, the free</span>
<span class="sd">        symbols are not considered here.  But they should be added for the</span>
<span class="sd">        resetting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">dumm</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">substs</span><span class="p">[</span><span class="n">dumm</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">excl</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dumm</span><span class="p">)</span>
            <span class="n">excl</span> <span class="o">|=</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span>


<span class="k">class</span> <span class="nc">_Sum</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sum nodes in the evaluation graph.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span> <span class="o">=</span> <span class="n">sum_terms</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Sum(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, sum_terms=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_Prod</span><span class="p">(</span><span class="n">_EvalNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product nodes in the evaluation graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sums</span> <span class="o">=</span> <span class="n">sums</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a representation string for the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;_Prod(base=</span><span class="si">{}</span><span class="s1">, exts=</span><span class="si">{}</span><span class="s1">, sums=</span><span class="si">{}</span><span class="s1">, coeff=</span><span class="si">{}</span><span class="s1">, factors=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sums</span><span class="p">),</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_Interm</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Newly formed intermediate.</span>

<span class="sd">    This small utility carries both a symbolic reference to an intermediate</span>
<span class="sd">    and the actual node for this, which can be helpful for getting</span>
<span class="sd">    information about a newly-formed intermediate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span>


<span class="c1">#</span>
<span class="c1"># Internals for product optimization</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">def</span> <span class="nf">_get_prod_final_cost</span><span class="p">(</span><span class="n">exts_total_size</span><span class="p">,</span> <span class="n">sums_total_size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Size</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the final cost for a pairwise product evaluation.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sums_total_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">exts_total_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">exts_total_size</span> <span class="o">*</span> <span class="n">sums_total_size</span>


<span class="k">def</span> <span class="nf">_gen_broken_sums</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate broken summations in increasing size of broken summations.</span>

<span class="sd">    The size and the actual subset of broken summations are generated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">]</span>  <span class="c1"># Sizes are assumed to be sorted.</span>
    <span class="n">n_sums</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

    <span class="n">init</span> <span class="o">=</span> <span class="n">Tuple4Cmp</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># Nothing is broken.</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">init</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">curr</span>
        <span class="n">curr_size</span><span class="p">,</span> <span class="n">curr_broken</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="n">next_idx</span> <span class="o">=</span> <span class="n">curr_broken</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">next_idx</span> <span class="o">&lt;</span> <span class="n">n_sums</span><span class="p">:</span>
            <span class="n">joined_size</span> <span class="o">=</span> <span class="n">curr_size</span> <span class="o">*</span> <span class="n">sizes</span><span class="p">[</span><span class="n">next_idx</span><span class="p">]</span>
            <span class="n">joined_set</span> <span class="o">=</span> <span class="n">curr_broken</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">next_idx</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">Tuple4Cmp</span><span class="p">((</span>
                <span class="n">joined_size</span><span class="p">,</span> <span class="n">joined_set</span>
            <span class="p">)))</span>
            <span class="k">if</span> <span class="n">next_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">top_idx</span> <span class="o">=</span> <span class="n">next_idx</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">new_size</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">joined_size</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="n">top_idx</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">assert</span> <span class="n">joined_set</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">top_idx</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">Tuple4Cmp</span><span class="p">((</span>
                    <span class="n">new_size</span><span class="p">,</span> <span class="n">joined_set</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">top_idx</span>
                <span class="p">)))</span>
        <span class="k">continue</span>


<span class="c1">#</span>
<span class="c1"># Internals for summation optimization</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>
<span class="c1"># Convention: nodes always refer to nodes in the DAG for tensor computations,</span>
<span class="c1"># while vertices are used for vertices in the constriction graph.</span>
<span class="c1">#</span>

<span class="c1"># Organized references to products in a summation.</span>
<span class="c1">#</span>
<span class="c1"># Intermediate base -&gt; (indices -&gt; coefficient)</span>

<span class="n">_OrgTerms</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">DefaultDict</span><span class="p">[</span>
    <span class="n">Symbol</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">DefaultDict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Expr</span><span class="p">]</span>
<span class="p">]</span>

<span class="c1">#</span>
<span class="c1"># Symbolic names for the parts of the bicliques.</span>
<span class="c1">#</span>

<span class="n">_LEFT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_RIGHT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_OPPOS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">_LEFT</span><span class="p">:</span> <span class="n">_RIGHT</span><span class="p">,</span>
    <span class="n">_RIGHT</span><span class="p">:</span> <span class="n">_LEFT</span>
<span class="p">}</span>

<span class="c1"># For type annotation, actually is should be ``_LEFT | _RIGHT`` in Haskell</span>
<span class="c1"># algebraic data type notation.</span>

<span class="n">_LR</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;_LR&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">_LRS</span> <span class="o">=</span> <span class="p">(</span><span class="n">_LEFT</span><span class="p">,</span> <span class="n">_RIGHT</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_LastStepIdxes</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The involved indices of the last step of a constriction.</span>

<span class="sd">    The external and summation indices involved by the left/right factor in</span>
<span class="sd">    the last step of a contraction.  This is going to be used as the key for</span>
<span class="sd">    accessing the actual graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exts</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_SrPairs</span><span class="p">,</span> <span class="n">_SrPairs</span><span class="p">]</span>
    <span class="n">sums</span><span class="p">:</span> <span class="n">_SrPairs</span>


<span class="k">class</span> <span class="nc">_EdgeInfo</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Information about an edge on a constriction graph.&quot;&quot;&quot;</span>
    <span class="n">term</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span>
    <span class="n">coeff</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">exc_cost</span><span class="p">:</span> <span class="n">Size</span>


<span class="k">class</span> <span class="nc">_BaseInfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Information about a base referenced in a sum node.</span>

<span class="sd">    This is an open struct, with most of its manipulation done inside the</span>
<span class="sd">    optimizer class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;count&#39;</span><span class="p">,</span>
        <span class="s1">&#39;base&#39;</span><span class="p">,</span>
        <span class="s1">&#39;node&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">_Base</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the information.</span>

<span class="sd">        The count is initialized to **zero**.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span>


<span class="c1">#</span>
<span class="c1"># Intermediate data and results for the Kron-Kerbosch process.</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_VertInfo</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Information about a vertex in a constriction graph.</span>

<span class="sd">    expr</span>
<span class="sd">        The original expression for the factor.</span>

<span class="sd">    exts</span>
<span class="sd">        The involved external indices.</span>

<span class="sd">    canon</span>
<span class="sd">        The canonicalized content for the factor.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">exts</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">canon</span><span class="p">:</span> <span class="n">_Terms</span>


<span class="k">class</span> <span class="nc">_Delta</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Additional information about augmentation by a designated vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;coeff&#39;</span><span class="p">,</span>
        <span class="s1">&#39;leading_coeff&#39;</span><span class="p">,</span>
        <span class="s1">&#39;terms&#39;</span><span class="p">,</span>
        <span class="s1">&#39;exc_cost&#39;</span><span class="p">,</span>
        <span class="s1">&#39;saving&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span>
            <span class="n">terms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">exc_cost</span><span class="p">:</span> <span class="n">Size</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the delta.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leading_coeff</span> <span class="o">=</span> <span class="n">leading_coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">=</span> <span class="n">exc_cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saving</span><span class="p">:</span> <span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_DesVert</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vertices designated for a specific part.&quot;&quot;&quot;</span>
    <span class="n">part</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">vert</span><span class="p">:</span> <span class="nb">int</span>


<span class="c1"># Sets of designated vertices.</span>

<span class="n">_DesVerts</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Set</span><span class="p">[</span><span class="n">_DesVert</span><span class="p">]</span>

<span class="c1"># Dictionary of the designated vertices augmenting the current biclique along</span>
<span class="c1"># with their delta.</span>

<span class="n">_DesVertsWDelta</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Mapping</span><span class="p">[</span><span class="n">_DesVert</span><span class="p">,</span> <span class="n">_Delta</span><span class="p">]</span>

<span class="c1"># Zipped vertices and coefficients.</span>

<span class="n">_VertsWCoeff</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]]</span>

<span class="c1"># Parts for a constriction, left and right.</span>

<span class="n">_ConstrParts</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_VertsWCoeff</span><span class="p">,</span> <span class="n">_VertsWCoeff</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_Biclique</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A biclique to be yielded.&quot;&quot;&quot;</span>
    <span class="n">parts</span><span class="p">:</span> <span class="n">_ConstrParts</span>
    <span class="n">leading_coeff</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">terms</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">saving</span><span class="p">:</span> <span class="n">Size</span>
    <span class="n">constr_graph</span><span class="p">:</span> <span class="s1">&#39;_ConstrGraph&#39;</span>


<span class="c1">#</span>
<span class="c1"># Cost-related utilities for the Kron-Kerbosch process.</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_CostCoeffs</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cached quantities for getting gross saving of bicliques.</span>

<span class="sd">    final</span>
<span class="sd">        The final cost for contraction and make an addition of the results.</span>

<span class="sd">    preps</span>
<span class="sd">        The cost of making an addition for left and right factors.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">final</span><span class="p">:</span> <span class="n">Size</span>
    <span class="n">preps</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Size</span><span class="p">,</span> <span class="n">Size</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_cost_coeffs</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="p">:</span> <span class="n">_LastStepIdxes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_CostCoeffs</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get the cost coefficients for the given last step indices.&quot;&quot;&quot;</span>

    <span class="n">sums</span> <span class="o">=</span> <span class="n">last_step_idxes</span><span class="o">.</span><span class="n">sums</span>
    <span class="n">exts</span> <span class="o">=</span> <span class="n">last_step_idxes</span><span class="o">.</span><span class="n">exts</span>

    <span class="n">ext_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">exts</span><span class="p">))</span>

    <span class="n">final</span> <span class="o">=</span> <span class="n">_get_prod_final_cost</span><span class="p">(</span>
        <span class="n">ext_size</span><span class="p">,</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">sums</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">ext_size</span>

    <span class="n">preps</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">get_total_size</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">exts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sums</span><span class="p">)),</span>
        <span class="n">get_total_size</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">exts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sums</span><span class="p">))</span>
    <span class="p">)</span>  <span class="c1"># Explicitly repeated for linter.</span>

    <span class="k">return</span> <span class="n">_CostCoeffs</span><span class="p">(</span><span class="n">final</span><span class="o">=</span><span class="n">final</span><span class="p">,</span> <span class="n">preps</span><span class="o">=</span><span class="n">preps</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_VertGross</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Size</span><span class="p">,</span> <span class="n">Size</span><span class="p">]]):</span>
    <span class="sd">&quot;&quot;&quot;Gross saving of vertices.</span>

<span class="sd">    Given any numbers of vertices in the two parts, the gross saving of an</span>
<span class="sd">    additional vertex in the two parts can be queried.  The result are</span>
<span class="sd">    memorized for performance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;_cost_coeffs&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="p">:</span> <span class="n">_LastStepIdxes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the dictionary.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cost_coeffs</span> <span class="o">=</span> <span class="n">_get_cost_coeffs</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the gross savings for new keys.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost_coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_coeffs</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">key</span><span class="p">[</span><span class="n">_OPPOS</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">cost_coeffs</span><span class="o">.</span><span class="n">final</span> <span class="o">-</span> <span class="n">cost_coeffs</span><span class="o">.</span><span class="n">preps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_LRS</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="c1">#</span>
<span class="c1"># The core classes.</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_BronKerbosch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterable for the maximal bicliques.</span>

<span class="sd">    For performance reasons, the bicliques generated will contain references</span>
<span class="sd">    to internal mutable data.  It is the **responsibility of the caller** to</span>
<span class="sd">    make proper copy when it is necessary.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="p">:</span> <span class="n">_LastStepIdxes</span><span class="p">,</span> <span class="n">constr_graph</span><span class="p">:</span> <span class="s1">&#39;_ConstrGraph&#39;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the iterator.&quot;&quot;&quot;</span>

        <span class="c1"># Static data during the recursion, cached here for easier and faster</span>
        <span class="c1"># access.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span> <span class="o">=</span> <span class="n">constr_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span> <span class="o">=</span> <span class="n">constr_graph</span><span class="o">.</span><span class="n">constr_graphs</span><span class="o">.</span><span class="n">opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_req_an_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span><span class="o">.</span><span class="n">req_an_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span><span class="o">.</span><span class="n">greedy_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span><span class="o">.</span><span class="n">drop_cutoff</span>

        <span class="c1"># Dynamic data during the recursion.</span>
        <span class="c1">#</span>
        <span class="c1"># Zipped nodes and coefficients, for left and right.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">:</span> <span class="n">_ConstrParts</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>

        <span class="c1"># The leading coefficient.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The stack of actual saving.</span>
        <span class="c1">#</span>
        <span class="c1"># Keeping the saving as stack could save the cost of subtraction by</span>
        <span class="c1"># using some additional memory.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_savings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The set of terms currently in the biclique.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Gross saving of new vertices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vert_gross</span><span class="p">:</span> <span class="n">_VertGross</span> <span class="o">=</span> <span class="n">_VertGross</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the maximal bicliques.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span><span class="o">.</span><span class="n">exts</span>
        <span class="c1"># All left and right nodes.</span>
        <span class="n">subg</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">_DesVert</span><span class="p">(</span><span class="n">part</span><span class="o">=</span><span class="n">part</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">):</span> <span class="n">_Delta</span><span class="p">(</span>
                <span class="n">coeff</span><span class="o">=</span><span class="n">_UNITY</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exc_cost</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">vert</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span><span class="o">.</span><span class="n">verts</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">_LRS</span>
            <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">exts</span> <span class="o">==</span> <span class="n">exts</span><span class="p">[</span><span class="n">part</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">subg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">subg</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">subg</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># If things all goes correctly, the stack should be reverted to initial</span>
        <span class="c1"># state by now.</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_savings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">subg</span><span class="p">:</span> <span class="n">_DesVertsWDelta</span><span class="p">,</span> <span class="n">cand</span><span class="p">:</span> <span class="n">_DesVerts</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the bicliques from the current state.</span>

<span class="sd">        This is the core of the Bron-Kerbosch algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cached variables of the current state.</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span>
        <span class="n">n_verts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">curr</span><span class="p">)</span>

        <span class="n">savings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_savings</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">savings</span><span class="p">)</span>
        <span class="n">curr_saving</span> <span class="o">=</span> <span class="n">savings</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span><span class="o">.</span><span class="n">exts</span>

        <span class="c1"># The code here are adapted from the code in NetworkX for maximal clique</span>
        <span class="c1"># problem of simple general graphs.  The original code are kept as much</span>
        <span class="c1"># as possible and put in comments.  The original code on which the code</span>
        <span class="c1"># is based can be found at,</span>
        <span class="c1">#</span>
        <span class="c1"># https://github.com/networkx/networkx/blob</span>
        <span class="c1"># /48f4b5736174844c77044fae90e3e7adf1dabc10/networkx/algorithms</span>
        <span class="c1"># /clique.py#L277-L299</span>
        <span class="c1">#</span>

        <span class="n">if_maximal</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">saving</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">subg</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Redundant check on biclique size is used to skip the possibly</span>
        <span class="c1"># expansive saving comparison.</span>
        <span class="n">if_profitable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n_verts</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n_verts</span><span class="p">)</span> <span class="ow">and</span> <span class="n">curr_saving</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">if_maximal</span> <span class="ow">and</span> <span class="n">if_profitable</span><span class="p">:</span>
            <span class="c1"># If maximal and profitable.</span>
            <span class="c1">#</span>
            <span class="c1"># if not subg_q:</span>
            <span class="c1">#    yield Q[:]</span>
            <span class="c1">#</span>
            <span class="k">yield</span> <span class="n">_Biclique</span><span class="p">(</span>
                <span class="n">parts</span><span class="o">=</span><span class="n">curr</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span><span class="p">,</span>
                <span class="n">terms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_terms</span><span class="p">,</span> <span class="n">saving</span><span class="o">=</span><span class="n">curr_saving</span><span class="p">,</span>
                <span class="n">constr_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span>
            <span class="p">)</span>

        <span class="c1"># The quadratic loop.</span>
        <span class="n">subgq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">q_v</span><span class="p">,</span> <span class="n">q_d</span> <span class="ow">in</span> <span class="n">subg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subg_q</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subgq</span><span class="p">[</span><span class="n">q_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">subg_q</span>
            <span class="k">for</span> <span class="n">r_v</span><span class="p">,</span> <span class="n">r_d</span> <span class="ow">in</span> <span class="n">subg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">updated_r_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_delta</span><span class="p">(</span><span class="n">q_v</span><span class="p">,</span> <span class="n">q_d</span><span class="p">,</span> <span class="n">r_v</span><span class="p">,</span> <span class="n">r_d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">updated_r_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subg_q</span><span class="p">[</span><span class="n">r_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_r_d</span>
                <span class="k">continue</span>
            <span class="k">continue</span>

        <span class="c1">#</span>
        <span class="c1"># u = max(subg, key=lambda u: len(cand &amp; adj[u]))</span>
        <span class="c1"># for q in cand - adj[u]:</span>
        <span class="c1">#</span>

        <span class="c1"># to_loop need to be eagerly evaluated for avoiding complication with</span>
        <span class="c1"># the mutation of cand during the loop and the set operations for</span>
        <span class="c1"># pivoting.</span>

        <span class="n">pivots</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">_DesVert</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">n_verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cand</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">part</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">n_verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cand</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">part</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">exts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">exts</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># First part, first vertex, the vertex</span>
                <span class="n">exist_vert</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">curr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">vert</span> <span class="o">&gt;</span> <span class="n">exist_vert</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_req_an_opt</span><span class="p">:</span>
                <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span> <span class="k">if</span> <span class="n">subg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vert_gross</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">pivots</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subg</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">part</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gross</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cand</span> <span class="k">if</span> <span class="n">subg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">saving</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_loop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">pivots</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subg</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">saving</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">cut_greedy</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_greedy_cutoff</span> <span class="o">&lt;=</span> <span class="n">depth</span>
            <span class="n">cut_full</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drop_cutoff</span> <span class="o">&lt;=</span> <span class="n">depth</span>
            <span class="k">if</span> <span class="n">cut_greedy</span> <span class="ow">or</span> <span class="n">cut_full</span><span class="p">:</span>
                <span class="n">greedy_saving</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">saving</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span><span class="p">)</span>
                <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_loop</span> <span class="k">if</span> <span class="n">subg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">saving</span> <span class="o">==</span> <span class="n">greedy_saving</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">cut_full</span><span class="p">:</span>
                    <span class="n">to_loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">to_loop</span><span class="o">.</span><span class="n">pop</span><span class="p">()}</span>
                    <span class="n">pivots</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Designated vertices that can be excluded for each pivot.</span>
        <span class="n">fqs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">subgq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">part</span> <span class="o">==</span> <span class="n">k</span><span class="o">.</span><span class="n">part</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pivots</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">excl</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fqs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">to_loop</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_loop</span> <span class="o">-=</span> <span class="n">excl</span>

        <span class="k">for</span> <span class="n">q_v</span> <span class="ow">in</span> <span class="n">to_loop</span><span class="p">:</span>
            <span class="n">q_d</span> <span class="o">=</span> <span class="n">subg</span><span class="p">[</span><span class="n">q_v</span><span class="p">]</span>
            <span class="n">part</span><span class="p">,</span> <span class="n">vert</span> <span class="o">=</span> <span class="n">q_v</span><span class="o">.</span><span class="n">part</span><span class="p">,</span> <span class="n">q_v</span><span class="o">.</span><span class="n">vert</span>

            <span class="c1">#</span>
            <span class="c1"># cand.remove(q)</span>
            <span class="c1">#</span>
            <span class="n">cand</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q_v</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Q.append(q)</span>
            <span class="c1">#</span>
            <span class="n">curr</span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">vert</span><span class="p">,</span> <span class="n">q_d</span><span class="o">.</span><span class="n">coeff</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">q_d</span><span class="o">.</span><span class="n">leading_coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="n">q_d</span><span class="o">.</span><span class="n">leading_coeff</span>
            <span class="n">new_terms</span> <span class="o">=</span> <span class="n">q_d</span><span class="o">.</span><span class="n">terms</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">&amp;</span> <span class="n">new_terms</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">|=</span> <span class="n">new_terms</span>
            <span class="n">savings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_saving</span> <span class="o">+</span> <span class="n">q_d</span><span class="o">.</span><span class="n">saving</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># adj_q = adj[q]</span>
            <span class="c1"># subg_q = subg &amp; adj_q</span>
            <span class="c1">#</span>
            <span class="n">subg_q</span> <span class="o">=</span> <span class="n">subgq</span><span class="p">[</span><span class="n">q_v</span><span class="p">]</span>

            <span class="c1">#</span>
            <span class="c1"># if not subg_q:</span>
            <span class="c1">#    yield Q[:]</span>
            <span class="c1">#</span>
            <span class="c1"># Moved to top for clarity.</span>
            <span class="c1">#</span>

            <span class="c1">#</span>
            <span class="c1"># cand_q = cand &amp; adj_q</span>
            <span class="c1">#</span>
            <span class="n">cand_q</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cand</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">subg_q</span><span class="p">}</span>

            <span class="c1"># if cand_q:</span>
            <span class="c1">#     for clique in expand(subg_q, cand_q):</span>
            <span class="c1">#         yield clique</span>

            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand</span><span class="p">(</span><span class="n">subg_q</span><span class="p">,</span> <span class="n">cand_q</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Q.pop()</span>
            <span class="c1">#</span>
            <span class="n">curr</span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">&amp;</span> <span class="n">new_terms</span> <span class="o">==</span> <span class="n">new_terms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">^=</span> <span class="n">new_terms</span>
            <span class="n">savings</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">q_d</span><span class="o">.</span><span class="n">leading_coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">continue</span>

    <span class="k">def</span> <span class="nf">_update_delta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">new_v</span><span class="p">:</span> <span class="n">_DesVert</span><span class="p">,</span> <span class="n">new_d</span><span class="p">:</span> <span class="n">_Delta</span><span class="p">,</span>
            <span class="n">curr_v</span><span class="p">:</span> <span class="n">_DesVert</span><span class="p">,</span> <span class="n">curr_d</span><span class="p">:</span> <span class="n">_Delta</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Delta</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Update the delta assuming a new node is added to the stack.</span>

<span class="sd">        This is the core and performance bottleneck of the Bron-Kerbosch</span>
<span class="sd">        algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_terms</span> <span class="o">=</span> <span class="n">new_d</span><span class="o">.</span><span class="n">terms</span>
        <span class="n">curr_terms</span> <span class="o">=</span> <span class="n">curr_d</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">if</span> <span class="n">new_terms</span> <span class="o">&amp;</span> <span class="n">curr_terms</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">new_p</span> <span class="o">=</span> <span class="n">new_v</span><span class="o">.</span><span class="n">part</span>
        <span class="n">curr_p</span> <span class="o">=</span> <span class="n">curr_v</span><span class="o">.</span><span class="n">part</span>
        <span class="n">curr_coeff</span> <span class="o">=</span> <span class="n">curr_d</span><span class="o">.</span><span class="n">coeff</span>
        <span class="n">new_leading_coeff</span> <span class="o">=</span> <span class="n">new_d</span><span class="o">.</span><span class="n">leading_coeff</span>
        <span class="n">curr_leading_coeff</span> <span class="o">=</span> <span class="n">curr_d</span><span class="o">.</span><span class="n">leading_coeff</span>

        <span class="n">updated_d</span> <span class="o">=</span> <span class="n">_Delta</span><span class="p">(</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">curr_coeff</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="o">=</span><span class="n">curr_leading_coeff</span><span class="p">,</span>
            <span class="n">terms</span><span class="o">=</span><span class="n">curr_terms</span><span class="p">,</span> <span class="n">exc_cost</span><span class="o">=</span><span class="n">curr_d</span><span class="o">.</span><span class="n">exc_cost</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">new_p</span> <span class="o">==</span> <span class="n">curr_p</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_leading_coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">curr_leading_coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">updated_d</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">curr_leading_coeff</span> <span class="o">/</span> <span class="n">new_leading_coeff</span>
                <span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="n">updated_d</span><span class="o">.</span><span class="n">leading_coeff</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">new_neighb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constr_graph</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">new_v</span><span class="o">.</span><span class="n">vert</span><span class="p">]</span>
            <span class="n">curr_vert</span> <span class="o">=</span> <span class="n">curr_v</span><span class="o">.</span><span class="n">vert</span>
            <span class="k">if</span> <span class="n">curr_vert</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_neighb</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">new_neighb</span><span class="p">[</span><span class="n">curr_vert</span><span class="p">][</span><span class="s1">&#39;info&#39;</span><span class="p">]</span>

            <span class="n">edge_term</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="o">.</span><span class="n">term</span>
            <span class="n">if_conflict</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">edge_term</span> <span class="o">&amp;</span> <span class="n">new_terms</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">edge_term</span> <span class="o">&amp;</span> <span class="n">curr_terms</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="n">edge_term</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terms</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_conflict</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">updated_d</span><span class="o">.</span><span class="n">terms</span> <span class="o">|=</span> <span class="n">edge_term</span>

            <span class="n">updated_d</span><span class="o">.</span><span class="n">exc_cost</span> <span class="o">+=</span> <span class="n">edge</span><span class="o">.</span><span class="n">exc_cost</span>

            <span class="n">edge_coeff</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">coeff</span>

            <span class="k">if</span> <span class="n">new_leading_coeff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># The previous node gives the first edge.</span>
                <span class="n">updated_d</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">edge_coeff</span> <span class="o">/</span> <span class="n">new_leading_coeff</span>
                <span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This node gives the first edge.</span>
                <span class="n">updated_d</span><span class="o">.</span><span class="n">leading_coeff</span> <span class="o">=</span> <span class="n">edge_coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span> <span class="o">=</span> <span class="n">edge_coeff</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leading_coeff</span> <span class="o">*</span> <span class="n">new_d</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">proj</span> <span class="o">-</span> <span class="n">curr_coeff</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>

        <span class="n">n_verts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_curr</span><span class="p">]</span>
        <span class="n">n_verts</span><span class="p">[</span><span class="n">new_p</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">gross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vert_gross</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">n_verts</span><span class="p">)][</span><span class="n">curr_p</span><span class="p">]</span>

        <span class="n">updated_d</span><span class="o">.</span><span class="n">saving</span> <span class="o">=</span> <span class="n">gross</span> <span class="o">-</span> <span class="n">updated_d</span><span class="o">.</span><span class="n">exc_cost</span>

        <span class="k">return</span> <span class="n">updated_d</span>


<span class="k">class</span> <span class="nc">_ConstrGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Constriction graph for a given involvement of indices.</span>

<span class="sd">    We have separate graphs for different involved indices combinations.  For</span>
<span class="sd">    each combination, the graph has the factors as vertices, and actual</span>
<span class="sd">    evaluations with the factors as edges.  Internally, the graph is stored</span>
<span class="sd">    as a NetworkX graph.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">constr_graphs</span><span class="p">:</span> <span class="s1">&#39;_ConstrGraphs&#39;</span><span class="p">,</span> <span class="n">exts_l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">exts_r</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the constriction graph.</span>

<span class="sd">        graphs</span>
<span class="sd">            The constriction graphs.</span>

<span class="sd">        exts_l, exts_r</span>

<span class="sd">            The pair of integers encoding the external indices involved by</span>
<span class="sd">            the two parts of the graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constr_graphs</span> <span class="o">=</span> <span class="n">constr_graphs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="p">(</span><span class="n">exts_l</span><span class="p">,</span> <span class="n">exts_r</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># From canonicalized factor to the vertex number.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The optimal biclique in the current graph.  None when it is not yet</span>
        <span class="c1"># determined, False when it is determined that there is no profitable</span>
        <span class="c1"># biclique in the current graph.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">verts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The nodes in the graph as integers with the information.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node_infos</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_VertInfo</span><span class="p">,</span> <span class="n">_VertInfo</span><span class="p">],</span>
            <span class="n">coeff</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">term</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new edge to the graph.&quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">term_bases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constr_graphs</span><span class="o">.</span><span class="n">term_bases</span>
        <span class="n">repeated_terms_strat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constr_graphs</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">repeated_terms_strat</span>

        <span class="c1"># Treat excess cost first, since it might lead to direct return.</span>
        <span class="n">base_info</span> <span class="o">=</span> <span class="n">term_bases</span><span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">base_info</span><span class="o">.</span><span class="n">count</span>
        <span class="k">assert</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">repeated_terms_strat</span> <span class="o">==</span> <span class="n">RepeatedTermsStrat</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">:</span>
            <span class="n">exc_cost</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">-</span> <span class="n">base_info</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
        <span class="k">elif</span> <span class="n">repeated_terms_strat</span> <span class="o">==</span> <span class="n">RepeatedTermsStrat</span><span class="o">.</span><span class="n">SKIP</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">repeated_terms_strat</span> <span class="o">==</span> <span class="n">RepeatedTermsStrat</span><span class="o">.</span><span class="n">NATURAL</span><span class="p">:</span>
            <span class="n">exc_cost</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">total_cost</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exc_cost</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># For linter.</span>
            <span class="k">assert</span> <span class="kc">None</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node_infos</span><span class="p">:</span>
            <span class="n">canon</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">canon</span>
            <span class="k">if</span> <span class="n">canon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">canon</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_verts</span><span class="p">[</span><span class="n">canon</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">edge_info</span> <span class="o">=</span> <span class="n">_EdgeInfo</span><span class="p">(</span>
            <span class="n">term</span><span class="o">=</span><span class="n">term</span><span class="p">,</span> <span class="n">eval_</span><span class="o">=</span><span class="n">eval_</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">exc_cost</span><span class="o">=</span><span class="n">exc_cost</span>
        <span class="p">)</span>

        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">nodes</span>
        <span class="n">neighb1</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">neighb1</span><span class="p">:</span>
            <span class="c1"># It is possible that two evaluations actually the same be</span>
            <span class="c1"># recorded twice in the evaluation of product nodes because of</span>
            <span class="c1"># symmetry.</span>
            <span class="k">assert</span> <span class="n">neighb1</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">term</span> <span class="o">==</span> <span class="n">edge_info</span><span class="o">.</span><span class="n">term</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">edge_info</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">term</span>

    <span class="k">def</span> <span class="nf">get_opt_biclique</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="p">:</span> <span class="n">_LastStepIdxes</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Size</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Biclique</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get the optimal biclique in the current graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span>

        <span class="n">opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">biclique</span> <span class="ow">in</span> <span class="n">_BronKerbosch</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>

            <span class="n">saving</span> <span class="o">=</span> <span class="n">biclique</span><span class="o">.</span><span class="n">saving</span>

            <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">saving</span> <span class="o">&gt;</span> <span class="n">opt_saving</span><span class="p">:</span>
                <span class="n">opt_saving</span> <span class="o">=</span> <span class="n">saving</span>
                <span class="c1"># Make copy only when we need them.</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">biclique</span><span class="o">.</span><span class="n">parts</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">opt_biclique</span> <span class="o">=</span> <span class="n">_Biclique</span><span class="p">(</span>
                    <span class="n">parts</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="n">leading_coeff</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">leading_coeff</span><span class="p">,</span>
                    <span class="n">terms</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">,</span> <span class="n">saving</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">saving</span><span class="p">,</span>
                    <span class="n">constr_graph</span><span class="o">=</span><span class="n">biclique</span><span class="o">.</span><span class="n">constr_graph</span>
                <span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">opt_biclique</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="n">opt_saving</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="n">opt_biclique</span>
            <span class="k">return</span> <span class="n">opt_saving</span><span class="p">,</span> <span class="n">opt_biclique</span>

    <span class="k">def</span> <span class="nf">remove_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges for the given terms.</span>

<span class="sd">        Vertices no longer connected to anything is removed as well.  If a</span>
<span class="sd">        value of True is returned, we have an empty graph after the removal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">&amp;</span> <span class="n">terms</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges2remove</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">.</span><span class="n">term</span> <span class="o">&amp;</span> <span class="n">terms</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges2remove</span><span class="p">)</span>
            <span class="n">nodes2remove</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes_iter</span><span class="p">()</span> <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes2remove</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">^=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">&amp;</span> <span class="n">terms</span>

            <span class="c1"># Reset cached optimal biclique.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">_ConstrGraphs</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">_LastStepIdxes</span><span class="p">,</span> <span class="n">_ConstrGraph</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;The constriction graphs from a sum of contractions.</span>

<span class="sd">    The constriction graphs are organized according to their external and</span>
<span class="sd">    summation indices involved by the factors in the last step to achieve</span>
<span class="sd">    better performance with one big graph separated into pieces. With this</span>
<span class="sd">    decomposition, for instance, we can cache maximum bicliques in subgraphs</span>
<span class="sd">    unaffected by the latest constriction.</span>

<span class="sd">    Here just the basic data is defined, with most actual operations directly</span>
<span class="sd">    performed inside the optimizer.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    bases</span>
<span class="sd">        The mapping from the actual base to the base info.</span>

<span class="sd">    term_bases</span>
<span class="sd">        The list of base info for each of the terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;opt&#39;</span><span class="p">,</span>
        <span class="s1">&#39;bases&#39;</span><span class="p">,</span>
        <span class="s1">&#39;term_bases&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="s1">&#39;_Optimizer&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the graphs.</span>

<span class="sd">        Here only the most basic resource initialization is performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="n">_Base</span><span class="p">,</span> <span class="n">_BaseInfo</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># None for plain scalar terms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_bases</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_BaseInfo</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_opt_biclique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_LastStepIdxes</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_Biclique</span><span class="p">]</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Choose the most profitable biclique.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">opt_saving</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_last_step_idxes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">opt_biclique</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">last_step_idxes</span><span class="p">,</span> <span class="n">constr_graph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">curr_opt_saving</span><span class="p">,</span> <span class="n">curr_opt_biclique</span> <span class="o">=</span> <span class="n">constr_graph</span><span class="o">.</span><span class="n">get_opt_biclique</span><span class="p">(</span>
                <span class="n">last_step_idxes</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">curr_opt_saving</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">opt_saving</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">curr_opt_saving</span> <span class="o">&gt;</span> <span class="n">opt_saving</span><span class="p">:</span>
                <span class="n">opt_saving</span> <span class="o">=</span> <span class="n">curr_opt_saving</span>
                <span class="n">opt_last_step_idxes</span> <span class="o">=</span> <span class="n">last_step_idxes</span>
                <span class="n">opt_biclique</span> <span class="o">=</span> <span class="n">curr_opt_biclique</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">opt_last_step_idxes</span><span class="p">,</span> <span class="n">opt_biclique</span>

    <span class="k">def</span> <span class="nf">cleanup_constred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">if_untouched</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">biclique</span><span class="p">:</span> <span class="n">_Biclique</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Clean up the terms after a constriction.&quot;&quot;&quot;</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="n">biclique</span><span class="o">.</span><span class="n">terms</span>
        <span class="k">assert</span> <span class="n">if_untouched</span> <span class="o">&amp;</span> <span class="n">terms</span> <span class="o">==</span> <span class="n">terms</span>
        <span class="n">if_untouched</span> <span class="o">^=</span> <span class="n">terms</span>

        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">last_step_idxes</span><span class="p">,</span> <span class="n">constr_graph</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">if_empty</span> <span class="o">=</span> <span class="n">constr_graph</span><span class="o">.</span><span class="n">remove_terms</span><span class="p">(</span><span class="n">biclique</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">if_empty</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">if_untouched</span>


<span class="c1">#</span>
<span class="c1"># Core optimizer class</span>
<span class="c1"># ~~~~~~~~~~~~~~~~~~~~</span>
<span class="c1">#</span>


<span class="k">class</span> <span class="nc">_Optimizer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Optimizer for tensor contraction computations.</span>

<span class="sd">    This internal optimizer can only be used once for one set of input.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Public functions.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">interm_fmt</span><span class="p">,</span>
            <span class="n">contr_strat</span><span class="p">,</span> <span class="n">opt_sum</span><span class="p">,</span> <span class="n">repeated_terms_strat</span><span class="p">,</span> <span class="n">opt_symm</span><span class="p">,</span> <span class="n">req_an_opt</span><span class="p">,</span>
            <span class="n">greedy_cutoff</span><span class="p">,</span> <span class="n">drop_cutoff</span><span class="p">,</span> <span class="n">remove_shallow</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the optimizer.&quot;&quot;&quot;</span>

        <span class="c1"># Information to be read from the input computations.</span>
        <span class="c1">#</span>
        <span class="c1"># The only drudge for the inputs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># The only variable for range sizes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Mapping from the substituted range to original range.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Symbols that should not be used for dummies.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Read, process, and verify user input.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_form_grain</span><span class="p">(</span><span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span> <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span>
        <span class="p">]</span>

        <span class="c1"># Dummies stock in terms of the substituted range.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">dumms</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Storage of user options to be accessed during the optimization.</span>
        <span class="c1">#</span>
        <span class="c1"># Public for the each of accessing from other internal classes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interm_fmt</span> <span class="o">=</span> <span class="n">interm_fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contr_strat</span> <span class="o">=</span> <span class="n">contr_strat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_sum</span> <span class="o">=</span> <span class="n">opt_sum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeated_terms_strat</span> <span class="o">=</span> <span class="n">repeated_terms_strat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_symm</span> <span class="o">=</span> <span class="n">opt_symm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_an_opt</span> <span class="o">=</span> <span class="n">req_an_opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greedy_cutoff</span> <span class="o">=</span> <span class="n">greedy_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_cutoff</span> <span class="o">=</span> <span class="n">drop_cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_shallow</span> <span class="o">=</span> <span class="n">remove_shallow</span>

        <span class="c1"># Other internal data preparation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># From intermediate base to actual evaluation node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># From the canonical form to intermediate base.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given computations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

        <span class="n">res_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize</span><span class="p">(</span><span class="n">res_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res</span>

    <span class="c1">#</span>
    <span class="c1"># User input pre-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_form_grain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comput</span><span class="p">,</span> <span class="n">substs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form grain for a given computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">curr_drudge</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">drudge</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="o">=</span> <span class="n">curr_drudge</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">curr_drudge</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid computations to optimize, containing two drudges&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="p">,</span> <span class="n">curr_drudge</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Externals processing.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>
        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">}</span>

        <span class="c1"># Terms processing.</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">rhs_terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid term to optimize&#39;</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="s1">&#39;expecting scalar&#39;</span>
                <span class="p">)</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sums</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span>

            <span class="c1"># Add the true free symbols to the exclusion set.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|=</span> <span class="n">term</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">-</span> <span class="n">ext_symbs</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()))</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_proc_sums</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a summation list.</span>

<span class="sd">        The ranges will be replaced with substituted sizes.  Relevant members of</span>
<span class="sd">        the optimizer will also be updated.  User error will also be reported.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">range_</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>

            <span class="n">new_range</span><span class="p">,</span> <span class="n">range_var</span> <span class="o">=</span> <span class="n">form_sized_range</span><span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="n">substs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">range_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">=</span> <span class="n">range_var</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span> <span class="o">!=</span> <span class="n">range_var</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Invalid range&#39;</span><span class="p">,</span> <span class="n">range_</span><span class="p">,</span> <span class="s1">&#39;unexpected symbol&#39;</span><span class="p">,</span>
                        <span class="n">range_var</span><span class="p">,</span> <span class="s1">&#39;conflicting with&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_range_var</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">new_range</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_</span>
            <span class="k">elif</span> <span class="n">range_</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Invalid ranges&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">new_range</span><span class="p">]),</span>
                    <span class="s1">&#39;duplicated labels&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">symb</span><span class="p">,</span> <span class="n">new_range</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Optimization result post-processing.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_linearize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">optimized</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_EvalNode</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Linearize optimized forms of the evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Separate the intermediates and the results so that the results can be</span>
        <span class="c1"># guaranteed to be at the end of the evaluation sequence.</span>
        <span class="n">interms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">interms</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">interms</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_set_n_refs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set reference counts from an evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># We need to find an evaluation with optimal cost.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
        <span class="p">)]</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="n">possible_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">possible_refs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible_refs</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dep_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
            <span class="n">dep_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_refs</span><span class="p">(</span><span class="n">dep_node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linearize evaluation rooted in the given node into the result.</span>

<span class="sd">        If keep if set to True, the evaluation of the given node will not be</span>
<span class="sd">        appended to the result list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">generated</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">def_</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linearize_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">node</span><span class="o">.</span><span class="n">generated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">def_</span>

    <span class="k">def</span> <span class="nf">_form_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of an evaluation node.</span>

<span class="sd">        The dependencies will also be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_def</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a product evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
        <span class="n">term</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">eval_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="p">),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_prod_def_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the term in the final definition of a product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">amp</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">coeff</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">:</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">interm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">interm</span><span class="p">):</span>
                    <span class="c1"># Inline trivial reference to an input.</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span> <span class="o">**</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
                    <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amp</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">Term</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="p">()),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_form_sum_def</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form the final definition of a sum evaluation node.&quot;&quot;&quot;</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">exts_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span>

        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>

            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">((),</span> <span class="n">term</span><span class="p">,</span> <span class="p">()))</span>
                <span class="c1"># No dependency for pure scalars.</span>
                <span class="k">continue</span>

            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Higher power not possible in sum.</span>

            <span class="c1"># Sum term are guaranteed to be formed from references to products,</span>
            <span class="c1"># never directly written in terms of input.</span>
            <span class="n">term_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">term_node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_input</span><span class="p">(</span><span class="n">term_node</span><span class="p">):</span>
                <span class="c1"># Inline intermediates only used here and simple input</span>
                <span class="c1"># references.</span>

                <span class="n">eval_</span> <span class="o">=</span> <span class="n">term_node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
                <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">factors</span><span class="p">,</span> <span class="n">term_coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">exts_dict</span>
                <span class="p">)</span>

                <span class="c1"># Switch back to evaluation node for using the facilities for</span>
                <span class="c1"># product nodes.</span>
                <span class="n">tmp_node</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                    <span class="n">term_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">term_coeff</span><span class="p">,</span> <span class="n">factors</span>
                <span class="p">)</span>
                <span class="n">new_term</span><span class="p">,</span> <span class="n">term_deps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_def_term</span><span class="p">(</span><span class="n">tmp_node</span><span class="p">)</span>

                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_term</span><span class="p">)</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term_deps</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Term</span><span class="p">(</span>
                    <span class="p">(),</span> <span class="n">term</span><span class="p">,</span> <span class="p">()</span>
                <span class="p">))</span>
                <span class="n">deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">_Grain</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="n">exts</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span>
        <span class="p">),</span> <span class="n">deps</span>

    <span class="k">def</span> <span class="nf">_inline_sum_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">res</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inline the summation terms from single-reference terms.</span>

<span class="sd">        This function mutates the given result list rather than returning the</span>
<span class="sd">        result to avoid repeated list creation in recursive calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sum_term</span> <span class="ow">in</span> <span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">eval_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">if_inline</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">if_inline</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
                    <span class="p">}</span>

                <span class="n">proced_sum_terms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="k">if</span> <span class="n">substs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sum_term</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">sum_terms</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inline_sum_terms</span><span class="p">(</span><span class="n">proced_sum_terms</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_term</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_is_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_EvalNode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a product node is just a trivial reference to an input.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">computs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">_Grain</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Finalize the linearization result.</span>

<span class="sd">        Things will be cast to drudge tensor definitions, with intermediates</span>
<span class="sd">        holding names formed from the format given by user.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">next_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">substs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># For normal substitution of bases.</span>
        <span class="n">repls</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># For removed shallow intermediates</span>

        <span class="k">def</span> <span class="nf">proc_amp</span><span class="p">(</span><span class="n">amp</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Process the amplitude by making the found substitutions.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">repls</span><span class="p">):</span>
                <span class="n">amp</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">amp</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span>

        <span class="c1"># Cache some properties.</span>
        <span class="n">remove_shallow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_shallow</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comput</span> <span class="ow">in</span> <span class="n">computs</span><span class="p">:</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
            <span class="n">if_scalar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="n">comput</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">proc_amp</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_ranges</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">sums</span>
                <span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comput</span><span class="o">.</span><span class="n">terms</span>
            <span class="p">]</span>

            <span class="c1"># No internal intermediates should be leaked.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">free_vars</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comput</span><span class="o">.</span><span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">:</span>

                <span class="n">if_shallow</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">remove_shallow</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">if_shallow</span><span class="p">:</span>
                    <span class="c1"># Remove shallow intermediates.  The saving might be too</span>
                    <span class="c1"># modest to justify the additional memory consumption.</span>
                    <span class="c1">#</span>
                    <span class="c1"># TODO: Move it earlier to a better place.</span>
                    <span class="n">repl_lhs</span> <span class="o">=</span> <span class="n">base</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">base</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">_WILD_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
                    <span class="p">)]</span>
                    <span class="n">repl_rhs</span> <span class="o">=</span> <span class="n">proc_amp</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">_WILD_FACTORY</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)}</span>
                    <span class="p">))</span>
                    <span class="n">repls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">repl_lhs</span><span class="p">,</span> <span class="n">repl_rhs</span><span class="p">))</span>
                    <span class="k">continue</span>  <span class="c1"># No new intermediate added.</span>

                <span class="n">final_base</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Symbol</span> <span class="k">if</span> <span class="n">if_scalar</span> <span class="k">else</span> <span class="n">IndexedBase</span>
                <span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">interm_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">next_idx</span><span class="p">))</span>
                <span class="n">next_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">substs</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_base</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TensorDef</span><span class="p">(</span>
                <span class="n">final_base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">create_tensor</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">())</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="c1">#</span>
    <span class="c1"># Internal support utilities.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_get_next_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the symbol for the next internal intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next_internal_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;gristmillInternalIntermediate</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_write_in_orig_ranges</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the summations in terms of undecorated bare ranges.</span>

<span class="sd">        The labels in the ranges are assumed to be decorated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sums</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_canon_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Term</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Form a canonical label for a list of terms.</span>

<span class="sd">        The new summation list is prepended to the summation list of all terms.</span>
<span class="sd">        The coefficient ahead of the canonical form is returned before the</span>
<span class="sd">        canonical form.  And the permuted new summation list is also returned</span>
<span class="sd">        after the canonical form.  Note that this list contains the original</span>
<span class="sd">        dummies given in the new summation list, while the terms has reset new</span>
<span class="sd">        dummies.</span>

<span class="sd">        Note that the ranges in the new summation list are assumed to be</span>
<span class="sd">        decorated with labels earlier than _SUMMED.  In the result, they are</span>
<span class="sd">        still in decorated forms and are guaranteed to be permuted in the same</span>
<span class="sd">        way for all given terms.  The summations from the terms will be</span>
<span class="sd">        internally decorated but written in bare ranges in the final result.</span>

<span class="sd">        Note that this is definitely a poor man&#39;s version of canonicalization of</span>
<span class="sd">        multi-term tensor definitions with external indices.  A lot of cases</span>
<span class="sd">        cannot be handled well.  Hopefully it can be replaced with a systematic</span>
<span class="sd">        treatment some day in the future.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_dumms</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_sums</span><span class="p">}</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">candidates</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">term</span><span class="p">,</span> <span class="n">canon_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>

            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">)</span>
            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

            <span class="n">candidates</span><span class="p">[</span>
                <span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">))</span>
            <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">canon_sums</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="c1"># Poor man&#39;s canonicalization of external indices.</span>
        <span class="c1">#</span>
        <span class="c1"># This algorithm is not guaranteed to work.  Here we just choose an</span>
        <span class="c1"># ordering of the external indices that is as safe as possible.  But</span>
        <span class="c1"># certainly it is not guaranteed to work for all cases.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Fix it!</span>

        <span class="n">chosen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">new_dumms</span><span class="p">),</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort_key</span>
        <span class="p">))</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">chosen</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">canon_new_sums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Internal deficiency: &#39;</span>
                <span class="s1">&#39;summation intermediate may not be fully canonicalized&#39;</span>
            <span class="p">)</span>
        <span class="c1"># This could also fail when the chosen term has symmetry among the new</span>
        <span class="c1"># summations not present in any other term.  This can be hard to check.</span>

        <span class="n">canon_new_sum</span> <span class="o">=</span> <span class="n">canon_new_sums</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">preferred</span> <span class="o">=</span> <span class="n">prod_</span><span class="p">(</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">[</span><span class="n">chosen</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="n">canon_coeff</span> <span class="o">=</span> <span class="n">_get_canon_coeff</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">preferred</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">canon_term</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_term</span><span class="p">(</span><span class="n">canon_new_sum</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># TODO: Add support for complex conjugation.</span>
            <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">canon_term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">canon_coeff</span><span class="p">))</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">canon_coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">res_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">canon_new_sum</span>

    <span class="k">def</span> <span class="nf">_canon_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sums</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">fix_new</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonicalize a single term.</span>

<span class="sd">        Internal method for _canon_terms, not supposed to be directly called.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_EXT</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_sums</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">fix_new</span> <span class="k">else</span> <span class="n">new_sums</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_SUMMED</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="p">)</span>
        <span class="p">)),</span> <span class="n">term</span><span class="o">.</span><span class="n">amp</span><span class="p">,</span> <span class="p">())</span>
        <span class="n">canoned</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">canon_sums</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">sums</span>
        <span class="n">canon_orig_sums</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">canon_sums</span><span class="p">)</span>

        <span class="n">dumm_reset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">canoned</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="n">canon_orig_sums</span><span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="n">dumms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span>
        <span class="p">)</span>

        <span class="n">canon_new_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">term_new_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">term_sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i_new</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dumm_reset</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">canon_sums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">_SUMMED</span><span class="p">:</span>
                <span class="c1"># Existing summations.</span>
                <span class="n">term_sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fix_new</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_sums</span><span class="p">[</span><span class="n">i_new</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">range_</span> <span class="o">=</span> <span class="n">new_sums</span><span class="p">[</span><span class="n">i_new</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">range_</span> <span class="o">=</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">canon_new_sums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_</span><span class="p">))</span>
                <span class="n">term_new_sums</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_</span><span class="p">))</span>
                <span class="n">i_new</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">dumm_reset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">term_new_sums</span><span class="p">,</span> <span class="n">term_sums</span>
        <span class="p">))),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">canon_new_sums</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_interm_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_IntermRef</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parse an expression that is possibly an intermediate reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="n">base</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">power</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="n">ref</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Indexed</span><span class="p">):</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>
                <span class="k">assert</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_IntermRef</span><span class="p">(</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interm_ref</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the content of an intermediate reference.</span>

<span class="sd">        This function might be removed after the new factorization algorithm is</span>
<span class="sd">        implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">interm_ref</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_sum</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">i</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_power</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_index_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the sum node&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">term_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">term_def</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_index_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Substitute the external indices in the evaluation node.&quot;&quot;&quot;</span>

        <span class="n">substs</span><span class="p">,</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_substs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">factors</span><span class="p">),</span> <span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">excl</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_raise_power</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Term</span><span class="p">],</span> <span class="n">exp</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Term</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Raise the sum of the given terms to the given power.&quot;&quot;&quot;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: typing.List[Term]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">exp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: Make the multiplication more efficient.</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">mul_term</span><span class="p">(</span>
                    <span class="n">j</span><span class="p">,</span> <span class="n">dumms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span>
                    <span class="n">excl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span> <span class="o">|</span> <span class="n">i</span><span class="o">.</span><span class="n">free_vars</span> <span class="o">|</span> <span class="n">j</span><span class="o">.</span><span class="n">free_vars</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">terms</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">curr</span>

    <span class="c1">#</span>
    <span class="c1"># General optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_form_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grain</span><span class="p">:</span> <span class="n">_Grain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation node from a tensor definition.</span>

<span class="sd">        This is the entry point for optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We assume it is fully simplified and expanded by grist preparation.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">grain</span><span class="o">.</span><span class="n">terms</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Tensor is constant zero, probably it is not what you meant&#39;</span><span class="p">,</span>
                <span class="n">grain</span><span class="o">.</span><span class="n">base</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span>
            <span class="n">grain</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">terms</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the evaluation of the given node.</span>

<span class="sd">        The evaluation methods will be filled with, possibly multiple, method of</span>
<span class="sd">        evaluations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For node with known evaluations, skip actual optimization.  This</span>
        <span class="c1"># enables the acceleration from dynamic programming.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Sum</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sum</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_prod</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_form_prod_interm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Interm</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form a product intermediate.</span>

<span class="sd">        The factors are assumed to be all non-trivial factors needing</span>
<span class="sd">        processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_EXT</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">Term</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sums</span><span class="p">),</span> <span class="n">prod_</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">(),</span> <span class="p">())</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span>
            <span class="n">decored_exts</span><span class="p">,</span> <span class="p">[</span><span class="n">term</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">key_term</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">key_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
            <span class="n">key_sums</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]</span>

            <span class="c1"># The external symbols will automatically be considered in</span>
            <span class="c1"># get_amp_factors since they are in the summation list right now.</span>
            <span class="n">key_factors</span><span class="p">,</span> <span class="n">key_coeff</span> <span class="o">=</span> <span class="n">key_term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">)</span>
            <span class="n">interm</span> <span class="o">=</span> <span class="n">_Prod</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">key_exts</span><span class="p">,</span> <span class="n">key_sums</span><span class="p">,</span> <span class="n">key_coeff</span><span class="p">,</span> <span class="n">key_factors</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">interm</span>

        <span class="k">return</span> <span class="n">_Interm</span><span class="p">(</span>
            <span class="n">ref</span><span class="o">=</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">canon_exts</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_form_sum_interm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Term</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Interm</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form a sum intermediate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">decored_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">replace_label</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">_EXT</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">exts</span>
        <span class="p">)</span>
        <span class="n">n_exts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">)</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">canon_terms</span><span class="p">,</span> <span class="n">canon_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canon_terms</span><span class="p">(</span><span class="n">decored_exts</span><span class="p">,</span> <span class="n">terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">canon_terms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">canon_terms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_next_internal</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms_canon</span><span class="p">[</span><span class="n">canon_terms</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span>

            <span class="n">node_exts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">node_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">canon_terms</span><span class="p">:</span>
                <span class="n">term_exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_in_orig_ranges</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[:</span><span class="n">n_exts</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">node_exts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">node_exts</span> <span class="o">=</span> <span class="n">term_exts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">node_exts</span> <span class="o">==</span> <span class="n">term_exts</span>
                <span class="n">node_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sums</span><span class="o">=</span><span class="n">term</span><span class="o">.</span><span class="n">sums</span><span class="p">[</span><span class="n">n_exts</span><span class="p">:]))</span>
                <span class="k">continue</span>

            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_from_terms</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">node_exts</span><span class="p">,</span> <span class="n">node_terms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_Interm</span><span class="p">(</span>
            <span class="n">ref</span><span class="o">=</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">canon_exts</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_form_sum_from_terms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Term</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form a summation node for given the terms.</span>

<span class="sd">        No processing is done in this method.  It just forms the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plain_scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exts</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">sums</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">sums</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plain_scalars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">interm_ref</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">)</span>
                <span class="n">sum_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interm_ref</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plain_scalars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sum_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum_</span><span class="p">(</span><span class="n">plain_scalars</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_Sum</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sum_terms</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Sum optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_node</span><span class="p">:</span> <span class="n">_Sum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the summation node.&quot;&quot;&quot;</span>

        <span class="c1"># We first optimize the common terms.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">scalars</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_organize_sum_terms</span><span class="p">(</span><span class="n">sum_node</span><span class="o">.</span><span class="n">sum_terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_sum</span><span class="p">:</span>
            <span class="n">new_terms</span><span class="p">,</span> <span class="n">old_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constr_sum</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="n">terms</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_symm</span><span class="p">:</span>
            <span class="n">old_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_common_symmtrization</span><span class="p">(</span><span class="n">old_terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="n">scalars</span> <span class="o">+</span> <span class="n">old_terms</span> <span class="o">+</span> <span class="n">new_terms</span>
        <span class="n">sum_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Sum</span><span class="p">(</span>
            <span class="n">sum_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sum_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">res_terms</span>
        <span class="p">)]</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_organize_sum_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Expr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">_OrgTerms</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Organize terms in the summation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Intermediate base -&gt; (indices -&gt; coefficient)</span>
        <span class="c1">#</span>
        <span class="c1"># This first gather terms with the same reference to deeper nodes.</span>
        <span class="n">org_terms</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">_ZERO</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">plain_scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plain_scalars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">power</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">org_terms</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">base</span><span class="p">][</span><span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span>
            <span class="k">continue</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">org_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                    <span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">plain_scalars</span><span class="p">,</span> <span class="n">res_terms</span><span class="p">,</span> <span class="n">org_terms</span>

    <span class="k">def</span> <span class="nf">_optimize_common_symmtrization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize common symmetrization in the intermediate references.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res_terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exts_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">scalars</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">org_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_organize_sum_terms</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">scalars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Indices, coeffs tuple -&gt; base, coeff</span>
        <span class="n">pull_info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">org_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">_index</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Here we use name for sorting directly, since here we cannot</span>
                <span class="c1"># have general expressions hence no need to use the expensive</span>
                <span class="c1"># sort_key.</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># Indices/coefficient pairs.</span>
                <span class="n">raw</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">leading_coeff</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">pull_info</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">/</span> <span class="n">leading_coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">raw</span>
                <span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">leading_coeff</span><span class="p">))</span>

        <span class="c1"># Now we treat the terms from which new intermediates might be pulled</span>
        <span class="c1"># out.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pull_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># No need to form a new intermediate.</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pivot_ref</span> <span class="o">=</span> <span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">pivot</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need to form an intermediate here.</span>
                <span class="n">interm_exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">exts_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivot</span>
                <span class="p">)</span>
                <span class="n">interm_terms</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">term</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">_index</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">pivot</span><span class="p">))</span>
                <span class="p">]</span>
                <span class="n">pivot_ref</span><span class="p">,</span> <span class="n">interm_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span>
                    <span class="n">interm_exts</span><span class="p">,</span> <span class="n">interm_terms</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">interm_node</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">substs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">res_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pivot_ref</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substs</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">res_terms</span>

    <span class="k">def</span> <span class="nf">constr_sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constrict the summations greedily.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">if_untouched</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">constr_graphs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_constr_graphs</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

            <span class="n">last_step_idxes</span><span class="p">,</span> <span class="n">biclique</span> <span class="o">=</span> <span class="n">constr_graphs</span><span class="o">.</span><span class="n">get_opt_biclique</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">last_step_idxes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_form_constred_term</span><span class="p">(</span>
                <span class="n">last_step_idxes</span><span class="p">,</span> <span class="n">biclique</span>
            <span class="p">))</span>
            <span class="n">if_untouched</span> <span class="o">=</span> <span class="n">constr_graphs</span><span class="o">.</span><span class="n">cleanup_constred</span><span class="p">(</span>
                <span class="n">if_untouched</span><span class="p">,</span> <span class="n">biclique</span>
            <span class="p">)</span>

            <span class="k">continue</span>
        <span class="c1"># End Main loop.</span>

        <span class="n">untouched_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="k">if</span> <span class="n">if_untouched</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">new_terms</span><span class="p">,</span> <span class="n">untouched_terms</span>

    <span class="k">def</span> <span class="nf">_form_constr_graphs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">terms</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ConstrGraphs</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form the constriction graphs for the terms.</span>

<span class="sd">        The additional information about the bases of each of the terms are</span>
<span class="sd">        also returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">constr_graphs</span> <span class="o">=</span> <span class="n">_ConstrGraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">base_infos</span> <span class="o">=</span> <span class="n">constr_graphs</span><span class="o">.</span><span class="n">bases</span>
        <span class="n">term_bases</span> <span class="o">=</span> <span class="n">constr_graphs</span><span class="o">.</span><span class="n">term_bases</span>
        <span class="n">term_ref_nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term_idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">term_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">term_ref_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">base</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">base</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
            <span class="n">term_ref_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ref</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">base_infos</span><span class="p">:</span>
                <span class="n">base_info</span> <span class="o">=</span> <span class="n">base_infos</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_info</span> <span class="o">=</span> <span class="n">_BaseInfo</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="n">base_infos</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_info</span>

            <span class="n">base_info</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">term_bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base_info</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># This loop should have the correct bases count.</span>
        <span class="k">for</span> <span class="n">term_idx</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="n">ref</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">term_ref_nodes</span><span class="p">[</span><span class="n">term_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">eval_</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">evals</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">_Prod</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_aug_constr_graphs_4_eval</span><span class="p">(</span>
                    <span class="n">constr_graphs</span><span class="p">,</span> <span class="n">term_idx</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">eval_</span><span class="p">,</span> <span class="n">exts</span>
                <span class="p">)</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">constr_graphs</span>

    <span class="k">def</span> <span class="nf">_aug_constr_graphs_4_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">_ConstrGraphs</span><span class="p">,</span> <span class="n">term_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ref</span><span class="p">:</span> <span class="n">_IntermRef</span><span class="p">,</span>
            <span class="n">eval_</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">exts</span><span class="p">:</span> <span class="n">_SrPairs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Augment the constriction graphs for an evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">eval_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_prod</span><span class="p">(</span><span class="n">eval_</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">eval_term</span> <span class="o">=</span> <span class="n">eval_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ext_symbs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">}</span>

        <span class="n">factors</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">eval_term</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span>
        <span class="p">)</span>
        <span class="n">coeff</span> <span class="o">*=</span> <span class="n">ref</span><span class="o">.</span><span class="n">coeff</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sums</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span>
            <span class="n">eval_term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="p">))</span>

        <span class="n">excl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_excl</span><span class="p">)</span>
        <span class="n">excl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ext_symbs</span><span class="p">)</span>
        <span class="n">symms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drudge</span><span class="o">.</span><span class="n">symms</span><span class="o">.</span><span class="n">value</span>

        <span class="n">factor_infos</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">f_i</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_content</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">symbs</span> <span class="o">=</span> <span class="n">f_i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="n">exts_idxes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">symbs</span>
            <span class="p">)</span>
            <span class="n">exts_int</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exts_idxes</span>
            <span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sums</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbs</span>

            <span class="c1"># In order to really make sure, the content will be re-canonicalized</span>
            <span class="c1"># based on the current ambient.</span>
            <span class="n">canon</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">canon</span><span class="p">(</span><span class="n">symms</span><span class="o">=</span><span class="n">symms</span><span class="p">)</span><span class="o">.</span><span class="n">reset_dumms</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dumms</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">excl</span> <span class="o">|</span> <span class="n">content</span><span class="o">.</span><span class="n">free_vars</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">canon_coeff</span> <span class="o">=</span> <span class="n">canon</span><span class="o">.</span><span class="n">get_amp_factors</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_interms</span><span class="p">,</span> <span class="n">ext_symbs</span>
            <span class="p">)</span>
            <span class="n">canon</span> <span class="o">=</span> <span class="n">canon</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">canon_coeff</span><span class="p">,</span> <span class="n">skip_vecs</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">canon_coeff</span>

            <span class="n">factor_infos</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">exts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">exts_idxes</span><span class="p">),</span>
                <span class="n">_VertInfo</span><span class="p">(</span><span class="n">exts</span><span class="o">=</span><span class="n">exts_int</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">f_i</span><span class="p">,</span> <span class="n">canon</span><span class="o">=</span><span class="n">canon</span><span class="p">)</span>
            <span class="p">))</span>
            <span class="k">continue</span>

        <span class="n">factor_infos</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">last_step_idxes</span> <span class="o">=</span> <span class="n">_LastStepIdxes</span><span class="p">(</span>
            <span class="n">exts</span><span class="o">=</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">factor_infos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">sums</span><span class="o">=</span><span class="n">sums</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">last_step_idxes</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">constr_graph</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">last_step_idxes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constr_graph</span> <span class="o">=</span> <span class="n">_ConstrGraph</span><span class="p">(</span>
                <span class="n">res</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">factor_infos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span>
            <span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">last_step_idxes</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr_graph</span>

        <span class="n">constr_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span>
            <span class="p">(</span><span class="n">factor_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">factor_infos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">coeff</span><span class="o">=</span><span class="n">coeff</span><span class="p">,</span> <span class="n">term</span><span class="o">=</span><span class="n">term_idx</span><span class="p">,</span> <span class="n">eval_</span><span class="o">=</span><span class="n">eval_</span>
        <span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_form_constred_term</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="p">:</span> <span class="n">_LastStepIdxes</span><span class="p">,</span> <span class="n">biclique</span><span class="p">:</span> <span class="n">_Biclique</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Form the factored term for the given constriction.&quot;&quot;&quot;</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="n">biclique</span><span class="o">.</span><span class="n">constr_graph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">node</span>

        <span class="c1"># Form and optimize the two new summation nodes.</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">biclique</span><span class="o">.</span><span class="n">leading_coeff</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">exts_i</span><span class="p">,</span> <span class="n">part_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">biclique</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">scaled_terms</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">verts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">canon</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">part_i</span>
            <span class="p">]</span>

            <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">exts_i</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="o">.</span><span class="n">sums</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaled_terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_sum_interm</span><span class="p">(</span><span class="n">exts</span><span class="p">,</span> <span class="n">scaled_terms</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scaled_term</span> <span class="o">=</span> <span class="n">scaled_terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span>
                    <span class="n">exts</span><span class="p">,</span> <span class="n">scaled_term</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="p">[</span><span class="n">scaled_term</span><span class="o">.</span><span class="n">amp</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">eval_node</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Form the contraction node for the two new summation nodes.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">last_step_idxes</span><span class="o">.</span><span class="n">exts</span><span class="p">)),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">))</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">eval_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span>
            <span class="n">exts</span><span class="p">,</span> <span class="n">last_step_idxes</span><span class="o">.</span><span class="n">sums</span><span class="p">,</span> <span class="n">factors</span>
        <span class="p">)</span>

        <span class="c1"># Make phony optimization of the intermediate.</span>
        <span class="n">eval_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">eval_node</span><span class="o">.</span><span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_node</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1">#</span>
    <span class="c1"># Product optimization.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">_optimize_prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optimize the product evaluation node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This function should not be called on an already-optimized node.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_factors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_factors</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod_node</span><span class="p">)</span>
            <span class="n">sums_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">)</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">get_total_size</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="o">*</span> <span class="n">sums_size</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">sums_size</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">return</span>

        <span class="n">contr_strat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contr_strat</span>
        <span class="n">greedy_mode</span> <span class="o">=</span> <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">GREEDY</span>
        <span class="n">normal_mode</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">OPT</span> <span class="ow">or</span> <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">TRAV</span>
        <span class="p">)</span>
        <span class="n">exhaust_mode</span> <span class="o">=</span> <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">EXHAUST</span>
        <span class="n">if_inclusive</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">TRAV</span> <span class="ow">or</span>
            <span class="n">contr_strat</span> <span class="o">==</span> <span class="n">ContrStrat</span><span class="o">.</span><span class="n">EXHAUST</span>
        <span class="p">)</span>

        <span class="n">evals</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">evals</span>
        <span class="n">optimal_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">biparts_gen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_factor_biparts</span><span class="p">(</span>
                <span class="n">prod_node</span>
        <span class="p">):</span>
            <span class="k">def</span> <span class="nf">need_break</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;If we need to break the current loop.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">optimal_cost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">greedy_mode</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">normal_mode</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">final_cost</span> <span class="o">&gt;</span> <span class="n">optimal_cost</span>
                <span class="k">elif</span> <span class="n">exhaust_mode</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">need_break</span><span class="p">():</span>
                <span class="k">break</span>
            <span class="c1"># Else</span>

            <span class="k">for</span> <span class="n">bipart</span> <span class="ow">in</span> <span class="n">biparts_gen</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">need_break</span><span class="p">():</span>
                    <span class="k">break</span>

                <span class="c1"># Recurse, two parts.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bipart</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bipart</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_optimize</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">total_cost</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">final_cost</span>
                    <span class="o">+</span> <span class="n">bipart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                    <span class="o">+</span> <span class="n">bipart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">total_cost</span>
                <span class="p">)</span>

                <span class="n">if_new_optimal</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">optimal_cost</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">optimal_cost</span> <span class="o">&gt;</span> <span class="n">total_cost</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">if_new_optimal</span><span class="p">:</span>
                    <span class="n">optimal_cost</span> <span class="o">=</span> <span class="n">total_cost</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">if_inclusive</span><span class="p">:</span>
                        <span class="n">evals</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">if_new_optimal</span> <span class="ow">or</span> <span class="n">if_inclusive</span><span class="p">:</span>
                    <span class="n">new_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_eval</span><span class="p">(</span>
                        <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="n">bipart</span>
                    <span class="p">)</span>
                    <span class="n">new_eval</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">total_cost</span>
                    <span class="n">evals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_eval</span><span class="p">)</span>

                <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">prod_node</span><span class="o">.</span><span class="n">total_cost</span> <span class="o">=</span> <span class="n">optimal_cost</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_gen_factor_biparts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all the bipartitions of factors in a product node.&quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Compute things invariant to different summations for performance.</span>
        <span class="c1">#</span>

        <span class="n">exts</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span>
        <span class="n">exts_total_size</span> <span class="o">=</span> <span class="n">get_total_size</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span>

        <span class="n">ext2idx</span><span class="p">,</span> <span class="n">sum2idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Factors involving each of the summations, as iterable lists.</span>
        <span class="n">sum_infos</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sum2idx</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># Ext and sum involvements of factors.</span>
        <span class="n">factor_infos</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">factors</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sum2idx</span><span class="p">:</span>
                    <span class="n">sum_idx</span> <span class="o">=</span> <span class="n">sum2idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">sum_infos</span><span class="p">[</span><span class="n">sum_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sum_idx</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ext2idx</span><span class="p">:</span>
                    <span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ext2idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="c1">#</span>
        <span class="c1"># Actual two-level generation.</span>
        <span class="c1">#</span>

        <span class="k">for</span> <span class="n">broken_size</span><span class="p">,</span> <span class="n">broken</span> <span class="ow">in</span> <span class="n">_gen_broken_sums</span><span class="p">(</span><span class="n">sums</span><span class="p">):</span>
            <span class="n">broken_sums</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sums</span><span class="p">)</span> <span class="k">if</span> <span class="n">broken</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">]</span>  <span class="c1"># Sums to be retained in the evaluation.</span>
            <span class="n">final_cost</span> <span class="o">=</span> <span class="n">_get_prod_final_cost</span><span class="p">(</span>
                <span class="n">exts_total_size</span><span class="p">,</span> <span class="n">broken_size</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">final_cost</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_biparts_w_kept_sums</span><span class="p">(</span>
                <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken</span><span class="p">,</span> <span class="n">sum_infos</span><span class="p">,</span> <span class="n">factor_infos</span>
            <span class="p">)</span>
            <span class="k">continue</span>

    <span class="k">def</span> <span class="nf">_gen_biparts_w_kept_sums</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">broken</span><span class="p">,</span> <span class="n">sum_infos</span><span class="p">,</span> <span class="n">factor_infos</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate all bipartitions with given summations kept.</span>

<span class="sd">        First the factors are divided into chunks indivisible according to</span>
<span class="sd">        the kept summations.  Then their bipartitions which really break the</span>
<span class="sd">        broken sums are generated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_infos</span><span class="p">)</span>

        <span class="n">dsf</span> <span class="o">=</span> <span class="n">DSF</span><span class="p">(</span><span class="n">n_factors</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sum_infos</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">broken</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">dsf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">dsf</span><span class="o">.</span><span class="n">n_sets</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># The sums, externals, and factors involved by each chunks.</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Map root factors to the indices of the chunk in the above lists.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dsf</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">dsf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">sums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">exts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">chunk</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="n">factors</span><span class="p">[</span><span class="n">chunk</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="n">exts</span><span class="p">[</span><span class="n">chunk</span><span class="p">]</span> <span class="o">|=</span> <span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sums</span><span class="p">[</span><span class="n">chunk</span><span class="p">]</span> <span class="o">|=</span> <span class="n">factor_infos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">continue</span>

        <span class="c1"># Loop over bipartitions of the indivisible chunks.</span>

        <span class="n">n_chunks</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>

            <span class="c1"># Get the sums in the two chunks first.</span>
            <span class="n">sums1</span><span class="p">,</span> <span class="n">sums2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">sums1</span> <span class="o">|=</span> <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sums2</span> <span class="o">|=</span> <span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">broken</span> <span class="o">==</span> <span class="n">broken</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">sums1</span><span class="p">,</span> <span class="n">sums2</span><span class="p">)):</span>

                <span class="c1"># Only now we get the factors and the externals.</span>
                <span class="n">factors1</span><span class="p">,</span> <span class="n">factors2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="n">exts1</span><span class="p">,</span> <span class="n">exts2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chunks</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">p1</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">factors1</span> <span class="o">|=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">exts1</span> <span class="o">|=</span> <span class="n">exts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">factors2</span> <span class="o">|=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">exts2</span> <span class="o">|=</span> <span class="n">exts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">continue</span>

                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_form_part_interm</span><span class="p">(</span><span class="n">prod_node</span><span class="p">,</span> <span class="n">broken</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">exts1</span><span class="p">,</span> <span class="n">sums1</span><span class="p">,</span> <span class="n">factors1</span><span class="p">),</span> <span class="p">(</span><span class="n">exts2</span><span class="p">,</span> <span class="n">sums2</span><span class="p">,</span> <span class="n">factors2</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_form_part_interm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">,</span> <span class="n">broken</span><span class="p">,</span> <span class="n">exts</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an intermediate for a partition for the given factors.&quot;&quot;&quot;</span>

        <span class="n">factors_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span> <span class="k">if</span> <span class="n">factors</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
        <span class="p">]</span>
        <span class="n">exts_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span> <span class="k">if</span> <span class="n">exts</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
        <span class="p">]</span>
        <span class="n">sums_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prod_node</span><span class="o">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sums</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">):</span>
                <span class="c1"># Sums not involved.</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">broken</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">exts_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sums_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_form_prod_interm</span><span class="p">(</span><span class="n">exts_list</span><span class="p">,</span> <span class="n">sums_list</span><span class="p">,</span> <span class="n">factors_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_form_prod_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prod_node</span><span class="p">:</span> <span class="n">_Prod</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span>
            <span class="n">parts</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_Interm</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Form an evaluation for a product node.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">_UNITY</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
            <span class="n">curr_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_interm_ref</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">curr_ref</span><span class="o">.</span><span class="n">coeff</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_ref</span><span class="o">.</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_Prod</span><span class="p">(</span>
            <span class="n">prod_node</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">broken_sums</span><span class="p">,</span>
            <span class="n">coeff</span> <span class="o">*</span> <span class="n">prod_node</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">factors</span>
        <span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Optimization result verification</span>
<span class="c1"># --------------------------------</span>
<span class="c1">#</span>


<div class="viewcode-block" id="verify_eval_seq"><a class="viewcode-back" href="../../api.html#gristmill.verify_eval_seq">[docs]</a><span class="k">def</span> <span class="nf">verify_eval_seq</span><span class="p">(</span>
        <span class="n">eval_seq</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span> <span class="n">res</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">TensorDef</span><span class="p">],</span>
        <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Verify the correctness of an evaluation sequence for the results.</span>

<span class="sd">    The last entries of the evaluation sequence should be in one-to-one</span>
<span class="sd">    correspondence with the original form in the ``res`` argument.  This</span>
<span class="sd">    function returns ``True`` when the evaluation sequence is symbolically</span>
<span class="sd">    equivalent to the given raw form.  When a difference is found,</span>
<span class="sd">    ``ValueError`` will be raised with relevant information.</span>

<span class="sd">    Note that this function can be very slow for large evaluations.  But it is</span>
<span class="sd">    advised to be used for all optimizations in mission-critical tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    eval_seq</span>
<span class="sd">        The evaluation sequence to verify, can be the output from</span>
<span class="sd">        :py:func:`optimize` directly.</span>

<span class="sd">    res</span>
<span class="sd">        The original result to test the evaluation sequence against.  It can be</span>
<span class="sd">        the input to :py:func:`optimize` directly.</span>

<span class="sd">    simplify</span>
<span class="sd">        If simplification is going to be performed after each step of the</span>
<span class="sd">        back-substitution.  It is advised for larger complex evaluations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">n_interms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_res</span>

    <span class="n">substed_eval_seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">defs_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eval_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eval_seq</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">base</span>
        <span class="n">free_vars</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">free_vars</span>
        <span class="n">curr_defs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">defs_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">free_vars</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">defs_dict</span>
        <span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">}</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">eval_</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">subst_all</span><span class="p">(</span><span class="n">curr_defs</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span> <span class="n">excl</span><span class="o">=</span><span class="n">exts</span><span class="p">)</span>
        <span class="n">new_def</span> <span class="o">=</span> <span class="n">TensorDef</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">eval_</span><span class="o">.</span><span class="n">exts</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">substed_eval_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_def</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n_interms</span><span class="p">:</span>
            <span class="n">defs_dict</span><span class="p">[</span>
                <span class="n">base</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">base</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">new_def</span>

        <span class="k">continue</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">substed_eval_seq</span><span class="p">[</span><span class="o">-</span><span class="n">n_res</span><span class="p">:],</span> <span class="n">res</span><span class="p">):</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span> <span class="o">!=</span> <span class="n">ref</span><span class="o">.</span><span class="n">lhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal left-hand sides&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">lhs</span>
            <span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">rhs</span> <span class="o">-</span> <span class="n">ref</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unequal definition for &#39;</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">j</span>
            <span class="p">)</span>
        <span class="k">continue</span>

    <span class="k">return</span> <span class="kc">True</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jinmo Zhao and Gustavo E Scuseria.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>