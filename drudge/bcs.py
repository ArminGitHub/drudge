"""
Drudge for reduced BCS Hamiltonian.
"""

from sympy import Integer, Symbol, IndexedBase

from .drudge import Tensor
from .fock import PartHoleDrudge, SpinOneHalfPartHoleDrudge
from .su2 import SU2LatticeDrudge
from .term import Vec, Range


class ReducedBCSDrudge(SU2LatticeDrudge):
    r"""Drudge for reduced BCS (pairing) Hamiltonian.

    The reduced BCS drudge contains utilities for solving problems around the
    reduced BCS Hamiltonian, or pairing Hamiltonian.  In this problem, we have
    an :math:`\mathfrak{su}(2)`-like algebra generated by subscriptable
    generators :math:`N`, :math:`P`, and :math:`P^\dag`, which satisfies the
    commutations rules

    .. math::

        [N_p, P_q^\dag] & = 2 \delta_{pq} P_q^\dag \\
        [N_p, P_q] &= -2 \delta_{pq} P_q \\
        [P_p, P_q^\dag] &= \delta_{pq} \left( 1 - N_p \right) \\

    where the symbols :math:`p` and :math:`q` can be over two disjoint ranges,
    the particle range and the hole range.  The usage of these two ranges, as
    well as their default symbols, are exactly the same as those in the
    :py:class:`PartHoleDrudge`.

    In addition to the commutation rules, this drudge also has a Hamiltonian
    stored as ``ham`` attribute, which reads

    .. math::

        \epsilon_p N_p + G_{p, q} P^\dag_p P_q

    where :math:`p` and :math:`q` are summed over the two ranges.

    """

    def __init__(
            self, ctx,
            part_range=Range('V', 0, Symbol('nv')),
            part_dumm=PartHoleDrudge.DEFAULT_PART_DUMMS,
            hole_range=Range('O', 0, Symbol('no')),
            hole_dumm=PartHoleDrudge.DEFAULT_HOLE_DUMMS,
            energies=IndexedBase('epsilon'), interact=IndexedBase('G'),
            cartan=Vec('N'), raise_=Vec(r'P^\dag'), lower=Vec('P'),
            root=Integer(2), norm=Integer(1), trail=Integer(-1),
            **kwargs
    ):
        """Initialize the drudge object."""

        # Initialize the base su2 problem.
        super().__init__(
            ctx, cartan=cartan, raise_=raise_, lower=lower, root=root,
            norm=norm, trail=trail, **kwargs
        )

        # Set the range and dummies.
        self.part_range = part_range
        self.hole_range = hole_range
        self.set_dumms(part_range, part_dumm)
        self.set_dumms(hole_range, hole_dumm)
        self.add_resolver_for_dumms()

        # Make additional name definition for the operators.
        self.set_name(cartan, lower, Pdag=raise_)

        # Create the underlying particle-hole drudge with spin.  Note that this
        # drudge is only use internally for VEV evaluation.
        ph_dr = SpinOneHalfPartHoleDrudge(
            ctx, part_orb=(part_range, part_dumm),
            hole_orb=(hole_range, hole_dumm)
        )
        self._ph_dr = ph_dr

        # Translation from su2 generator to the actual fermion operators.
        cr = ph_dr.cr
        an = ph_dr.an
        up, down = ph_dr.spin_vals

        gen_idx = Symbol('p')
        cartan_def = self.define(
            cartan, gen_idx,
            cr[gen_idx, up] * an[gen_idx, up] +
            cr[gen_idx, down] * an[gen_idx, down]
        )
        raise_def = self.define(
            raise_, gen_idx, cr[gen_idx, up] * cr[gen_idx, down]
        )
        lower_def = self.define(
            lower, gen_idx, an[gen_idx, down] * an[gen_idx, up]
        )
        self._defs = [
            cartan_def, raise_def, lower_def
        ]

        # Define the Hamiltonian.
        all_ranges = (part_range, hole_range)
        gen_idx2 = Symbol('q')
        ham = self.sum(
            (gen_idx, all_ranges),
            energies[gen_idx] * cartan[gen_idx]
        ) + self.sum(
            (gen_idx, all_ranges), (gen_idx2, all_ranges),
            interact[gen_idx, gen_idx2] * raise_[gen_idx] * lower[gen_idx2]
        )
        self.ham = ham.simplify()

        # Set additional tensor methods.
        self.set_tensor_method('eval_vev', self.eval_vev)

    def _transl2fermi(self, tensor: Tensor):
        """Translate a tensor object in terms of the fermion operators.

        This is an internally utility.  The resulted tensor has the internal
        fermion drudge object as its owner.
        """
        return Tensor(
            self._ph_dr,
            tensor.subst_all(self._defs).terms
        )

    def eval_vev(self, tensor: Tensor):
        r"""Evaluate the vacuum expectation value.

        The VEV facility works *as if* we do substitution

        .. math::

            P_p &= c_{p \downarrow} c_{p \uparrow} \\
            P^\dag_p &= c^\dag_{p \uparrow} c^\dag_{p \downarrow} \\
            N_p &= c^\dag_{p \uparrow} c_{p \uparrow}
                + c^\dag_{p \downarrow} c_{p \downarrow} \\

        for :math:`p` in either particle or hole range and evaluate the
        expectation value with respect to the Fermi vacuum.
        """

        transled = self._transl2fermi(tensor)
        res = self._ph_dr.eval_fermi_vev(transled)
        return Tensor(self, res.terms)
